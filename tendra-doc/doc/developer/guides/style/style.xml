<?xml version="1.0" standalone="no"?>
<!DOCTYPE article SYSTEM "minidocbook.dtd">

<!-- $Id$ -->

<article>

  <articleinfo>
    <title>Style Guide</title>

	<authorgroup>
		<othercredit class="copyeditor">
			<firstname>Katherine</firstname>
			<surname>Flavel</surname>
			<affiliation><orgname>The TenDRA Project</orgname></affiliation>
		</othercredit>

		<othercredit class="copyeditor">
			<firstname>Jeroen</firstname>
			<surname>Ruigrok van der Werven</surname>
			<affiliation><orgname>The TenDRA Project</orgname></affiliation>
		</othercredit>
	</authorgroup>

    <pubdate>1998</pubdate>

    <copyright>
		<year>2007</year>
		<year>1998</year>
		<holder>The TenDRA Project</holder>
    </copyright>

    <copyright>
		<year>1998</year>
		<holder>DERA</holder>
    </copyright>

	<revhistory>
		<revision role="docs">
			<date>2007-10-01</date>
			<revremark>Split off style documentation from the
				C++ Producer User Guide</revremark>
			<author><firstname>kate</firstname></author>
		</revision>

		<revision role="version">
			<date>1998-07-30</date>
			<authorinitials>DERA</authorinitials>
			<revdescription>
				<para>TenDRA 4.1.2 release.</para>
			</revdescription>
		</revision>
	</revhistory>
  </articleinfo>

	<!-- TODO: this needs to be more language-neutral; we use more than just C. -->

	<!-- TODO de-OSSG -->

	<!-- TODO mention target platforms, APIs, etc (these are on the website) -->

  <chapter id="introduction">
    <title>Introduction</title>

  </chapter>

  <chapter>
    <title>Source code organisation</title>
  <para>
  This section describes the basic organisation of the source code for
  the C++ producer.  This includes the coding conventions applied, the
  application programming interface (API) observed and the division
  of the code into separate modules.
  </para>


  <section id="language">
    <title>C coding standard</title>
  <para>
  The C++ producer is written in a subset of C which is compatible with
  C++ (it compiles with most C compilers, but also bootstraps itself).
  It has been written to conform to the local (OSSG)
  <A HREF="index.html#cstyle">C coding standard</A>; most of the conformance
  checking being automated by use of a
  <A HREF="pragma.html#usr">user-defined compilation profile</A>,
  <code>ossg_std.h</code>.  The standard macros described in the coding
  standard are defined in the standard header <code>ossg.h</code>. This
  is included from the header <code>config.h</code> which is included
  by all source files.  The default definitions for these macros, set
  according to the value of <code>__STDC__</code> and other compiler-defined
  macros, should be correct, but they can be overridden by defining
  the <code>FS_*</code> macros, described in the header, as command-line
  options.
  </para>
  <para>
  The most important of these macros are those used to handle function
  prototypes, enabling both ISO and pre-ISO C compilers to be accommodated.
  Simple function definitions take the form:
  <programlisting language="C++">
ret function
    PROTO_N ( ( p1, p2, ...., pn ) )
    PROTO_T ( par1 p1 X par2 p2 X .... X parn pn )
{
    ....
}</programlisting>
  with the <code>PROTO_N</code> macro being used to list the parameter
  names (note the double bracket) and the <code>PROTO_T</code> macro
  being used to list the parameter types using <code>X</code> (cartesian
  product) as a separator.  The corresponding function declaration will
  have the form:
  <programlisting language="C++">
ret function PROTO_S ( ( par1, par2, ...., parn ) ) ;</programlisting>
  The case where there are no parameter types is defined using:
  <programlisting language="C++">
ret function
    PROTO_Z ()
{
    ....
}</programlisting>
  and declared as:
  <programlisting language="C++">
ret function PROTO_S ( ( void ) ) ;</programlisting>
  Functions with ellipses are defined using:
  <programlisting language="C++">
#if FS_STDARG
#include &lt;stdarg.h&gt;
#else
#include &lt;varargs.h&gt;
#endif

ret function
    PROTO_V ( ( par1 p1, par2 p2, ...., parn pn, ... ) )
{
    va_list args ;
    ....
#if FS_STDARG
    va_start ( args, pn ) ;
#else
    par1 p1 ;
    par2 p2 ;
    ....
    parn pn ;
    va_start ( args ) ;
    p1 = va_arg ( args, par1 ) ;
    p2 = va_arg ( args, par2 ) ;
    ....
    pn = va_arg ( args, parn ) ;
#endif
    ....
    va_end ( args ) ;
    ....
}</programlisting>
  and declared as:
  <programlisting language="C++">
ret function PROTO_W ( ( par1, par2, ...., parn, ... ) ) ;</programlisting>
  Note that <code>&lt;varargs.h&gt;</code> does not allow for parameters
  preceding the <code>va_alist</code>, so the fixed parameters need
  to be explicitly assigned from <code>args</code>.
  </para>
  <para>
  The following <A HREF="pragma.html#keyword">TenDRA keywords</A> are
  defined (with suitable default values for non-TenDRA compilers):
  <programlisting language="C++">
#pragma TenDRA keyword SET for set
#pragma TenDRA keyword UNUSED for discard variable
#pragma TenDRA keyword IGNORE for discard value
#pragma TenDRA keyword EXHAUSTIVE for exhaustive
#pragma TenDRA keyword REACHED for set reachable
#pragma TenDRA keyword UNREACHED for set unreachable
#pragma TenDRA keyword FALL_THROUGH for fall into case</programlisting>
  </para>
  <para>
  Various flags giving properties of the compiler being used are defined
  in <code>ossg.h</code>.  Among the most useful are <code>FS_STDARG</code>,
  which is true if the compiler supports ellipsis functions (see above).
  The macros
  <code>CONST</code> and <code>VOLATILE</code>, to be used in place
  of
  <code>const</code> and <code>volatile</code>, are also defined.
  </para>
  <para>
  A policy of rigorous static program checking is enforced.  The TenDRA
  C producer is applied with the user-defined compilation mode
  <code>ossg_std.h</code> and intermodule checks enabled.  Checking
  is applied with both the C and <code>#pragma token</code>
  <A HREF="../utilities/calc.html"><code>calculus</code> output files</A>.
  The C++ producer itself is applied with the same checks.  <code>gcc
  -Wall</code> and various versions of <code>lint</code> are also periodically
  applied.
  </para>
  </section>

  <section id="api">
    <title>API usage and target dependencies</title>
  <para>
  Most of the API features used in the C++ producer are to be found
  in the ISO C API, with just a couple of extensions from POSIX required.
  These POSIX features can be disabled with minimal loss of functionality
  by defining the macro <code>FS_POSIX</code> to be false.
  </para>
  <para>
  The following features are used from the ISO <code>&lt;stdio.h&gt;</code>
  header:
	<!-- TODO some sort of compound list -->
  <programlisting>
BUFSIZ		EOF		FILE		SEEK_SET
fclose		fflush		fgetc		fgets
fopen		fprintf		fputc		fputs
fread		fseek		fwrite		rewind
sprintf		stderr		stdin		stdout
vfprintf</programlisting>
  from the ISO <code>&lt;stdlib.h&gt;</code> header:
  <programlisting>
EXIT_SUCCESS	EXIT_FAILURE	NULL		abort
exit		free		malloc		realloc
size_t</programlisting>
  and from the ISO <code>&lt;string.h&gt;</code> header:
  <programlisting>
memcmp		memcpy		strchr		strcmp
strcpy		strlen		strncmp		strrchr</programlisting>
  The three headers just mentioned are included in all source files
  via the
  <code>ossg_api.h</code> header file (included by <code>config.h</code>).
  The remaining headers are only included as and when they are needed.
  The following features are used from the ISO <code>&lt;ctype.h&gt;</code>
  header:
  <programlisting>
isalpha		isprint</programlisting>
  from the ISO <code>&lt;limits.h&gt;</code> header:
  <programlisting>
UCHAR_MAX	UINT_MAX	ULONG_MAX</programlisting>
  from the ISO <code>&lt;stdarg.h&gt;</code> header:
  <programlisting>
va_arg		va_end		va_list		va_start</programlisting>
  (note that if <code>FS_STDARG</code> is false the XPG3
  <code>&lt;varargs.h&gt;</code> header is used instead); and from the
  ISO
  <code>&lt;time.h&gt;</code> header:
  <programlisting>
localtime	time		time_t		struct tm
tm::tm_hour	tm::tm_mday	tm::tm_min	tm::tm_mon
tm::tm_sec	tm::tm_year</programlisting>
  The following features are used from the POSIX
  <code>&lt;sys/stat.h&gt;</code> header:
  <programlisting>
stat		struct stat	stat::st_dev	stat::st_ino
stat::st_mtime</programlisting>
  The <code>&lt;sys/types.h&gt;</code> header is also included to provide
  the necessary types for <code>&lt;sys/stat.h&gt;</code>.
  </para>
  <para>
  There are a couple of target dependencies in the producer which can
  overridden using command-line options:
  <itemizedlist>
  <listitem>It assumes that if a count of the number of characters read from
  an input file is maintained, then that count value can be used as
  an argument to <code>fseek</code>.  This may not be true on machines
  where the end of line marker consists of both a newline and a carriage
  return.  In this case the <code>-m-f</code> command-line option can
  be used to switch to a slower, but more portable, algorithm for setting
  file positions.
  </listitem>
  <listitem>It assumes that a file is uniquely determined by the
  <code>st_dev</code> and <code>st_ino</code> fields of its corresponding
  <code>stat</code> value.  This is used when processing
  <code>#include</code> directives to prevent a file being read more
  than once if this is not necessary.  This assumption may not be true
  on machines with a small <code>ino_t</code> type which have file systems
  mounted from machines with a larger <code>ino_t</code> type.  In this
  case the <code>-m-i</code> command-line option can be used to disable
  this check.
  </listitem>
  </itemizedlist>
  </para>
  </section>
  </chapter>

  <chapter>
    <title>TDF generation</title>
  <para>
  The TDF encoding as a bitstream is expressed as a series of macros
  generated by the <code>make_tdf</code> tool from the TDF specification
  database.  Note that the version of the TDF database used contains
  a couple of corrections from the standard version:
  <itemizedlist>
  <listitem>A construct <code>make_token_def</code> has been added to represent
  a     token definition.
  </listitem>
  <listitem>The sort <code>diag_tag</code> has been added to the edge constructors.
  </listitem>
  </itemizedlist>
  The macros generated only handle the encoding of the construct - the
  construct parameters need to be encoded by hand (the C producer does
  something similar, but including the construct parameters).  For example,
  <code>make_tdf</code> generates a macro:
  <programlisting language="C++">
void ENC_plus ( BITSTREAM * ) ;</programlisting>
  which encodes the <code>plus</code> construct (91 as 7 bits in extended
  format).  A typical use of this macro, for adding the expressions
  <code>a</code> and <code>b</code> would be:
  <programlisting language="C++">
ENC_plus ( bs ) ;
ENC_impossible ( bs ) ;
bs = enc_exp ( bs, a ) ;
bs = enc_exp ( bs, b ) ;</programlisting>
  </para>
  <para>
  Each function or variable is compiled to TDF as its definition is
  encountered.  For some definitions, such as inline functions, the
  compilation may be deferred until it is clear whether or not the identifier
  has been used.  There is a final pass over all identifiers during
  the variable analysis routines which incorporates this check. Because
  of the organisation of a TDF capsule it is necessary to store all
  of the compiled TDF in memory until the end of the program, when the
  complete capsule, including external tag and token names and linkage
  information, is written to the output file.
  </para>
  </chapter>
</article>

