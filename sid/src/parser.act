/*
 * Copyright 2008-2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */

/*
 * SID's .sid format parser actions.
 */


/* TODO: could some of these be centralised for the c-language actions? */

%prefixes%

	terminal = LEXER_TOK_;

%persistents%

	sid_current_grammar : GrammarP;

%maps%

	AltP              -> AltP;
	bool             -> bool;
	EntryP            -> EntryP;
	ItemP             -> ItemP;
	RuleP             -> RuleP;
	TypeTupleT        -> TypeTupleT;
	NonLocalEntryP    -> NonLocalEntryP;
	StringT           -> NStringT;

	sid-parse-grammar -> sid_parse_grammar;

%header% @{

	/*
	 * Copyright 2008-2011, The TenDRA Project.
	 * Copyright 1997, United Kingdom Secretary of State for Defence.
	 *
	 * See doc/copyright/ for the full copyright terms.
	 */

	#include <limits.h>
	#include <assert.h>

	#include <shared/bool.h>
	#include <shared/check.h>
	#include <shared/error.h>

	#include <exds/common.h>
	#include <exds/exception.h>
	#include <exds/bitvec.h>
	#include <exds/dalloc.h>
	#include <exds/dstring.h>

	#include "adt/action.h"
	#include "adt/basic.h"
	#include "adt/key.h"
	#include "adt/non-local.h"
	#include "adt/rule.h"
	#include "adt/scope.h"
	#include "adt/table.h"
	#include "adt/types.h"

	#include "parser.h"
	#include "grammar.h"
	#include "lexer.h"

	#define ERROR_TERMINAL @$ERROR
	#define CURRENT_TERMINAL lexer_get_terminal(sid_current_stream)
	#define ADVANCE_LEXER lexer_next_token(sid_current_stream)
	#define SAVE_LEXER(x) (lexer_save_terminal(sid_current_stream, (LexerTokenT) (x)))
	#define RESTORE_LEXER (lexer_restore_terminal(sid_current_stream))
	#define ALT_LIMIT (UINT_MAX - 1)

	/* typedefs for the maps section */
	typedef AltT *AltP;
	typedef EntryT *EntryP;
	typedef ItemT *ItemP;
	typedef RuleT *RuleP;
	typedef NonLocalEntryT *NonLocalEntryP;

	LexerStreamT *sid_current_stream;

	static ScopeStackT  sid_scope_stack;
	static ScopeStackT  sid_global_scope;
	static ScopeStackT *sid_current_scope;
	static EntryT      *sid_current_entry;
	static RuleT       *sid_enclosing_rule;
	static RuleT       *sid_current_rule;
	static bool        sid_redefining_entry;
	static NStringT     sid_maximum_scope;
	static bool        sid_saved_pred_id;
	static bool        sid_current_pred_id;
	static AltT        *sid_current_alt;
	static ItemT       *sid_current_item;
	static unsigned     sid_alternative;
	static bool        sid_internal_rule;
	static EntryT      *sid_external_rule;
	static unsigned     sid_num_alternatives = 0;
	static bool        sid_propagating_error = false;
	static bool        sid_finished_terminals = false;


	static void err_redeclared(const char *type, NStringT *name) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"identifier '%S' redeclared as %s",
			(void *) name, type);
	}

	static void err_unknown(const char *type, NStringT *name) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"%s '%S' hasn't been declared",
			type, (void *) name);
	}

	static void err_basic_mismatch(const char *type, KeyT *key, TypeTupleT *a) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"parameter type mismatch for %s of terminal '%K' [%Y should be ()])",
			type, (void *) key, (void *) a);
	}

	static void err_type_mismatch(const char *item, const char *verb, KeyT *key, TypeTupleT *a, TypeTupleT *b) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"%s type mismatch for %s '%K' [%Y should be %Y]",
			item, verb, (void *) key, (void *) a, (void *) b);
	}

	static void err_type_mismatch_of(const char *item, const char *verb, const char *entity,
		KeyT *key, TypeTupleT *a, TypeTupleT *b) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"%s type mismatch for %s of %s '%K' [%Y should be %Y]",
			item, verb, entity, (void *) key, (void *) a, (void *) b);
	}

	static void err_expected(const char *item) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"expected %s", item);
	}

	static void err_ignored(const char *item, NStringT *name) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"invocation of ignored %s '%S'", item, (void *) name);
	}

	static void err_undefined_name(KeyT *name, KeyT *rule, unsigned alt) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"undefined parameter name '%K' in alternative %u of production '%K'",
			(void *) name, alt, (void *) rule);
	}

	static void err_redefined_name(KeyT *name, KeyT *rule, unsigned alt) {
		error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
			"redefined name '%K' in alternative %u of production '%K'",
			(void *) name, alt, (void *) rule);
	}

@}, @{

	/*
	 * Copyright 2008-2011, The TenDRA Project.
	 * Copyright 1997, United Kingdom Secretary of State for Defence.
	 *
	 * See doc/copyright/ for the full copyright terms.
	 */

	/*
	 * parser.h - SID parser.
	 *
	 * This file specifies the interface to the SID file parser that is produced
	 * from the file "parser.sid".
	 */

	#include "grammar.h"
	#include "lexer.h"

	extern LexerStreamT *  sid_current_stream;

@};

%assignments%

	StringT: (a) -> (b) = @{
		nstring_assign(&@b, @&a);
	@};

	/*
	We should probably do a list copy for assignments
	This has no importance since we do not rename in the sid code anyway.
	*/
	TypeTupleT: (a) -> (b) = @{
		@b.head = @a.head;

		if (@b.head == NULL) {
			@b.tail = &@b.head;
		} else {
			@b.tail= @a.tail ;
		}
	@};

%parameter-assignments%

	StringT: (a) -> (b) = @{
		nstring_assign(&@b, @a);
	@};

	TypeTupleT: (a) -> (b) = @{
		@b.head = @a->head;

		if (@b.head == NULL) {
			@b.tail = &@b.head;
		} else {
			@b.tail= @a->tail ;
		}
	@};

%result-assignments%

	StringT: (a) -> (b) = @{
		nstring_assign(@b, @&a);
	@};

	TypeTupleT: (a) -> (b) = @{
		@b->head = @a.head;

		if (@b->head == NULL) {
			@b->tail = &@b->head;
		} else {
			@b->tail= @a.tail ;
		}
	@};

%terminals%

	IDENTIFIER: () -> (i) = @{
		nstring_assign(&@i, lexer_string_value(sid_current_stream));
	@};

	BASIC: () -> (i) = @{
		nstring_assign(&@i, lexer_string_value(sid_current_stream));
	@};

%actions%

	<init> = @{
		scope_stack_init(&sid_scope_stack);
		scope_stack_init(&sid_global_scope);
	@};


	/*
	 * Type section actions
	 */

	<add-type>: (string :StringT &) -> () = @{
		if (table_add_type(grammar_table(sid_current_grammar), &@=string, false) == NULL) {
			err_redeclared("type", @&string);
			nstring_destroy(&@=string);
		}
	@};

	<i-add-type>: (string :StringT &) -> () = @{
		if (table_add_type(grammar_table(sid_current_grammar), &@=string, true) == NULL) {
			err_redeclared("type", @&string);
			nstring_destroy(&@=string);
		}
	@};


	/*
	 * Terminals section actions
	 */

	<terminal>: (string :StringT &) -> (entry :EntryP) = @{
		@entry = table_add_basic(grammar_table(sid_current_grammar), &@=string,
			sid_current_grammar, false);
		if (@entry == NULL) {
			err_redeclared("terminal", @&string);
			nstring_destroy(&@=string);
		}
	@};

	<i-terminal>: ( string :StringT &) -> (entry :EntryP) = @{
		@entry = table_add_basic(grammar_table(sid_current_grammar), &@=string,
			sid_current_grammar, true);
		if (@entry == NULL) {
			err_redeclared("terminal", @&string);
			nstring_destroy(&@=string);
		}
	@};

	<x-terminal>: (entry :EntryP, params :TypeTupleT &, results :TypeTupleT &) -> () = @{
		if (@entry) {
			KeyT *key = entry_key(@entry);
			BasicT *basic = entry_get_basic(@entry);
			if (types_contains_names(@&params)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"parameter of declaration of terminal '%K' has names [parameter = %Y]",
					(void *) key, (void *) @&params);
			}
			if (types_contains_names(@&results)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result of declaration of terminal '%K' has names [result = %Y]",
					(void *) key, (void *) @&results);
			}
			if (types_contains_references(@&results)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result of declaration of terminal '%K' has references [result = %Y]",
					(void *) key, (void *) @&results);
			}
			if (!types_equal_zero_tuple(@&params)) {
				err_basic_mismatch("declaration", key, @&params);
			}
			if (!basic_get_ignored(basic)) {
				EntryT *type;

				type = types_find_ignored(@&params);
				if (type != NULL) {
					err_ignored("type", key_get_string(entry_key(type)));
				}

				type = types_find_ignored(@&results);
				if (type != NULL) {
					err_ignored("type", key_get_string(entry_key(type)));
				}
			}
			types_assign(basic_result(basic), @&results);
		} else {
			types_destroy(@&results);
		}
		types_destroy(@&params);
	@};

	<x-terminals> = @{
		unsigned max_terminal = grammar_max_terminal(sid_current_grammar);

		bitvec_set_size(max_terminal);
		sid_finished_terminals = true;
	@};

	<x-basic>: (string :StringT) -> () = @{
		EntryT *entry = table_get_entry(grammar_table(sid_current_grammar), @&string);

		if (entry) {
			if (!entry_is_basic(entry)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"quoted identifier '%S' is not a terminal",
					(void *) @&string);
			}
		}

	@};


	/*
	 * Tuple manipulation actions
	 */

	<init-tuple>: () -> (tuple :TypeTupleT) = @{
		types_init(&@tuple);
	@};

	<current-tuple>: () -> () = @{
		sid_current_pred_id = false;
	@};

	<save-tuple> = @{
		sid_saved_pred_id = sid_current_pred_id;
	@};

	<tuple-name>: (tuple :TypeTupleT &, name :StringT &, type :StringT &) -> () = @{
		if (!types_add_typed_name(@&tuple, grammar_table(sid_current_grammar),
			&@=name, @&type, false)) {
			err_unknown("type", @&type);
		}
		nstring_destroy(&@=type);
	@};

	<tuple-ref-name>: (tuple :TypeTupleT &, name :StringT &, type :StringT &) -> () = @{
		if (!types_add_typed_name(@&tuple, grammar_table(sid_current_grammar),
			&@=name, @&type, true)) {
			err_unknown("type", @&type);
		}
		nstring_destroy(&@=type);
	@};

	<tuple-type>: (tuple :TypeTupleT &, type :StringT &) -> () = @{
		if (!types_add_type(@&tuple, grammar_table(sid_current_grammar), @&type,
			false)) {
			err_unknown("type", @&type);
		}
		nstring_destroy(&@=type);
	@};

	<tuple-ref-type>:  (tuple :TypeTupleT &, type :StringT &) -> () = @{
		if (!types_add_type(@&tuple, grammar_table(sid_current_grammar), @&type, true)) {
			err_unknown("type", @&type);
		}
		nstring_destroy(&@=type);
	@};

	<add-name>: (tuple :TypeTupleT &, name :StringT &) -> () = @{
		NStringT scope;
		EntryT *non_local_entry;
		EntryT *name_entry;

		non_local_entry = scope_stack_get_non_local(&sid_scope_stack,
			grammar_table(sid_current_grammar), @&name, &scope);
		name_entry = table_get_entry(grammar_table(sid_current_grammar), @&name);

		if (name_entry) {
			if (sid_current_entry && sid_current_alt) {
				if (!types_contains(alt_names(sid_current_alt), name_entry) &&
					!types_contains(rule_param(sid_current_rule), name_entry)) {
						name_entry = NULL;
				}
			} else {
				name_entry = NULL;
			}
		}

		if (name_entry) {
			types_add_name_and_type(@&tuple, name_entry, NULL, false);
			if (non_local_entry) {
				nstring_destroy(&scope);
			}
			nstring_destroy(&@=name);
		} else if (non_local_entry) {
			types_add_name_and_type(@&tuple, non_local_entry, NULL, false);
			if (nstring_length(&scope) > nstring_length(&sid_maximum_scope)) {
				nstring_destroy(&sid_maximum_scope);
				nstring_assign(&sid_maximum_scope, &scope);
			} else {
				nstring_destroy(&scope);
			}
			nstring_destroy(&@=name);
		} else {
			types_add_name(@&tuple, grammar_table(sid_current_grammar), &@=name, false);
		}
	@};

	/* TODO: these are a bit repetitive; can they be centralised? */
	<add-ref-name>: (tuple :TypeTupleT & ,name :StringT &) -> () = @{
		NStringT scope;
		EntryT *non_local_entry;
		EntryT *name_entry;

		non_local_entry = scope_stack_get_non_local(&sid_scope_stack,
			grammar_table(sid_current_grammar), @&name, &scope);
		name_entry = table_get_entry(grammar_table(sid_current_grammar), @&name);

		if (name_entry) {
			if (sid_current_entry && sid_current_alt) {
				if (!types_contains(alt_names(sid_current_alt), name_entry) &&
					!types_contains(rule_param(sid_current_rule), name_entry)) {
						name_entry = NULL;
				}
			} else {
				name_entry = NULL;
			}
		}

		if (name_entry) {
			types_add_name_and_type (@&tuple, name_entry, NULL, true);
			if (non_local_entry) {
				nstring_destroy(&scope);
			}
			nstring_destroy(&@=name);
		} else if (non_local_entry) {
			types_add_name_and_type (@&tuple, non_local_entry, NULL, true);
			if (nstring_length(&scope) > nstring_length(&sid_maximum_scope)) {
				nstring_destroy(&sid_maximum_scope);
				nstring_assign(&sid_maximum_scope, &scope);
			} else {
				nstring_destroy(&scope);
			}
			nstring_destroy(&@=name);
		} else {
			types_add_name(@&tuple, grammar_table(sid_current_grammar), &@=name, true);
		}
	@};

	<add-var>: (tuple :TypeTupleT &, name :StringT &) -> () = @{
		NStringT scope;
		EntryT *non_local_entry;
		EntryT *name_entry;

		non_local_entry = scope_stack_get_non_local(&sid_scope_stack,
			grammar_table(sid_current_grammar), @&name, &scope);
		name_entry = table_get_entry(grammar_table(sid_current_grammar), @&name);

		if (name_entry) {
			if (sid_current_entry && sid_current_alt) {
				if (!types_contains(alt_names(sid_current_alt), name_entry) &&
					!types_contains(rule_param(sid_current_rule), name_entry)) {
					name_entry = NULL;
				}
			} else {
				name_entry = NULL;
			}
		}

		if (name_entry) {
			types_add_name_and_type_var(@&tuple, name_entry, NULL);
			if (non_local_entry) {
				nstring_destroy(&scope);
			}
			nstring_destroy(&@=name);
		} else if (non_local_entry) {
			types_add_name_and_type_var(@&tuple, non_local_entry, NULL);
			if (nstring_length(&scope) > nstring_length(&sid_maximum_scope)) {
				nstring_destroy(&sid_maximum_scope);
				nstring_assign(&sid_maximum_scope, &scope);
			} else {
				nstring_destroy(&scope);
			}
			nstring_destroy(&@=name);
		} else {
			error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
				"assignment to undefined name '%S'", (void *) @&name);
			types_add_name(@&tuple, grammar_table(sid_current_grammar), &@=name, false);
		}
	@};

	<add-pred>: (tuple :TypeTupleT &) -> () = @{
		if (sid_current_pred_id) {
			error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
				"result contains more than one predicate result symbol");
		}
		sid_current_pred_id = true;
		types_add_name_entry(@&tuple, grammar_get_predicate_id(sid_current_grammar));
	@};

	<add-void>: (tuple :TypeTupleT &) -> () = @{
		EntryT *entry;

		entry = table_add_generated_name(grammar_table(sid_current_grammar));
		types_add_name_entry(@&tuple, entry);
	@};


	/*
	 * Productions section actions
	 */

	<use-global> = @{
		sid_current_scope = &sid_global_scope;
	@};

	<use-local> = @{
		sid_current_scope = &sid_scope_stack;
	@};

	<action>: (string :StringT &) -> (entry :EntryP) = @{
		@entry = scope_stack_add_action(sid_current_scope,
			grammar_table(sid_current_grammar), &@=string, sid_enclosing_rule,
			&sid_redefining_entry, false);
			sid_current_entry = @entry;
		if (!@entry) {
			err_redeclared("action", @&string);
			nstring_destroy(&@=string);
		}
	@};

	<i-action>: (string :StringT &) -> (entry :EntryP) = @{
		@entry = scope_stack_add_action(sid_current_scope,
			grammar_table(sid_current_grammar), &@=string, sid_enclosing_rule,
			&sid_redefining_entry, true);
			sid_current_entry = @entry;
		if (!@entry) {
			err_redeclared("action", @&string);
			nstring_destroy(&@=string);
		}
	@};

	<x-action>: (entry :EntryP, n_params :TypeTupleT &, n_results :TypeTupleT &) -> () = @{
		if (@entry) {
			KeyT       *key     = entry_key(sid_current_entry);
			ActionT    *action  = entry_get_action(@entry);
			TypeTupleT *param   = action_param(action);
			TypeTupleT *result  = action_result(action);
			bool       errored = false;

			if (types_contains_names(@&n_params)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"parameter of declaration of action '%K' has names [parameter = %Y]",
					(void *) key, (void *) @&n_params);
				errored = true;
			}

			if (sid_redefining_entry) {
				if (!types_equal(param, @&n_params)) {
					err_type_mismatch("parameter", "action", key, @&n_params, param);
					errored = true;
				}
			}

			if (types_contains_names(@&n_results)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result of declaration of action '%K' has names [result = %Y]",
					(void *) key, (void *) @&n_results);
				errored = true;
			}

			if (types_contains_references(@&n_results)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result of declaration of action '%K' has references [result = %Y]",
					(void *) key, (void *) @&n_results);
				errored = true;
			}

			if (sid_redefining_entry) {
				if (!types_equal(result, @&n_results)) {
					err_type_mismatch("result", "action", key, @&n_params, param);
					errored = true;
				}
			}

			if (!action_get_ignored(action)) {
				EntryT *type;

				type = types_find_ignored(@&n_params);
				if (type != NULL) {
					err_ignored("type", key_get_string(entry_key(type)));
					errored = true;
				}

				type = types_find_ignored(@&n_results);
				if (type != NULL) {
					err_ignored("type", key_get_string(entry_key(type)));
					errored = true;
				}
			}

			if (errored || sid_redefining_entry) {
				types_destroy(@&n_params);
				types_destroy(@&n_results);
			} else {
				types_assign(param, @&n_params);
				types_assign(result, @&n_results);
			}
		} else {
			types_destroy(@&n_params);
			types_destroy(@&n_results);
		}
	@};

	<non-local>: (id :StringT &, type_id :StringT &) -> (nonlocalentry :NonLocalEntryP) = @{
		@nonlocalentry = NULL;
		if (sid_enclosing_rule == NULL || sid_current_scope == &sid_global_scope) {
			error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
				"definition of non local name '%S' at global scope",
				(void *) @&id);
			nstring_destroy(&@=id);
		} else {
			EntryT *type;

			type = table_get_type(grammar_table(sid_current_grammar), @&type_id);
			if (type == NULL) {
				err_unknown("type", @&type_id);
				nstring_destroy(&@=id);
			} else {
				EntryT *name;

				name = scope_stack_add_non_local(sid_current_scope,
					grammar_table(sid_current_grammar), &@=id, type,
					sid_enclosing_rule);
				if (name) {
					NonLocalListT *non_locals;

					non_locals = rule_non_locals(sid_enclosing_rule);
					@nonlocalentry = non_local_list_add(non_locals, name, type);
				} else {
					err_redeclared("non-local", @&id);
					nstring_destroy(&@=id);
				}
			}
		}
		nstring_destroy(&@=type_id);
	@};

	<non-local-init>: (nonlocalentry :NonLocalEntryP, action_id :StringT &) -> () = @{
		EntryT *actionentry;

		actionentry = scope_stack_get_action(&sid_scope_stack,
			grammar_table(sid_current_grammar), @&action_id);

		if (actionentry == NULL) {
			err_unknown("action", @&action_id);
		} else if (@nonlocalentry) {
			EntryT     *type   = non_local_entry_get_type(@nonlocalentry);
			KeyT       *name   = entry_key(non_local_entry_get_name(@nonlocalentry));
			ActionT    *action = entry_get_action(actionentry);
			TypeTupleT *param  = action_param(action);
			TypeTupleT *result = action_result(action);
			TypeTupleT  tuple;
			TypeTupleT  ref_tuple;

			if (action_get_ignored(action)) {
				err_ignored("action call", key_get_string(entry_key(actionentry)));
			}

			types_init(&tuple);
			types_init(&ref_tuple);
			types_add_type_entry(&tuple, type, false);
			types_add_type_entry(&ref_tuple, type, true);

			if (!types_equal(param, &tuple) && !types_equal(param, &ref_tuple)
				&& !types_equal_zero_tuple(param)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"parameter type mismatch for initialiser of non local name '%K' [%Y should be %Y, %Y or ()]",
					(void *) name, (void *) param, (void *) &tuple, (void *) &ref_tuple);
			}

			if (!types_equal(result, &tuple)) {
				err_type_mismatch_of("result", "initialiser", "non-local name", name, result, &tuple);
			}

			types_destroy(&ref_tuple);
			types_destroy(&tuple);
			non_local_entry_set_initialiser(@nonlocalentry, actionentry);
		}
		nstring_destroy(&@=action_id);
	@};

	<rule>: (string) -> () = @{
		sid_current_entry = scope_stack_add_rule(sid_current_scope,
			grammar_table(sid_current_grammar), &@=string, sid_enclosing_rule,
			&sid_redefining_entry);
		if (sid_current_entry) {
			sid_current_rule = entry_get_rule(sid_current_entry);
		} else {
			err_redeclared("rule", @&string);
			nstring_destroy(&@=string);
		}
	@};

	/* TODO: This looks a bit repetitive, too */
	<x-rule>: (n_params :TypeTupleT &, n_results :TypeTupleT &) -> () = @{
		if (sid_current_entry) {
			KeyT       *key     = entry_key(sid_current_entry);
			TypeTupleT *param   = rule_param(sid_current_rule);
			TypeTupleT *result  = rule_result(sid_current_rule);
			bool       errored = false;

			if (types_contains_names(@&n_params)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"parameter of declaration of rule '%K' has names [parameter = %Y]",
					(void *) key, (void *) @&n_params);
				errored = true;
			}

			if (sid_redefining_entry) {
				if (!types_equal(param, @&n_params)) {
					err_type_mismatch("parameter", "production", key, @&n_params, param);
					errored = true;
				}
			}

			if (types_contains_names(@&n_results)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result of declaration of rule '%K' has names [result = %Y]",
					(void *) key, (void *) @&n_results);
				errored = true;
			}

			if (types_contains_references(@&n_results)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result of declaration or definition of rule '%K' has references [result = %Y]",
					(void *) key, (void *) @&n_results);
				errored = true;
			}

			if (sid_redefining_entry) {
				if (!types_equal(result, @&n_results)) {
					err_type_mismatch("result", "production", key, @&n_results, result);
					errored = true;
				}
			}

			{
				EntryT *type;

				type = types_find_ignored(@&n_params);
				if (type != NULL) {
					err_ignored("type", key_get_string(entry_key(type)));
					errored = true;
				}

				type = types_find_ignored(@&n_results);
				if (type != NULL) {
					err_ignored("type", key_get_string(entry_key(type)));
					errored = true;
				}
			}

			if (errored || sid_redefining_entry) {
				types_destroy(@&n_params);
				types_destroy(@&n_results);
			} else {
				types_assign(param, @&n_params);
				types_assign(result, @&n_results);
			}
		} else {
			types_destroy(@&n_params);
			types_destroy(@&n_results);
		}
	@};

	<prod>: (n_params :TypeTupleT &, n_results :TypeTupleT &) -> () = @{
		if (sid_current_entry) {
			KeyT *key;

			key = entry_key(sid_current_entry);

			if (rule_is_defined(sid_current_rule)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"production '%K' is already defined", (void *) key);
				sid_current_entry = NULL;
				types_destroy(@&n_params);
				types_destroy(@&n_results);
			} else {
				TypeTupleT *param   = rule_param(sid_current_rule);
				TypeTupleT *result  = rule_result(sid_current_rule);
				bool       errored = false;

				rule_defined(sid_current_rule);
				if (!types_disjoint_names(@&n_params)) {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"parameter names are not disjoint (or are missing) for production '%K' [parameter = %Y]",
						(void *) key, (void *) @&n_params);
					errored = true;
				}

				if (types_check_shadowing(@&n_params, &sid_scope_stack,
					sid_current_rule)) {
					errored = true;
				}

				if (sid_redefining_entry) {
					if (!types_fillin_names(param, @&n_params)) {
						err_type_mismatch("parameter", "production", key, @&n_params, param);
						errored = true;
					}
					types_destroy(@&n_params);
				} else {
					types_assign(param, @&n_params);
				}

				if (!types_disjoint_names(@&n_results)) {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"result names are not disjoint (or are missing) for production '%K' [result = %Y]",
						(void *) key, (void *) @&n_results);
					errored = true;
				}

				if (types_check_shadowing(@&n_results, &sid_scope_stack,
					sid_current_rule)) {
					errored = true;
				}

				if (types_contains_references(@&n_results)) {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"result of declaration or definition of rule '%K' has references [result = %Y]",
						(void *) key, (void *) @&n_results);
					errored = true;
				}

				if (sid_redefining_entry) {
					if (!types_fillin_names(result, @&n_results)) {
						err_type_mismatch("result", "production", key, @&n_results, result);
						errored = true;
					}
					types_destroy(@&n_results);
				} else {
					types_assign(result, @&n_results);
				}

				{
					EntryT *type;

					type = types_find_ignored(param);
					if (type != NULL) {
						err_ignored("type", key_get_string(entry_key(type)));
						errored = true;
					}

					type = types_find_ignored(result);
					if (type != NULL) {
						err_ignored("type", key_get_string(entry_key(type)));
						errored = true;
					}
				}

				if (errored) {
					sid_current_entry = NULL;
				} else {
					if (types_intersect(param, result)) {
						error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
							"parameter and result names are not disjoint for production '%K' [parameter = %Y, result = %Y]",
							(void *) key, (void *) param, (void *) result);
						sid_current_entry = NULL;
					}
				}
			}
		} else {
			types_destroy(@&n_params);
			types_destroy(@&n_results);
		}

		sid_alternative   = 0;
		sid_internal_rule = false;
		sid_external_rule = sid_current_entry;
		nstring_init(&sid_maximum_scope);
	@};

	<x-prod> = @{
		if (sid_current_entry) {
			nstring_assign(rule_maximum_scope(sid_current_rule),
				&sid_maximum_scope);
		} else {
			nstring_destroy(&sid_maximum_scope);
		}
	@};

	<push-scope> = @{
		if (sid_current_entry) {
			KeyT     *key   = entry_key(sid_current_entry);
			NStringT *scope = key_get_string(key);

			scope_stack_push(&sid_scope_stack, scope);
		}
	@};

	<pop-scope> = @{
		if (sid_current_entry) {
			scope_stack_pop(&sid_scope_stack);
		}
	@};

	<save-scope>: () -> (saved_entry, saved_rule) = @{
		@saved_entry = sid_current_entry;
		@saved_rule  = sid_enclosing_rule;

		sid_enclosing_rule = sid_current_rule;
	@};

	<restore-scope>: (saved_entry, saved_rule) -> () = @{
		sid_current_entry  = @saved_entry;
		sid_current_rule   = sid_enclosing_rule;
		sid_enclosing_rule = @saved_rule;
		sid_alternative    = 0;
		sid_internal_rule  = false;
		sid_external_rule  = sid_current_entry;

		nstring_init(&sid_maximum_scope);
	@};

	<empty-alt> = @{
		sid_num_alternatives++;
		if (sid_num_alternatives == ALT_LIMIT) {
			error_posn(ERR_FATAL, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
				"too many alternatives in grammar");
			UNREACHED;
		}

		if (!sid_internal_rule) {
			sid_alternative++;
		}

		if (sid_current_entry) {
			if (rule_has_empty_alt(sid_current_rule)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"production '%K' has multiple empty alternatives",
					(void *) entry_key(sid_external_rule));
			} else if (!types_equal_zero_tuple(rule_result(sid_current_rule))) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result formals are not defined in alternative %u of production '%K'",
					sid_alternative, (void *) entry_key(sid_external_rule));
			} else {
				rule_add_empty_alt(sid_current_rule);
			}
		}
	@};

	<non-empty-alt> = @{
		sid_num_alternatives++;
		if (sid_num_alternatives == ALT_LIMIT) {
			error_posn(ERR_FATAL, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
				"too many alternatives in grammar");
			UNREACHED;
		}

		if (!sid_internal_rule) {
			sid_alternative++;
		}

		if (sid_current_entry) {
			sid_current_alt = alt_create();
		}
	@};

	<x-non-empty-alt> = @{
		if (sid_current_entry && sid_current_alt) {
			if (types_check_names(rule_result(sid_current_rule),
				alt_names(sid_current_alt))) {
				TypeTupleT used;

				types_copy(&used, rule_result(sid_current_rule));
				item_compute_minimal_dataflow(alt_item_head(sid_current_alt),
					&used);
				types_destroy(&used);
				rule_add_alt(sid_current_rule, sid_current_alt);
			} else {
				IGNORE alt_deallocate(sid_current_alt);
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result formals are not defined in alternative %u of production '%K'",
					sid_alternative, (void *) entry_key(sid_external_rule));
			}
		}
	@};

	<handler> = @{
		if (sid_current_entry) {
			sid_current_alt = alt_create();
		}
	@};

	<x-handler> = @{
		if (sid_current_entry && sid_current_alt) {
			if (types_check_names(rule_result(sid_current_rule),
				alt_names(sid_current_alt))) {
				TypeTupleT used;

				types_copy(&used, rule_result(sid_current_rule));
				item_compute_minimal_dataflow(alt_item_head(sid_current_alt),
					&used);
				types_destroy(&used);
				rule_set_handler(sid_current_rule, sid_current_alt);
			} else {
				IGNORE alt_deallocate(sid_current_alt);
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result formals are not defined in exception handler alternative of production '%K'",
					(void *) entry_key(sid_external_rule));
			}
		}
	@};

	<save>: () -> (saved_entry, saved_rule, saved_alt, saved_internal, item) = @{
		@saved_entry      = sid_current_entry;
		@saved_rule       = sid_current_rule;
		@saved_alt        = sid_current_alt;
		@saved_internal   = sid_internal_rule;
		@item             = NULL;
		sid_internal_rule = true;

		if (sid_current_entry && sid_current_alt) {
			sid_current_entry = table_add_generated_rule(grammar_table(sid_current_grammar), false);
			sid_current_rule  = entry_get_rule(sid_current_entry);
			@item             = item_create(sid_current_entry);

			rule_defined(sid_current_rule);
			item_inlinable(@item);
			types_copy(item_param(@item), rule_param(@saved_rule));
			types_append_copy(item_param(@item), alt_names(@saved_alt));
			types_copy(rule_param(sid_current_rule), item_param(@item));
			types_make_references(rule_param(sid_current_rule), item_param(@item));
			alt_add_item(@saved_alt, @item);
		} else {
			sid_current_entry = NULL;
		}
	@};

	<restore>: (saved_entry, saved_rule, saved_alt, saved_internal, item) -> () = @{
		if (@saved_entry && @saved_alt) {
			rule_compute_result_intersect(sid_current_rule);
			types_copy(item_result(@item), rule_result(sid_current_rule));
			types_add_new_names(alt_names(@saved_alt), item_result(@item),
			grammar_get_predicate_id(sid_current_grammar));
		}

		sid_internal_rule = @saved_internal;
		sid_current_alt   = @saved_alt;
		sid_current_rule  = @saved_rule;
		sid_current_entry = @saved_entry;
	@};

	<prod-action>: (string) -> () = @{
		if (sid_current_entry && sid_current_alt) {
			EntryT *entry;

			entry = scope_stack_get_action(&sid_scope_stack,
				grammar_table(sid_current_grammar), @&string);
			if (entry) {
				sid_current_item = item_create(entry);
			} else {
				err_unknown("action", @&string);
				sid_current_item = NULL;
				IGNORE alt_deallocate(sid_current_alt);
				sid_current_alt  = NULL;
			}
		} else {
			sid_current_item = NULL;
		}
		nstring_destroy(&@=string);
	@};

	<x-prod-action>: (lhs :TypeTupleT &, rhs :TypeTupleT &) -> () = @{
		if (sid_current_item) {
			bool    errored = false;
			EntryT  *entry   = item_entry(sid_current_item);
			ActionT *action  = entry_get_action(entry);

			if (action_get_ignored(action)) {
				err_ignored("action call", key_get_string(entry_key(entry)));
			}

			if (types_resolve(@&rhs, rule_param(sid_current_rule),
				alt_names(sid_current_alt), err_undefined_name,
				entry_key(sid_external_rule), sid_alternative)) {
				if (types_equal(@&rhs, action_param(action))) {
					item_add_param(sid_current_item, @&rhs);
				} else {
					err_type_mismatch_of("parameter", "invocation", "action",
						entry_key(entry), @&rhs, action_param(action));
					types_destroy(@&rhs);
					errored = true;
				}
			} else {
				types_destroy(@&rhs);
				errored = true;
			}

			if (types_disjoint_names(@&lhs)) {
				if (types_check_undefined(@&lhs, rule_param(sid_current_rule),
					alt_names(sid_current_alt), err_redefined_name,
					entry_key(sid_external_rule), sid_alternative)) {
					if (types_fillin_types(@&lhs, action_result(action))) {
						types_add_new_names(alt_names(sid_current_alt),
							@&lhs, grammar_get_predicate_id(sid_current_grammar));
						if (sid_saved_pred_id) {
							bool   reference;
							EntryT *type;

							type = types_find_name_type(@&lhs,
								grammar_get_predicate_id(sid_current_grammar), &reference);
							assert(type != NULL && !reference);
							if (grammar_get_predicate_type(sid_current_grammar)) {
								if (type != grammar_get_predicate_type(sid_current_grammar)) {
									error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
										"predicate type mismatch [%Y should be %Y]",
										(void *) type, (void *) grammar_get_predicate_type(sid_current_grammar));
								}
							} else {
								grammar_set_predicate_type(sid_current_grammar, type);
							}
							item_to_predicate(sid_current_item);
						}
						item_add_result(sid_current_item, @&lhs);
					} else {
						err_type_mismatch_of("result", "invocation", "action",
							entry_key(entry), @&lhs, action_result(action));
						types_destroy(@&lhs);
						errored = true;
					}
				} else {
					types_destroy(@&lhs);
					errored = true;
				}
			} else {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result names are not disjoint for invocation of action '%K' [result = %Y]",
					(void *) entry_key(entry), (void *) @&lhs);
				types_destroy(@&lhs);
				errored = true;
			}

			if (errored) {
				IGNORE item_deallocate(sid_current_item);
				sid_current_item = NULL;
				IGNORE alt_deallocate(sid_current_alt);
				sid_current_alt  = NULL;
			} else {
				alt_add_item(sid_current_alt, sid_current_item);
			}
		} else {
			types_destroy(@&lhs);
			types_destroy(@&rhs);
		}
	@};

	<x-identity>: (lhs :TypeTupleT &, rhs :TypeTupleT &) -> () = @{
		if (sid_current_entry && sid_current_alt) {
			EntryT *entry = table_add_rename(grammar_table(sid_current_grammar));

			if (types_resolve(@&rhs, rule_param(sid_current_rule),
				alt_names(sid_current_alt), err_undefined_name,
				entry_key(sid_external_rule), sid_alternative)) {
				if (types_contains_references(@&rhs)) {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"cannot take address of identity parameters in alternative %u of production '%K' [parameter = %Y]",
						sid_alternative, (void *) entry_key(sid_external_rule), (void *) @&rhs);
					types_destroy(@&rhs);
					sid_current_item = NULL;
				} else {
					sid_current_item = item_create(entry);
					item_add_param(sid_current_item, @&rhs);
				}
			} else {
				types_destroy(@&rhs);
				sid_current_item = NULL;
			}

			if (types_disjoint_names(@&lhs)) {
				if (types_check_undefined(@&lhs, rule_param(sid_current_rule),
					alt_names(sid_current_alt), err_redefined_name,
					entry_key(sid_external_rule), sid_alternative)) {
					if (sid_current_item) {
						if (types_fillin_types(@&lhs, item_param(sid_current_item))) {
							types_add_new_names(alt_names(sid_current_alt),
							@&lhs, grammar_get_predicate_id(sid_current_grammar));
							if (sid_saved_pred_id) {
								error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
									"predicate result symbol used in result of something other than an action");
							}
							item_add_result(sid_current_item, @&lhs);
							alt_add_item(sid_current_alt, sid_current_item);
						} else {
							error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
								"type mismatch for identity [%Y should be %Y]",
								(void *) @&lhs, (void *) item_param(sid_current_item));
							types_destroy(@&lhs);
							IGNORE item_deallocate(sid_current_item);
							sid_current_item = NULL;
						}
					}
				} else {
					types_destroy(@&lhs);
					if (sid_current_item) {
						IGNORE item_deallocate(sid_current_item);
						sid_current_item = NULL;
					}
				}
			} else {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result names are not disjoint for identity [result = %Y]",
					(void *) @&lhs);
				types_destroy(@&lhs);
				if (sid_current_item) {
					IGNORE item_deallocate(sid_current_item);
					sid_current_item = NULL;
				}
			}

			if (sid_current_item == NULL) {
				IGNORE alt_deallocate(sid_current_alt);
				sid_current_alt = NULL;
			}
		} else {
			types_destroy(@&lhs);
			types_destroy(@&rhs);
		}
	@};

	<x-prod-rule>: (lhs :TypeTupleT &, rhs :TypeTupleT &, string :StringT &) -> () = @{
		TypeTupleT *param  = NULL;
		TypeTupleT *result = NULL;
		EntryT     *entry  = NULL;
		RuleT      *rule;
		BasicT     *basic;

		if (sid_current_entry && sid_current_alt) {
			entry = scope_stack_get_rule(&sid_scope_stack,
				grammar_table(sid_current_grammar), @&string);
			if (entry) {
				sid_current_item = item_create(entry);
				rule             = entry_get_rule(entry);
				param            = rule_param(rule);
				result           = rule_result(rule);
			} else {
				entry = table_get_basic(grammar_table(sid_current_grammar), @&string);
				if (entry) {
					sid_current_item = item_create(entry);
					basic            = entry_get_basic(entry);
					param            = NULL;
					result           = basic_result(basic);

					if (basic_get_ignored(basic)) {
						err_ignored("terminal", @&string);
					}
				} else {
					err_unknown("identifier", @&string);
					sid_current_item = NULL;
				}
			}
		} else {
			sid_current_item = NULL;
		}

		nstring_destroy(&@=string);
		if (sid_current_item) {
			bool  errored = false;
			KeyT  *key     = entry_key(entry);

			if (types_resolve(@&rhs, rule_param(sid_current_rule),
				alt_names(sid_current_alt), err_undefined_name,
				entry_key(sid_external_rule), sid_alternative)) {
				if (param) {
					if (types_equal(@&rhs, param)) {
						item_add_param(sid_current_item, @&rhs);
					} else {
						err_type_mismatch_of("parameter", "invocation", "rule",
							key, @&rhs, param);
						types_destroy(@&rhs);
						errored = true;
					}
				} else {
					if (!types_equal_zero_tuple(@&rhs)) {
						err_basic_mismatch("invocation", key, @&rhs);
						types_destroy(@&rhs);
						errored = true;
					}
				}
			} else {
				types_destroy(@&rhs);
				errored = true;
			}

			if (types_disjoint_names(@&lhs)) {
				if (types_check_undefined(@&lhs, rule_param(sid_current_rule),
					alt_names(sid_current_alt), err_redefined_name,
					entry_key(sid_external_rule), sid_alternative)) {
					if (types_fillin_types(@&lhs, result)) {
						types_add_new_names(alt_names(sid_current_alt),
							@&lhs, grammar_get_predicate_id(sid_current_grammar));
						if (sid_saved_pred_id) {
							error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
								"predicate result symbol used in result of something other than an action");
						}
						item_add_result(sid_current_item, @&lhs);
					} else {
						if (param) {
							err_type_mismatch_of("result", "invocation", "rule",
								key, @&lhs, result);
						} else {
							err_type_mismatch_of("result", "invocation", "terminal",
								key, @&lhs, result);
						}
						types_destroy(@&lhs);
						errored = true;
					}
				} else {
					types_destroy(@&lhs);
					errored = true;
				}
			} else {
				if (param) {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"result names are not disjoint for invocation of rule '%K' [result = %Y]",
						(void *) key, (void *) @&lhs);
				} else {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"result names are not disjoint for invocation of terminal '%K' [result = %Y]",
						(void *) key, (void *) @&lhs);
				}

				types_destroy(@&lhs);
				errored = true;
			}

			if (errored) {
				IGNORE item_deallocate(sid_current_item);
				sid_current_item = NULL;
				IGNORE alt_deallocate(sid_current_alt);
				sid_current_alt  = NULL;
			} else {
				alt_add_item(sid_current_alt, sid_current_item);
			}
		} else {
			if (sid_current_alt) {
				IGNORE alt_deallocate (sid_current_alt);
				sid_current_alt = NULL;
			}
			types_destroy(@&lhs);
			types_destroy(@&rhs);
		}
	@};

	<x-prod-rule-or-identity>: (lhs :TypeTupleT &, string :StringT &) -> () = @{
		EntryT     *name_entry = table_get_entry(grammar_table(sid_current_grammar), @&string);
		EntryT     *entry      = NULL;
		TypeTupleT *param      = NULL;
		TypeTupleT *result     = NULL;
		RuleT      *rule;
		BasicT     *basic;
		TypeTupleT  rhs;

		types_init(&rhs);

		if (sid_current_entry && sid_current_alt) {
			if (name_entry != NULL &&
				!types_contains(alt_names(sid_current_alt), name_entry) &&
				!types_contains(rule_param(sid_current_rule), name_entry)) {
				name_entry = NULL;
			}

			entry = scope_stack_get_rule(&sid_scope_stack, grammar_table(sid_current_grammar),
				@&string);
			if (entry) {
				sid_current_item = item_create (entry);
				rule             = entry_get_rule (entry);
				param            = rule_param(rule);
				result           = rule_result(rule);
			} else {
				entry = table_get_basic(grammar_table(sid_current_grammar), @&string);
				if (entry) {
					sid_current_item = item_create (entry);
					basic            = entry_get_basic(entry);
					param            = NULL;
					result           = basic_result(basic);
					if (name_entry == NULL && basic_get_ignored(basic)) {
						err_ignored("terminal", @&string);
					}
				}
			}

			if (entry == NULL && name_entry == NULL) {
				NStringT scope;

				name_entry = scope_stack_get_non_local(&sid_scope_stack,
					grammar_table(sid_current_grammar), @&string, &scope);
				if (name_entry) {
					if (nstring_length(&scope) > nstring_length(&sid_maximum_scope)) {
						nstring_destroy(&sid_maximum_scope);
						nstring_assign(&sid_maximum_scope, &scope);
					} else {
						nstring_destroy(&scope);
					}
				} else {
					err_unknown("identifier", @&string);
				}
			} else if (entry != NULL && name_entry != NULL) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"identifier '%S' used in ambiguous context [may be name, rule or terminal]",
						(void *) @&string);
				entry      = NULL;
				name_entry = NULL;
			}
		} else {
			name_entry = NULL;
		}
		nstring_destroy(&@=string);

		if (entry) {
			bool  errored = false;
			KeyT  *key     = entry_key(entry);

			if (types_resolve(&rhs, rule_param(sid_current_rule),
				alt_names(sid_current_alt), err_undefined_name,
				entry_key(sid_external_rule), sid_alternative)) {
				if (param) {
					if (types_equal(&rhs, param)) {
						item_add_param(sid_current_item, &rhs);
					} else {
						err_type_mismatch_of("parameter", "invocation", "rule",
							key, &rhs, param);
						types_destroy(&rhs);
						errored = true;
					}
				} else {
					if (!types_equal_zero_tuple(&rhs)) {
						err_basic_mismatch("invocation", key, &rhs);
						types_destroy(&rhs);
						errored = true;
					}
				}
			} else {
				types_destroy(&rhs);
				errored = true;
			}

			if (types_disjoint_names(@&lhs)) {
				if (types_check_undefined(@&lhs, rule_param(sid_current_rule),
					alt_names(sid_current_alt), err_redefined_name,
					entry_key(sid_external_rule), sid_alternative)) {
					if (types_fillin_types(@&lhs, result)) {
						types_add_new_names(alt_names(sid_current_alt),
							@&lhs, grammar_get_predicate_id(sid_current_grammar));
						if (sid_saved_pred_id) {
							error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
								"predicate result symbol used in result of something other than an action");
						}
						item_add_result(sid_current_item, @&lhs);
					} else {
						if (param) {
							err_type_mismatch_of("result", "invocation", "rule",
								key, @&lhs, result);
						} else {
							err_type_mismatch_of("result", "invocation", "terminal",
								key, @&lhs, result);
						}
						types_destroy(@&lhs);
						errored = true;
					}
				} else {
					types_destroy(@&lhs);
					errored = true;
				}
			} else {
				if (param) {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"result names are not disjoint for invocation of rule '%K' [result = %Y]",
						(void *) key, (void *) @&lhs);
				} else {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"result names are not disjoint for invocation of terminal '%K' [result = %Y]",
						(void *) key, (void *) @&lhs);
				}

				types_destroy(@&lhs);
				errored = true;
			}

			if (errored) {
				IGNORE item_deallocate(sid_current_item);
				sid_current_item = NULL;
				IGNORE alt_deallocate(sid_current_alt);
				sid_current_alt  = NULL;
			} else {
				alt_add_item(sid_current_alt, sid_current_item);
			}
		} else if (name_entry) {
			types_add_name_entry(&rhs, name_entry);
			entry = table_add_rename (grammar_table(sid_current_grammar));
			if (types_resolve(&rhs, rule_param(sid_current_rule),
				alt_names(sid_current_alt), err_undefined_name,
				entry_key(sid_external_rule), sid_alternative)) {
				if (types_contains_references(&rhs)) {
					error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
						"cannot take address of identity parameters in alternative %u of production '%K' [parameter = %Y]",
						sid_alternative, (void *) entry_key(sid_external_rule), (void *) &rhs);
					types_destroy(&rhs);
					sid_current_item = NULL;
				} else {
					sid_current_item = item_create(entry);
					item_add_param(sid_current_item, &rhs);
				}
			} else {
				types_destroy(&rhs);
				sid_current_item = NULL;
			}

			if (types_disjoint_names(@&lhs)) {
				if (types_check_undefined(@&lhs, rule_param(sid_current_rule),
					alt_names(sid_current_alt), err_redefined_name,
					entry_key(sid_external_rule), sid_alternative)) {
					if (sid_current_item) {
						if (types_fillin_types(@&lhs, item_param(sid_current_item))) {
							types_add_new_names(alt_names(sid_current_alt),
								@&lhs, grammar_get_predicate_id(sid_current_grammar));
							if (sid_saved_pred_id) {
								error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
									"predicate result symbol used in result of something other than an action");
							}
							item_add_result(sid_current_item, @&lhs);
							alt_add_item(sid_current_alt, sid_current_item);
						} else {
							error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
								"type mismatch for identity [%Y should be %Y]",
								(void *) @&lhs, (void *) item_param(sid_current_item));
							types_destroy(@&lhs);
							IGNORE item_deallocate(sid_current_item);
							sid_current_item = NULL;
						}
					}
				} else {
					types_destroy(@&lhs);
					if (sid_current_item) {
						IGNORE item_deallocate(sid_current_item);
						sid_current_item = NULL;
					}
				}
			} else {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"result names are not disjoint for identity [result = %Y]",
					(void *) @&lhs);
				types_destroy(@&lhs);
				if (sid_current_item) {
					IGNORE item_deallocate(sid_current_item);
					sid_current_item = NULL;
				}
			}

			if (sid_current_item == NULL) {
				IGNORE alt_deallocate(sid_current_alt);
				sid_current_alt = NULL;
			}
		} else {
			if (sid_current_alt) {
				IGNORE alt_deallocate(sid_current_alt);
				sid_current_alt = NULL;
			}
			types_destroy(@&lhs);
			types_destroy(&rhs);
		}
	@};

	<add-entry>: (string) -> () = @{
		EntryT *entry;

		entry = table_get_rule(grammar_table(sid_current_grammar), @&string);
		if (entry) {
			if (entry_list_contains(grammar_entry_list(sid_current_grammar), entry)) {
				error_posn(ERR_SERIOUS, lexer_stream_name(sid_current_stream), (int) lexer_stream_line(sid_current_stream),
					"rule '%K' occurs in the entry list more than once",
					(void *) entry_key(entry));
			} else {
				entry_list_add(grammar_entry_list(sid_current_grammar), entry);
				rule_required(entry_get_rule(entry));
			}
		} else {
			err_unknown("rule", @&string);
		}
		nstring_destroy(&@=string);
	@};


	/*
	 * Error recovery stuff
	 */

	<unhandled-syntax-error> = @{
		UNREACHED;
	@};

	<expected-typemark> = @{
		if (!sid_propagating_error) {
			err_expected("':'");
		}
	@};

	<expected-identifier> = @{
		if (!sid_propagating_error) {
			err_expected("identifier");
		}
	@};

	<expected-identifier-or-basic> = @{
		if (!sid_propagating_error) {
			err_expected("identifier or terminal");
		}
	@};

	<expected-tuple-defn> = @{
		if (!sid_propagating_error) {
			err_expected("identifier or ':'");
		}
	@};

	<expected-terminal-decn> = @{
		if (!sid_propagating_error) {
			err_expected("identifier or '!'");
		}
	@};

	<expected-separator> = @{
		if (!sid_propagating_error) {
			err_expected("','");
		}
	@};

	<expected-open-tuple> = @{
		if (!sid_propagating_error) {
			err_expected("'('");
		}
	@};

	<expected-close-tuple> = @{
		if (!sid_propagating_error) {
			err_expected("')'");
		}
	@};

	<expected-arrow> = @{
		if (!sid_propagating_error) {
			err_expected("'->'");
		}
	@};

	<expected-terminator> = @{
		if (!sid_propagating_error) {
			err_expected("';'");
		}
	@};

	<expected-lhs-name> = @{
		if (!sid_propagating_error) {
			err_expected("identifier, '?' or '!'");
		}
	@};

	<expected-rhs-name> = @{
		if (!sid_propagating_error) {
			err_expected("identifier or '&'");
		}
	@};

	<expected-begin-action> = @{
		if (!sid_propagating_error) {
			err_expected("'<'");
		}
	@};

	<expected-end-action> = @{
		if (!sid_propagating_error) {
			err_expected("'>'");
		}
	@};

	<expected-end-scope> = @{
		if (!sid_propagating_error) {
			err_expected("']'");
		}
	@};

	<expected-tuple-or-terminator> = @{
		if (!sid_propagating_error) {
			err_expected("tuple or ';'");
		}
	@};

	<expected-item-rhs> = @{
		if (!sid_propagating_error) {
			err_expected("item right hand side");
		}
	@};

	<expected-define> = @{
		if (!sid_propagating_error) {
			err_expected("'='");
		}
	@};

	<expected-tuple-or-define-or-terminator> = @{
		if (!sid_propagating_error) {
			err_expected("tuple, '=' or ';'");
		}
	@};

	<expected-begin-rule> = @{
		if (!sid_propagating_error) {
			err_expected("'{'");
		}
	@};

	<expected-end-rule> = @{
		if (!sid_propagating_error) {
			err_expected("'}'");
		}
	@};

	<expected-item> = @{
		if (!sid_propagating_error) {
			err_expected("item");
		}
	@};

	<expected-alternative> = @{
		if (!sid_propagating_error) {
			err_expected("alternative");
		}
	@};

	<expected-other-defn> = @{
		if (!sid_propagating_error) {
			err_expected("rule declaration or rule or non local name definition");
		}
	@};

	<expected-production-defn> = @{
		if (!sid_propagating_error) {
			err_expected("rule declaration or definition, or action declaration");
		}
	@};

	<expected-blt-types> = @{
		if (!sid_propagating_error) {
			err_expected("'%types%'");
		}
	@};

	<expected-blt-terminals> = @{
		if (!sid_propagating_error) {
			err_expected("'%terminals%'");
		}
	@};

	<expected-blt-productions> = @{
		if (!sid_propagating_error) {
			err_expected("'%productions%'");
		}
	@};

	<expected-blt-entry> = @{
		if (!sid_propagating_error) {
			err_expected("'%entry%'");
		}
	@};

	<expected-eof> = @{
		if (!sid_propagating_error) {
			err_expected("end of file");
		}
	@};

	<expected-terminator-or-define> = @{
		if (!sid_propagating_error) {
			err_expected("';' or '='");
		}
	@};

	<destroy-string>: (string) -> () = @{
		nstring_destroy(&@=string);
	@};

	/* TODO: Suspiciously repetitive */
	<skip-to-end-of-tuple-defn> = @{
		if (sid_finished_terminals) {
			while (@. != @$EOF
				&& @. != @$DEFINE
				&& @. != @$BEGIN-SCOPE
				&& @. != @$BEGIN-RULE
				&& @. != @$SEPARATOR
				&& @. != @$CLOSE-TUPLE
				&& @. != @$TERMINATOR
				&& @. != @$BLT-ENTRY) {
				if (@. == @$IDENTIFIER) {
					nstring_destroy(lexer_string_value(sid_current_stream));
				}
				@>;
			}

			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}

			if (@. != @$EOF) {
				@>;
			}
		} else {
			while (@. != @$EOF
				&& @. != @$SEPARATOR
				&& @. != @$CLOSE-TUPLE
				&& @. != @$TERMINATOR
				&& @. != @$BLT-PRODUCTIONS
				&& @. != @$BLT-ENTRY) {
				if (@. == @$IDENTIFIER) {
					nstring_destroy(lexer_string_value (sid_current_stream));
				}
				@>;
			}

			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value (sid_current_stream));
			}

			if (@. != @$EOF) {
				@>;
			}
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-terminal-decn> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-lhs-name> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-rhs-name> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-action-decn> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$END-SCOPE
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-item> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$ALT-SEP
			&& @. != @$HANDLER-SEP
			&& @. != @$BEGIN-RULE
			&& @. != @$END-RULE
			&& @. != @$END-SCOPE
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-alternative> = @{
		while (@. != @$EOF
			&& @. != @$ALT-SEP
			&& @. != @$HANDLER-SEP
			&& @. != @$END-RULE
			&& @. != @$END-SCOPE
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-other-defn> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$END-SCOPE
			&& @. != @$END-RULE
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-production-defn> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$END-SCOPE
			&& @. != @$END-RULE
			&& @. != @$BLT-PRODUCTIONS
			&& @. != @$BLT-ENTRY) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-to-end-of-entry-list> = @{
		while (@. != @$EOF
			&& @. != @$TERMINATOR
			&& @. != @$SEPARATOR) {
			if (@. == @$IDENTIFIER) {
				nstring_destroy(lexer_string_value(sid_current_stream));
			}
			@>;
		}

		if (@. == @$IDENTIFIER) {
			nstring_destroy(lexer_string_value(sid_current_stream));
		}

		if (@. != @$EOF) {
			@>;
		}

		sid_propagating_error = true;
	@};

	<skip-recover> = @{
		sid_propagating_error = false;
	@};

	<is-blt-entry-or-end-scope-or-eof>: () -> (predicate) = @{
		@predicate = (@. == @$EOF
			|| @. == @$END-SCOPE
			|| @. == @$BLT-ENTRY);
	@};

	<is-close-tuple-or-skipped-or-eof>: () -> (predicate) = @{
		@predicate = (@. == @$CLOSE-TUPLE
			|| @. == @$EOF
			|| sid_propagating_error);
	@};

	<is-terminator>: () -> (predicate) = @{
		@predicate = (@. == @$TERMINATOR);
	@};

	<is-not-separator>: () -> (predicate) = @{
		@predicate = (@. != @$SEPARATOR);
	@};

%trailer% @{

@}, @{

@};
