/* $Id$ */

/*
 * Copyright 2002-2011, The TenDRA Project.
 *
 * See doc/copyright/ for the full copyright terms.
 */


%types%
BOOL;
ENTRYP;
IDENTIFIER ;
BIGSTRING ;
TYPETUPLE;
CCODE;

%terminals%

header-kw ;
trailer-kw ;
map-kw ;
action-kw ;
argument-kw;

reference ;	//&
colon;
arrow;
define ;  	//=
semicolon ;	//;
comma ;   	//,
open ; 		//(
close ; 	//)

code-start;	//@{
code-end;	//@}
lone-code-at;
code-at;
code-eof;

eof;
identifier : () -> (:IDENTIFIER);
code-identifier : () -> (:IDENTIFIER);
code-reference : () -> (:IDENTIFIER);
code-string : () -> (:BIGSTRING);
!unknown ;

%productions%

<true> : () -> (:BOOL) ;
<false> : () -> (:BOOL) ;

<empty-identifier> : () -> ( : IDENTIFIER);

<set-headers> : (:CCODE &, :CCODE&) -> ();
<set-trailers> : (:CCODE &, :CCODE&) -> ();

<init-tuple> : () -> (:TYPETUPLE);
<append-tuple> : (:TYPETUPLE&, :IDENTIFIER, :IDENTIFIER, :BOOL) -> ();

<make-map> : (:IDENTIFIER, :IDENTIFIER) -> ();

<define-action> : (:ENTRYP, :CCODE&) -> ();
<check-action-tuples> : (:ENTRYP, :TYPETUPLE&, :TYPETUPLE&) -> ();	
<null-entry> : () -> (:ENTRYP);
<get-entry-action> : (:IDENTIFIER) -> (:ENTRYP);


<init-ccode> : () -> (:CCODE);
<append-ccode-string> : (:CCODE&, :BIGSTRING&) -> ();
<append-ccode-identifier> : (:CCODE&, :IDENTIFIER, :ENTRYP, :BOOL) -> ();
<append-ccode-at> : (:CCODE&) -> ();

<define-additional-argument> : (:IDENTIFIER, :IDENTIFIER) -> ();

<E-syntax-error> ;
<E_expected_code_end> ;
<E_expected_code_start> ;
<E_expected_comma> ;
<E_expected_define> ;
<E_expected_arrow> ;
<E_expected_colon> ;
<E_expected_semicolon> ;
<E_expected_identifier>;

<E_unexpected_eof> ;
<E_lone_at_in_code_block>;

code-block : (e:ENTRYP) -> (c:CCODE) [
	code-element : (c:CCODE&, e:ENTRYP) -> () = {
		s = code-string ;
		<append-ccode-string>(&c, &s);
	    ||	
	    	i = code-identifier;
		b = <false>;
		<append-ccode-identifier>(&c, i, e, b);
	    ||
	    	i = code-reference;
		b = <true>;
		<append-ccode-identifier>(&c, i, e, b);
	    ||
		lone-code-at;
		<E_lone_at_in_code_block>;
	    ||
		code-at;
		<append-ccode-at>(&c);
	};

	code-body : (c:CCODE&, e:ENTRYP) -> () = {
		$;
	    ||
		code-element(&c, e);
		code-body(&c, e); 
	};
] = {
	{
		code-start ;
    	##
		<E_expected_code_start> ;
	} ;
	c=<init-ccode>;
	code-body(&c, e);
	{
		$ ;
	    ||
		code-eof ; <E_unexpected_eof> ;
	} ;
	{
		code-end ;
	    ##
		<E_expected_code_end> ;
	} ;
};

header-stmnt : () -> () = {
	header-kw ;
	{
		define ;
	    ##
		<E_expected_define> ;
	} ;
	e=<null-entry>;
	sc=code-block(e);
	{
		comma ;
	    ##
		<E_expected_comma> ;
	};
	sh=code-block(e);
	<set-headers>(&sc,&sh);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

trailer-stmnt : () -> () = {
	trailer-kw ;
	{
		define ;
	    ##
		<E_expected_define> ;
	} ;
	e=<null-entry>;
	sc = code-block(e);
	{
		comma ;
	    ##
		<E_expected_comma> ;
	};
	sh=code-block(e);
	<set-trailers>(&sc,&sh);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

map-stmnt : () -> () = {
	map-kw ; lexitype=identifier; 
	{
		arrow; 
	    ##
		<E_expected_arrow>;
	};
	ctype=identifier; 
	<make-map>(lexitype, ctype);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

action-definition : () -> () [ 
	type-tuple : ( ) -> (a:TYPETUPLE) [
		type-name : (a:TYPETUPLE&) -> () = {
			{
				name=identifier ;
			    ||
				name=<empty-identifier>;
			};
			colon ;
			type=identifier ;
			{
				isref = <false>;
			    ||
				reference; isref = <true>;
			};
			<append-tuple>(&a,name,type,isref);
		} ;
		type-tuple1 : (a:TYPETUPLE&) -> () = {
			type-name(&a) ;
		    ||
			type-name(&a) ; comma; type-tuple1(&a) ;
		} ; ] = {
		open;
		a=<init-tuple> ;
		close;
	    ||
		open;
		a=<init-tuple>;
		type-tuple1(&a) ;
		close;
	};
	function-type-defn : () -> (in:TYPETUPLE,out:TYPETUPLE) = {
		in=<init-tuple>;
		out=<init-tuple>;
	    ||
		colon;
		in=type-tuple;
		{
			arrow;
		    ##
			<E_expected_arrow>;
		};
		out=type-tuple;
	};
	] = {
	action-kw; 
	{
		nm = identifier; 
	    ##
		nm = <empty-identifier>;
		<E_expected_identifier>;
	};
	(in, out) = function-type-defn ;
	{
		define ; 
	    ##
		<E_expected_define>;
	};

	ea = <get-entry-action>(nm);
	<check-action-tuples>(ea, &in, &out);
	c = code-block(ea);
	<define-action>(ea, &c);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

argument-stmnt : () -> () = {
	argument-kw; 
	{
		name = identifier ;
	    ##
		name = <empty-identifier>;
		<E_expected_identifier>;
	};
	{
		colon ;
	    ##
		<E_expected_colon>;
	};
	{
		ctype = identifier ;
	    ##
		ctype = <empty-identifier>;
		<E_expected_identifier>;
	};
	<define-additional-argument>(name, ctype);	
	{
		semicolon ; 
	    ##
		<E_expected_semicolon>;
	};
};


statement : () -> () = {
	header-stmnt;
    ||
	trailer-stmnt;
    ||
	action-definition;
    ||
	map-stmnt;
    ||
	argument-stmnt;
};

statement-list : () -> () = {
	$;
    ||
	statement; statement-list;
};

lct-unit : () -> () = {
	statement-list;
	eof;
    ##
	<E-syntax-error> ;
};

%entry% 
lct-unit ;
