<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter id="building"
	xmlns:dt="http://xml.water-powered.com/doctools">

	<title>Building</title>

	<section>
		<title>Building &api;s</title>

		<para>The &api; checking is one of the more interesting areas of
			TenDRA. An overview of the process of building &api;s is
			given in <xref linkend="api-building"/>.
			This diagram expands on the top-right and bottom-right
			quadrants of the &tdf; compilation phases described in
			&tdf-portability.doc;.</para>

		<figure id="api-building">
			<title>Files Involved for Building &api;s</title>

			<graphic fileref="images/apibuilding.svg"/>
		</figure>

		<para>An &api; consists of abstract specifications of a set of
			&api;s<footnote>
				<para><dt:source path="/tendra/src/lib/apis/"/></para>
			</footnote> which represent a similar level of abstraction that their
			respective standards represent. For example, <code>size_t</code>
			for the C89 &api; is defined to be an unsigned arithmetic
			type, but exactly which type is left to the implementation.
			See <dt:doc name="tspecguide"/> for details on specifying
			&api;s.</para>

		<para>These abstract specifications are converted by &tspec; into
			&api; Source and &api; Includes. The &api; Includes contain
			<code>#pragma token</code> statements which create tokens that
			correspond to the various things the &api; defines. Details of these
			are documented in the <code>tdfc2</code> guide. These are used
			later on, during compilation of users' programs.</para>

		<para>The generated &api; Source from &tspec; contains implementations of
			just the symbols present in each header for an &api; (as opposed to
			all the extensions your system probably provides), guarded by
			preprocessor conditions. These guards are of a standard form; for
			example, <code>ssize_t.c</code> from the <code>posix1</code>
			&api;:</para>

<programlisting language="C">
/* AUTOMATICALLY GENERATED BY tspec 2.8 */
#ifndef __WRONG_POSIX1
#ifndef __WRONG_POSIX1_SYS_TYPES_H_SSIZE_T
#if #include ( sys/types.h )
#define __BUILDING_TDF_POSIX1_SYS_TYPES_H_SSIZE_T
#include &lt;sys/types.h&gt;
#endif
#endif

#ifndef __BUILDING_TDF_POSIX1_SYS_TYPES_H_SSIZE_T
#pragma TenDRA no token definition allow
#endif
#pragma implement interface &lt;../shared/posix1.api/ssize_t.h&gt;
#endif</programlisting>

		<para>In the &api; specifications fed to &tspec;, <code>ssize_t</code>
			is a subset; the <code>__WRONG_POSIX1_SYS_TYPES_H_SSIZE_T</code>
			guard above is provided so that it may be excluded if your
			system does not have a compliant implementation of
			<code>ssize_t</code>.</para>

		<para>Non-compliance for a particular machine is indicated by
			setting <code>__WRONG_*</code> macros in the start-up files for
			that machine. Hence for &ultrix;, which (apparently) has a
			<code>ssize_t</code> incompatible to the <code>posix1</code>
			&api;'s, <dt:source href="/tendra/src/lib/machines/ultrix/mips/startup/posix1.h">the Startup header for &ultrix;</dt:source> defines <code>__WRONG_POSIX1_SYS_TYPES_H_SSIZE_T</code> and hence <code>ssize_t</code> is omitted when
			compiling the &tspec; &api; Source into the &api; &tdf; Tokens.
			See &porting.doc; for a worked example of making use of
			these macros.</para>

		<para>The compiled &api; &tdf; Tokens are linked together into
			<code>.tl</code> libraries; each library represents an
			&api;. As explained above, the contents of these libraries
			are the intersection of the sets of the things defined in
			that particular &api; and what your system provides.</para>
	</section>

	<section>
		<title>Production of TDF</title>

		<para>Based on the files installed, the process of compilation is
			outlined in <xref linkend="production"/>. These steps may be
			seen by executing <code>tcc -dry</code>.</para>

		<figure id="production">
			<title>Files involved during production</title>

			<graphic fileref="images/production.svg"/>
		</figure>

		<para>C is used as an example here, though similar things
			apply for any other producer. The main difference would be in
			&api; checking.</para>

		<para>It is important to note that during compilation the system
			headers are not used at all. Instead, the various prototypes and
			such which would be bought in by <code>#include</code> statements
			are prepended from the &api; Includes. These can be seen by running
			<code>tcc -E</code>:</para>

<programlisting language="C">
% tcc -Yc89 -E hello.c
#line 1 "hello.c"
...
#line 13 "<replaceable>$PREFIX_TSPEC</replaceable>/TenDRA/include/shared/c89.api/size_t.h"
...
#pragma token VARIETY unsigned size_t # size_t
#pragma token VARIETY __size_t # __size_t
#pragma promote size_t : __size_t

#pragma no_def size_t __size_t

...
#line 25 "<replaceable>$PREFIX_TSPEC</replaceable>/TenDRA/include/c89.api/stdio.h"
#pragma token EXP rvalue : FILE * : stdin # c89.stdio.stdin
#pragma token EXP rvalue : FILE * : stdout # c89.stdio.stdout
#pragma token EXP rvalue : FILE * : stderr # c89.stdio.stderr
...
#pragma token FUNC int ( __local_printf_string, ... ) : printf # c89.stdio.printf

#line 3 "hello.c"
int main(void) {
        printf("hello, world\n");
        return 0;
}</programlisting>

		<para>Here I've omitted most of the things <code>&lt;stdio.h&gt;</code>
			defines, just to keep the example small.</para>

		<para>Note that the contents of the &tspec; &api; Includes are
			portable; they ought to be the same for any system (this should
			be the case, since they were generated from the &tspec; &api;
			Specification sources, which did not involve anything
			system-specific). Therefore since these are included verbatim for
			a given &api; at the top of a users' C program, we can infer that
			the &tdf; capsule produced (<code>foo.j</code>is itself portable.
			This is what TenDRA is all about: producing a portable binary.
			The steps following (namely the call to &trans; and beyond) may
			therefore be on a different system than the one on which
			<code>hello.j</code> was produced, even though that system may
			have a different implementation of the &api;s used.
			As long as the target system provides the same subset in its
			<code>$api.tl</code>, the code will link and execute as expected.
			For details on this, see <dt:doc name="tdfandportability"/>.</para>
	</section>

	<section>
		<title>Installation of TDF</title>

		<para>The final step of linking also brings in any system-specific
			libraries which may be required (such as <code>crt0.o</code>),
			and of course any user-specified libraries, if given.
			These are illustrated representatively and their exact details
			differ per platform.</para>

		<figure id="installation">
			<title>Files involved during installation</title>

			<graphic fileref="images/installation.svg"/>
		</figure>
	</section>

</chapter>

