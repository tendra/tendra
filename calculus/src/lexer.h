/*
 * Copyright 2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */

/*
 *  AUTOMATICALLY GENERATED BY lexi VERSION 1.2
 */


/* LOOKUP TABLE */

static unsigned char lookup_tab[257] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x001c, 0x001c, 0x001c, 0x001c, 0x001c, 0x001c, 0x001c, 0x001c,
    0x001c, 0x001c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x0000, 0x0000, 0x0000, 0x0000, 0x000a,
    0x0000, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x001a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000
};

#ifndef LEX_EOF
#define LEX_EOF		256
#endif

#define lookup_char(C)	((int)lookup_tab[(C)])
#define is_white(T)	((T) & 0x0001)
#define is_alpha(T)	((T) & 0x0002)
#define is_digit(T)	((T) & 0x0004)
#define is_alphanum(T)	((T) & 0x0008)
#define is_hexdigit(T)	((T) & 0x0010)


/* MAIN PASS ANALYSER */

int
read_token(void)
{
    start: {
	int c0 = read_char(), t0;
	t0 = lookup_char(c0);
	if (is_white(t0)) goto start;
	switch (c0) {
	    case '!': {
		return(lex_exclaim);
	    }
	    case '"': {
		return(get_string(c0));
	    }
	    case '#': {
		return(lex_hash);
	    }
	    case '%': {
		return(lex_rem);
	    }
	    case '&': {
		return(lex_and);
	    }
	    case '(': {
		return(lex_open_Hround);
	    }
	    case ')': {
		return(lex_close_Hround);
	    }
	    case '*': {
		return(lex_star);
	    }
	    case '+': {
		return(lex_plus);
	    }
	    case ',': {
		return(lex_comma);
	    }
	    case '-': {
		int c1 = read_char();
		if (c1 == '>') {
		    return(lex_arrow);
		}
		unread_char(c1);
		return(lex_minus);
	    }
	    case '.': {
		return(lex_dot);
	    }
	    case '/': {
		int c1 = read_char();
		if (c1 == '*') {
		    return(get_comment(c0, c1));
		}
		unread_char(c1);
		return(lex_div);
	    }
	    case '0': {
		int c1 = read_char();
		if (c1 == 'X') {
		    int c2 = read_char(), t2;
		    t2 = lookup_char(c2);
		    if (is_hexdigit(t2)) {
			return(get_hex(c0, c1, c2));
		    }
		    unread_char(c2);
		} else if (c1 == 'x') {
		    int c2 = read_char(), t2;
		    t2 = lookup_char(c2);
		    if (is_hexdigit(t2)) {
			return(get_hex(c0, c1, c2));
		    }
		    unread_char(c2);
		}
		unread_char(c1);
		break;
	    }
	    case ':': {
		int c1 = read_char();
		if (c1 == ':') {
		    return(lex_colon_Hcolon);
		}
		unread_char(c1);
		return(lex_colon);
	    }
	    case ';': {
		return(lex_semicolon);
	    }
	    case '<': {
		int c1 = read_char();
		if (c1 == '<') {
		    return(lex_lshift);
		}
		unread_char(c1);
		break;
	    }
	    case '=': {
		return(lex_equal);
	    }
	    case '>': {
		int c1 = read_char();
		if (c1 == '>') {
		    return(lex_rshift);
		}
		unread_char(c1);
		break;
	    }
	    case '?': {
		return(lex_question);
	    }
	    case '[': {
		return(lex_open_Hsquare);
	    }
	    case ']': {
		return(lex_close_Hsquare);
	    }
	    case '^': {
		return(lex_xor);
	    }
	    case '{': {
		return(lex_open_Hbrace);
	    }
	    case '|': {
		return(lex_or);
	    }
	    case '}': {
		return(lex_close_Hbrace);
	    }
	    case '~': {
		return(lex_compl);
	    }
	    case LEX_EOF: {
		return(lex_eof);
	    }
	}
	if (is_alpha(t0)) {
	    return(get_identifier(c0));
	} else if (is_digit(t0)) {
	    return(get_number(c0));
	}
	return(unknown_token(c0));
    }
}
