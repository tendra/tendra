<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter id="specification-of-tdf-constructs">
	<title>Specification of TDF constructs</title>

	<section id="tdf-access">
		<title>Access</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>4</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>An <code>ACCESS</code> describes properties a variable or identity may
			have which may constrain or describe the ways in which the variable or
			identity is used.</para>

		<para>Each construction which needs an <code>ACCESS</code> uses it in the form
			<code>OPTION</code>(<code>ACCESS</code>). If the option is absent the
			variable or identity has no special properties.</para>

		<para>An <code>ACCESS</code> acts like a set of the values
			<replaceable>constant</replaceable>, <replaceable>long_jump_access</replaceable>,
			<replaceable>no_other_read</replaceable>, <replaceable>no_other_write</replaceable>,
			<replaceable>register</replaceable>, <replaceable>out_par</replaceable>,
			<replaceable>used_as_volatile</replaceable>, and <replaceable>visible</replaceable>.
			<replaceable>standard_access</replaceable> acts like the empty set.
			<replaceable>add_accesses</replaceable> is the set union operation.</para>

		<section id="access_apply_token">
			<title>access_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; ACCESS</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give an
				<code>ACCESS</code>.</para>

			<para>The notation <replaceable>param_sorts(token_value)</replaceable> is intended
				to mean the following. The token definition or token declaration for
				<replaceable>token_value</replaceable> gives the <code>SORT</code>s of its
				arguments in the <code>SORTNAME</code> component. The
				<code>BITSTREAM</code> in <replaceable>token_args</replaceable> consists of
				these <code>SORT</code>s in the given order. If no token declaration or
				definition exists in the <code>CAPSULE</code>, the
				<code>BITSTREAM</code> cannot be read.</para>
		</section>

		<section id="access_cond">
			<title>access_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM ACCESS
e2:      BITSTREAM ACCESS
 -&gt; ACCESS</programlisting>

			<para><replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed. If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="add_access">
			<title>add_access</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">a1: ACCESS
a2: ACCESS
 -&gt; ACCESS</programlisting>

			<para>A construction qualified with <replaceable>add_accesses</replaceable> has both
				<code>ACCESS</code> properties <replaceable>a1</replaceable> and
				<replaceable>a2</replaceable>. This operation is associative and commutative.</para>
		</section>

		<section id="constant">
			<title>constant</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>Only a variable (not an identity) may be qualified with
				<replaceable>constant</replaceable>. A variable qualified with
				<replaceable>constant</replaceable> will retain its initialising value unchanged
				throughout its lifetime.</para>
		</section>

		<section id="long_jump_access">
			<title>long_jump_access</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>An object must also have this property if it is to have a defined value
				when a <replaceable>long_jump</replaceable> returns to the procedure declaring
				the object.</para>
		</section>

		<section id="no_other_read">
			<title>no_other_read</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>This property refers to a <code>POINTER</code>, <replaceable>p</replaceable>.
				It says that, within the lifetime of the declaration being qualified,
				there are no <replaceable>contents</replaceable>,
				<replaceable>contents_with_mode</replaceable> or
				<replaceable>move_some</replaceable> source accesses to any pointer not
				derived from <replaceable>p</replaceable> which overlap with any of the
				<replaceable>contents</replaceable>, <replaceable>contents_with_mode</replaceable>,
				<replaceable>assign</replaceable>, <replaceable>assign_with_mode</replaceable> or
				<replaceable>move_some</replaceable> accesses to pointers derived from
				<replaceable>p</replaceable>.</para>

			<para>The <code>POINTER</code> being described is that obtained by applying
				<replaceable>obtain_tag</replaceable> to the <code>TAG</code> of the
				declaration. If the declaration is an <replaceable>identity</replaceable>, the
				<code>SHAPE</code> of the <code>TAG</code> will be a
				<code>POINTER</code>.</para>
		</section>

		<section id="no_other_write">
			<title>no_other_write</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>This property refers to a <code>POINTER</code>, <replaceable>p</replaceable>.
				It says that, within the lifetime of the declaration being qualified,
				there are no <replaceable>assign</replaceable>,
				<replaceable>assign_with_mode</replaceable> or <replaceable>move_some</replaceable>
				destination accesses to any pointer not derived from
				<replaceable>p</replaceable> which overlap with any of the
				<replaceable>contents</replaceable>, <replaceable>contents_with_mode</replaceable>,
				<replaceable>assign</replaceable>, <replaceable>assign_with_mode</replaceable> or
				<replaceable>move_some</replaceable> accesses to pointers derived from
				<replaceable>p</replaceable>.</para>

			<para>The <code>POINTER</code> being described is that obtained by applying
				<replaceable>obtain_tag</replaceable> to the <code>TAG</code> of the
				declaration. If the declaration is an <replaceable>identity</replaceable>, the
				<code>SHAPE</code> of the <code>TAG</code> will be a
				<code>POINTER</code>.</para>
		</section>

		<section id="out_par">
			<title>out_par</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>An object qualified by <replaceable>out_par</replaceable> will be an output
				parameter in a <replaceable>make_general_proc</replaceable> construct. This will
				indicate that the final value of the parameter is required in
				<replaceable>postlude</replaceable> part of an
				<replaceable>apply_general_proc</replaceable> of this procedure.</para>
		</section>

		<section id="preserve">
			<title>preserve</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>9</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>This property refers to a global object. It says that the object will be
				included in the final program, whether or not all possible accesses to
				that object are optimised away; for example by inlining all possible uses
				of procedure object.</para>
		</section>

		<section id="register">
			<title>register</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>10</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>Indicates that an object with this property is frequently used. This can
				be taken as a recommendation to place it in a register.</para>
		</section>

		<section id="standard_access">
			<title>standard_access</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>11</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>An object qualified as having <replaceable>standard_access</replaceable> has
				normal (i.e.	no special) access properties.</para>
		</section>

		<section id="used_as_volatile">
			<title>used_as_volatile</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>12</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>An object qualified as having <replaceable>used_as_volatile</replaceable> will
				be used in a <replaceable>move_some</replaceable>,
				<replaceable>contents_with_mode</replaceable> or an
				<replaceable>assign_with_mode</replaceable> construct with
				<code>TRANSFER_MODE</code> <replaceable>volatile</replaceable>.</para>
		</section>

		<section id="visible">
			<title>visible</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>13</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ACCESS</programlisting>

			<para>An object qualified as <replaceable>visible</replaceable> may be accessed when
				the procedure in which it is declared is not the current procedure. A
				<code>TAG</code> must have this property if it is to be used by
				<replaceable>env_offset</replaceable>.</para>
		</section>
	</section>

	<section id="AL_TAG">
		<title>AL_TAG</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
			<tr> <td>Linkable entity identification</td> <td>alignment</td> </tr>
		</informaltable>

		<para><code>AL_TAG</code>s name <code>ALIGNMENT</code>s. They are used so that
			circular definitions can be written in TDF. However, because of the
			definition of alignments, intrinsic circularities cannot occur.</para>

		<para>For example, the following equation has a circular form
			<replaceable>x = alignment(pointer(alignment(x)))</replaceable> and it
			or a similar equation might occur in TDF. But since
			<replaceable>alignment(pointer(x))</replaceable> is
			<replaceable>{pointer}</replaceable>, this reduces to
			<replaceable>x = {pointer}</replaceable>.
		</para>

		<section id="al_tag_apply_token">
			<title>al_tag_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; AL_TAG</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give an
				<code>AL_TAG</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="make_al_tag">
			<title>make_al_tag</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">al_tagno: TDFINT
 -&gt; AL_TAG</programlisting>

			<para><replaceable>make_al_tag</replaceable> constructs an <code>AL_TAG</code>
				identified by <replaceable>al_tagno</replaceable>.</para>
		</section>
	</section>

	<section id="AL_TAGDEF">
		<title>AL_TAGDEF</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>An <code>AL_TAGDEF</code> gives the definition of an <code>AL_TAG</code>
			for incorporation into a <code>AL_TAGDEF_PROPS</code>.</para>

		<section id="make_al_tagdef">
			<title>make_al_tagdef</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">t: TDFINT
a: ALIGNMENT
 -&gt; AL_TAGDEF</programlisting>

			<para>The <code>AL_TAG</code> identified by <replaceable>t</replaceable> is defined
				to stand for the <code>ALIGNMENT</code> <replaceable>a</replaceable>. All the
				<code>AL_TAGDEF</code>s in a <code>CAPSULE</code> must be considered
				together as a set of simultaneous equations defining
				<code>ALIGNMENT</code> values for the <code>AL_TAG</code>s. No order is
				imposed on the definitions.</para>

			<para>In any particular <code>CAPSULE</code> the set of equations may be
				incomplete, but a <code>CAPSULE</code> which is being translated into
				code will have a set of equations which defines all the
				<code>AL_TAG</code>s which it uses.</para>

			<para>The result of the evaluation of the <replaceable>control</replaceable>
				argument of any <replaceable>x_cond</replaceable> construction (e.g
				<replaceable>alignment_cond</replaceable>) used in <replaceable>a</replaceable>
				shall be independent of any <code>AL_TAG</code>s used in the
				<replaceable>control</replaceable>.	Simultaneous equations defining
				<code>ALIGNMENT</code>s can then always be solved.</para>

			<para>See <link linkend="circular-types">Circular types in languages</link>.</para>
		</section>
	</section>

	<section id="AL_TAGDEF_PROPS">
		<title>AL_TAGDEF_PROPS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
			<tr> <td>Unit identificaiton</td> <td>aldef</td> </tr>
		</informaltable>

		<section id="make_al_tagdefs">
			<title>make_al_tagdefs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">no_labels: TDFINT
tds:       SLIST(AL_TAGDEF)
 -&gt; AL_TAGDEF_PROPS</programlisting>

			<para><replaceable>no_labels</replaceable> is the number of local
				<code>LABEL</code>s used in <replaceable>tds</replaceable>.
				<replaceable>tds</replaceable> is a list of <code>AL_TAGDEF</code>s which
				define the bindings for <replaceable>al_tags</replaceable>.</para>
		</section>
	</section>

	<section id="ALIGNMENT">
		<title>ALIGNMENT</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>4</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>An <code>ALIGNMENT</code> gives information about the layout of data in
			memory and hence is a parameter for the <code>POINTER</code> and
			<code>OFFSET SHAPE</code>s (see <link linkend="memory-model">Memory
			Model</link>). This information consists of a set of elements.</para>

		<para>The possible values of the elements in such a set are
			<replaceable>proc</replaceable>, <replaceable>code</replaceable>,
			<replaceable>pointer</replaceable>, <replaceable>offset</replaceable>, all
			<code>VARIETY</code>s, all <code>FLOATING_VARIETY</code>s and all
			<code>BITFIELD_VARIETY</code>s. The sets are written here as, for example,
			{<replaceable>pointer</replaceable>, <replaceable>proc</replaceable>} meaning the set
			containing <replaceable>pointer</replaceable> and <replaceable>proc</replaceable>.</para>

		<para>In addition, there are &ldquo;special&rdquo; <code>ALIGNMENT</code>s
			<replaceable>alloca_alignment</replaceable>,
			<replaceable>callers_alignment</replaceable>,
			<replaceable>callees_alignment</replaceable>,
			<replaceable>locals_alignment</replaceable> and
			<replaceable>var_param_alignment</replaceable>. Each of these are considered to
			be sets which include all of the &ldquo;ordinary&rdquo;
			<code>ALIGNMENT</code>s above.</para>

		<para>There is a function, <replaceable>alignment</replaceable>, which can be applied
			to a <code>SHAPE</code> to give an <code>ALIGNMENT</code> (see the
			definition below). The interpretation of a <code>POINTER</code> to an
			<code>ALIGNMENT</code>, <replaceable>a</replaceable>, is that it can serve as a
			<code>POINTER</code> to any <code>SHAPE</code>, <replaceable>s</replaceable>,
			such that <replaceable>alignment</replaceable>(<replaceable>s</replaceable>) is a
			subset of the set <replaceable>a</replaceable>.</para>

		<para>So given a <code>POINTER</code>({<replaceable>proc</replaceable>,
			<replaceable>pointer</replaceable>}) it is permitted to assign a
			<code>PROC</code> or a <code>POINTER</code> to it, or indeed a compound
			containing only <code>PROC</code>s and <code>POINTER</code>s. This
			permission is valid only in respect of the space being of the right kind;
			it may or may not be big enough for the data.</para>

		<para>The most usual use for <code>ALIGNMENT</code> is to ensure that addresses
			of <replaceable>int</replaceable> values are aligned on 4-byte boundaries,
			<replaceable>float</replaceable> values are aligned on 4-byte boundaries,
			<replaceable>double</replaceable>s on 8-bit boundaries etc. and whatever may be
			implied by the definitions of the machines and languages involved.</para>

		<para>In the specification the phrase &ldquo;<replaceable>a</replaceable> will include
			<replaceable>b</replaceable>&rdquo; where <replaceable>a</replaceable> and
			<replaceable>b</replaceable> are <code>ALIGNMENT</code>s, means that the set
			<replaceable>b</replaceable> will be a subset of <replaceable>a</replaceable> (or
			equal to <replaceable>a</replaceable>).</para>

		<section id="alignment_apply_token">
			<title>alignment_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; ALIGNMENT</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give an
				<code>ALIGNMENT</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="alignment_cond">
			<title>alignment_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM ALIGNMENT
e2:      BITSTREAM ALIGNMENT
 -&gt; ALIGNMENT</programlisting>

			<para><replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed. If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="alignment">
			<title>alignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">sha: SHAPE
 -&gt; ALIGNMENT</programlisting>

			<para>The <replaceable>alignment</replaceable> construct is defined as follows:</para>

			<itemizedlist>
				<listitem>
					<para>If <replaceable>sha</replaceable> is <code>PROC</code> then the resulting
						<code>ALIGNMENT</code> is {<replaceable>proc</replaceable>}.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is
						<code>INTEGER</code>(<replaceable>v</replaceable>) then the resulting
						<code>ALIGNMENT</code> is {<replaceable>v</replaceable>}.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is
						<code>FLOATING</code>(<replaceable>v</replaceable>) then the resulting
						<code>ALIGNMENT</code> is {<replaceable>v</replaceable>}.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is
						<code>BITFIELD</code>(<replaceable>v</replaceable>) then the resulting
						<code>ALIGNMENT</code> is {<replaceable>v</replaceable>}.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is <code>TOP</code> the resulting
						<code>ALIGNMENT</code> is {} - the empty set.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is <code>BOTTOM</code> the resulting
						<code>ALIGNMENT</code> is undefined.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is
						<code>POINTER</code>(<replaceable>x</replaceable>) the resulting
						<code>ALIGNMENT</code> is {<replaceable>pointer</replaceable>}.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is
						<code>OFFSET</code>(<replaceable>x</replaceable>, <replaceable>y</replaceable>)
						the resulting <code>ALIGNMENT</code> is
						{<replaceable>offset</replaceable>}.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is
						<code>NOF</code>(<replaceable>n</replaceable>, <replaceable>s</replaceable>) the
						resulting <code>ALIGNMENT</code> is
						<replaceable>alignment</replaceable>(<replaceable>s</replaceable>).</para>
				</listitem>

				<listitem>
					<para>If <replaceable>sha</replaceable> is <code>COMPOUND</code>(<code>EXP
						OFFSET</code>(<replaceable>x</replaceable>, <replaceable>y</replaceable>)) then
						the resulting <code>ALIGNMENT</code> is <replaceable>x</replaceable>.</para>
				</listitem>
			</itemizedlist>
		</section>

		<section id="alloca_allignment">
			<title>alloca_allignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ALIGNMENT</programlisting>

			<para>Delivers the <code>ALIGNMENT</code> of <code>POINTER</code>s produced
				from <replaceable>local_alloc</replaceable>.</para>
		</section>

		<section id="callees_alignment">
			<title>callees_alignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf">var: BOOL
 -&gt; ALIGNMENT</programlisting>

			<para>If <replaceable>var</replaceable> is <replaceable>true</replaceable> the
				<code>ALIGNMENT</code> is that of callee parameters qualified by the
				<code>PROCPROPS</code> <replaceable>var_callees</replaceable>. If
				<replaceable>var</replaceable> is <replaceable>false</replaceable>, the
				<code>ALIGNMENT</code> is that of callee parameters not qualified by
				<code>PROCPROPS</code> <replaceable>var_callees</replaceable>.</para>

			<para>Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from a
				frame-pointer to a <code>CALLEE</code> parameter. Values of such
				<code>OFFSET</code>s can only be produced by
				<replaceable>env_offset</replaceable> applied to <code>CALLEE</code>
				parameters, or offset arithmetic operations applied to existing
				<code>OFFSET</code>s.</para>
		</section>

		<section id="callers_alignment">
			<title>callers_alignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf">var: BOOL
 -&gt; ALIGNMENT</programlisting>

			<para>If <replaceable>var</replaceable> is <replaceable>true</replaceable> the
				<code>ALIGNMENT</code> is that of caller parameters qualified by the
				<code>PROCPROPS</code> <replaceable>var_callers</replaceable>. If
				<replaceable>var</replaceable> is <replaceable>false</replaceable>, the
				<code>ALIGNMENT</code> is that of caller parameters not qualified by
				<code>PROCPROPS</code> <replaceable>var_callers</replaceable>.</para>

			<para>Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from a
				frame-pointer to a <code>CALLER</code> parameter. Values of such
				<code>OFFSET</code>s can only be produced by
				<replaceable>env_offset</replaceable> applied to <code>CALLER</code>
				parameters, or offset arithmetic operations applied to existing
				<code>OFFSET</code>s.</para>
		</section>

		<section id="code_alignment">
			<title>code_alignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ALIGNMENT</programlisting>

			<para>Delivers {<replaceable>code</replaceable>}, the <code>ALIGNMENT</code> of the
				<code>POINTER</code> produced by <replaceable>make_local_lv</replaceable>.</para>
		</section>

		<section id="locals_alignment">
			<title>locals_alignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ALIGNMENT</programlisting>

			<para>Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from a
				frame-pointer to a value defined by <replaceable>variable</replaceable> or
				<replaceable>identify</replaceable>. Values of such <code>OFFSET</code>s can
				only be produced by <replaceable>env_offset</replaceable> applied to
				<code>TAG</code>s so defined, or offset arithmetic operations applied to
				existing <code>OFFSET</code>s.</para>
		</section>

		<section id="obtain_al_tag">
			<title>obtain_al_tag</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>9</td> </tr>
			</informaltable>

			<programlisting language="tdf">at: AL_TAG
 -&gt; ALIGNMENT</programlisting>

			<para><replaceable>obtain_al_tag</replaceable> produces the <code>ALIGNMENT</code>
				with which the <code>AL_TAG</code> <replaceable>at</replaceable> is bound.</para>
		</section>

		<section id="parameter_alignment">
			<title>parameter_alignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>10</td> </tr>
			</informaltable>

			<programlisting language="tdf">sha: SHAPE
 -&gt; ALIGNMENT</programlisting>

			<para>Delivers the <code>ALIGNMENT</code> of a parameter of a procedure of
				<code>SHAPE</code> <replaceable>sha</replaceable>.</para>
		</section>

		<section id="unite_alignments">
			<title>unite_alignments</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>11</td> </tr>
			</informaltable>

			<programlisting language="tdf">a1: ALIGNMENT
a2: ALIGNMENT
 -&gt; ALIGNMENT</programlisting>

			<para><replaceable>unite_alignments</replaceable> produces the alignment at which
				all the members of the <code>ALIGNMENT</code> sets
				<replaceable>a1</replaceable> and <replaceable>a2</replaceable> can be placed - in
				other words the <code>ALIGNMENT</code> set which is the union of
				<replaceable>a1</replaceable> and <replaceable>a2</replaceable>.</para>
		</section>

		<section id="var_param_alignment">
			<title>var_param_alignment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>12</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ALIGNMENT</programlisting>
			<para>Delivers the <code>ALIGNMENT</code> used in the
				<replaceable>var_param</replaceable> argument of
				<replaceable>make_proc</replaceable>.</para>
		</section>
	</section>

	<section id="BITFIELD_VARIETY">
		<title>BITFIELD_VARIETY</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These describe runtime bitfield values. The intention is that these values
			are usually kept in memory locations which need not be aligned on
			addressing boundaries.</para>

		<para>There is no limit on the size of bitfield values in TDF, but an installer
			may specify limits. See <link linkend="representing-bitfields">Representing
			bitfields</link> and <link linkend="permitted-limits">Permitted limits</link>.</para>

		<section id="bfvar_apply_token">
			<title>bfvar_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; BITFIELD_VARIETY</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give a
				<code>BITFIELD_VARIETY</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="bfvar_cond">
			<title>bfvar_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM BITFIELD_VARIETY
e2:      BITSTREAM BITFIELD_VARIETY
 -&gt; BITFIELD_VARIETY</programlisting>

			<para><replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed. If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="bfvar_bits">
			<title>bfvar_bits</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">issigned: BOOL
bits:     NAT
 -&gt; BITFIELD_VARIETY</programlisting>

			<para><replaceable>bfvar_bits</replaceable> constructs a
				<code>BITFIELD_VARIETY</code> describing a pattern of
				<replaceable>bits</replaceable> bits. If <replaceable>issigned</replaceable> is
				<replaceable>true</replaceable>, the pattern is considered to be a
twos-complement signed number: otherwise it is considered to be
				unsigned.</para>
		</section>
	</section>

	<section id="BITSTREAM">
		<title>BITSTREAM</title>

		<para>A <code>BITSTREAM</code> consists of an encoding of any number of bits.
			This encoding is such that any program reading TDF can determine how to
			skip over it. To read it meaningfully extra knowledge of what it
			represents may be needed.</para>

		<para>A <code>BITSTREAM</code> is used, for example, to supply parameters in a
			<code>TOKEN</code> application. If there is a definition of this
			<code>TOKEN</code> available, this will provide the information needed to
			decode the bitstream.</para>

		<para>See <link linkend="tdf-encoding">The TDF encoding</link>.</para>
	</section>

	<section id="BOOL">
		<title>BOOL</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>A <code>BOOL</code> is a piece of TDF which can take two values,
			<replaceable>true</replaceable> or <replaceable>false</replaceable>.</para>

		<section id="bool_apply_token">
			<title>bool_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; BOOL</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give a
				<code>BOOL</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="bool_cond">
			<title>bool_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM BOOL
e2:      BITSTREAM BOOL
 -&gt; BOOL</programlisting>

			<para><replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="false">
			<title>false</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; BOOL</programlisting>

			<para><replaceable>false</replaceable> produces a false <code>BOOL</code>.</para>
		</section>

		<section id="true">
			<title>true</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; BOOL</programlisting>

			<para><replaceable>true</replaceable> produces a true <code>BOOL</code>.</para>
		</section>
	</section>

	<section id="BYTESTREAM">
		<title>BYTESTREAM</title>

		<para>A <code>BYTESTREAM</code> is analogous to a <code>BITSTREAM</code>, but is
			encoded to permit fast copying.</para>

		<para>See <link linkend="tdf-encoding">The TDF encoding</link>.</para>
	</section>

	<section id="CALLEES">
		<title>CALLEES</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>This is an auxilliary <code>SORT</code> used in calling procedures by
			<replaceable>apply_general_proc</replaceable> and <replaceable>tail_call</replaceable>
			to provide their actual callee parameters.</para>

		<section id="make_callee_list">
			<title>make_callee_list</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">args: LIST(EXP)
 -&gt; CALLEES</programlisting>

			<para>The list of <code>EXP</code>s <replaceable>args</replaceable> are evaluated in
				any interleaved order and the resulting list of values form the actual
				callee parameters of the call.</para>
		</section>

		<section id="make_dynamic_callees">
			<title>make_dynamic_callees</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">ptr: EXP POINTER(x)
sze: EXP OFFSET(x, y)
 -&gt; CALLEES</programlisting>

			<para>The value of size <replaceable>sze</replaceable> pointed at by
				<replaceable>ptr</replaceable> forms the actual callee parameters of the call.</para>

			<para>The <code>CALLEES</code> value is intended to refer to a sequence of
				zero or more callee parameters. <replaceable>x</replaceable> will include
				<replaceable>parameter_alignment</replaceable>(<replaceable>s</replaceable>) for
				each <replaceable>s</replaceable> that is the <code>SHAPE</code> of an
				intended callee parameter. The value addressed by
				<replaceable>ptr</replaceable> may be produced in one of two ways.	It may be
				produced as a <code>COMPOUND SHAPE</code> value in the normal sense of a
				structure, whose successive elements will be used to generate the
				sequence of callee parameters. In this case, each element in the
				sequence of <code>SHAPE</code> <replaceable>s</replaceable> must additionally
				be padded to
				<replaceable>parameter_alignment</replaceable>(<replaceable>s</replaceable>).
				Alternatively, <replaceable>ptr</replaceable> may address the callee
				parameters of an already activated procedure, by referring to the first
				of the sequence.	<replaceable>sze</replaceable> will be equivalent to
				<replaceable>shape_offset</replaceable>(<replaceable>c</replaceable>) where
				<replaceable>c</replaceable> is the <code>COMPOUND SHAPE</code> just
				described.</para>

			<para>The call involved (i.e. <replaceable>apply_general_proc</replaceable> or
				<replaceable>tail_call</replaceable>) must have a
				<replaceable>var_callees</replaceable> <code>PROCPROPS</code>.</para>
		</section>

		<section id="same_callees">
			<title>same_callees</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; CALLEES</programlisting>

			<para>The callee parameters of the call are the same as those of the current
				procedure.</para>
		</section>
	</section>

	<section id="CAPSULE">
		<title>CAPSULE</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>A <code>CAPSULE</code> is an independent piece of TDF. There is only one
			construction, <replaceable>make_capsule</replaceable>.</para>

		<section id="make_capsule">
			<title>make_capsule</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">prop_names:  SLIST(TDFIDENT)
cap_linking: SLIST(CAPSULE_LINK)
ext_linkage: SLIST(EXTERN_LINK)
groups:      SLIST(GROUP)
 -&gt; CAPSULE</programlisting>

			<para><replaceable>make_capsule</replaceable> brings together <code>UNIT</code>s and
				linking and naming information. See <link linkend="overall-structure">The Overall
				Structure</link>.</para>

			<para>The elements of the list, <replaceable>prop_names</replaceable>, correspond
				one-to-one with the elements of the list, <replaceable>groups</replaceable>.
				The element of <replaceable>prop_names</replaceable> is the unit
				identification of all the <code>UNIT</code>s in the corresponding
				<code>GROUP</code>. See <link linkend="PROPS"><code>PROPS</code></link>.
				A <code>CAPSULE</code> need not contain all the kinds of
				<code>UNIT</code>.</para>

			<para>It is intended that new kinds of <code>PROPS</code> with new unit
				identifications can be added to the standard in a purely additive
				fashion, either to form a new standard or for private purposes.</para>

			<para>The elements of the list, <replaceable>cap_linking</replaceable>, correspond
				one-to-one with the elements of the list,
				<replaceable>ext_linkage</replaceable>. The element of
				<replaceable>cap_linking</replaceable> gives the linkable entity
				identification for all the <code>LINKEXTERN</code>s in the element of
				<replaceable>ext_linkage</replaceable>.	It also gives the number of
				<code>CAPSULE</code> level linkable entities having that identification.</para>

			<para>The elements of the list, <replaceable>cap_linking</replaceable>, also
				correspond one-to-one with the elements of the lists called
				<replaceable>local_vars</replaceable> in each of the
				<replaceable>make_unit</replaceable> constructions for the <code>UNIT</code>s
				in <replaceable>groups</replaceable>. The element of
				<replaceable>local_vars</replaceable> gives the number of <code>UNIT</code>
				level linkable entities having the identification in the corresponding
				member of <replaceable>cap_linking</replaceable>.</para>

			<para>It is intended that new kinds of linkable entity can be added to the
				standard in a purely additive fashion, either to form a new standard or
				for private purposes.</para>

			<para><replaceable>ext_linkage</replaceable> provides a list of lists of
				<code>LINKEXTERN</code>s. These <code>LINKEXTERN</code>s specify the
				associations between the names to be used outside the
				<code>CAPSULE</code> and the linkable entities by which the
				<code>UNIT</code>s make objects available within the
				<code>CAPSULE</code>.</para>

			<para>The list, <replaceable>groups</replaceable>, provides the non-linkage
				information of the <code>CAPSULE</code>.</para>
		</section>
	</section>

	<section id="CAPSULE_LINK">
		<title>CAPSULE_LINK</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>An auxiliary <code>SORT</code> which gives the number of linkable entities
			of a given kind at <code>CAPSULE</code> level. It is used only in
			<replaceable>make_capsule</replaceable>.</para>

		<section id="make_capsule_link">
			<title>make_capsule_link</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">sn: TDFIDENT
n:  TDFINT
 -&gt; CAPSULE_LINK</programlisting>

			<para><replaceable>n</replaceable> is the number of <code>CAPSULE</code> level
				linkable entities (numbered from 0 to <replaceable>n</replaceable>-1) of the
				kind given by <replaceable>sn</replaceable>.	<replaceable>sn</replaceable>
				corresponds to the linkable entity identification.</para>
		</section>
	</section>

	<section id="CASELIM">
		<title>CASELIM</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>An auxiliary <code>SORT</code> which provides lower and upper bounds and
			the <code>LABEL</code> destination for the <replaceable>case</replaceable>
			construction.</para>

		<section id="make_caselim">
			<title>make_caselim</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">branch: LABEL
lower:  SIGNED_NAT
upper:  SIGNED_NAT
 -&gt; CASELIM</programlisting>

			<para>Makes a triple of destination and limits. The <replaceable>case</replaceable>
				construction uses a list of <code>CASELIM</code>s. If the control
				variable of the <replaceable>case</replaceable> lies between
				<replaceable>lower</replaceable> and <replaceable>upper</replaceable>, control
				passes to <replaceable>branch</replaceable>.</para>
		</section>
	</section>

	<section id="error_code">
		<title>ERROR_code</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<section id="nil_access">
			<title>nil_access</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ERROR_code</programlisting>

			<para>Delivers the <code>ERROR_code</code> arising from an attempt to access a
				nil pointer in an operation with <code>TRANSFER_MODE</code>
				<replaceable>trap_on_nil</replaceable>.</para>
		</section>

		<section id="overflow">
			<title>overflow</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ERROR_code</programlisting>

			<para>Delivers the <code>ERROR_code</code> arising from a numerical
				exceptional result in an operation with <code>ERROR_TREATMENT</code>
				<replaceable>trap</replaceable>(<replaceable>overflow</replaceable>).</para>
		</section>

		<section id="stack_overflow">
			<title>stack_overflow</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ERROR_code</programlisting>

			<para>Delivers the <code>ERROR_code</code> arising from a stack overflow in
				the call of a procedure defined with <code>PROCPROPS</code>
				<replaceable>check_stack.</replaceable>
			</para>
		</section>
	</section>

	<section id="ERROR_TREATMENT">
		<title>ERROR_TREATMENT</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These values describe the way to handle various forms of error which can
			occur during the evaluation of operations.</para>

		<para><replaceable>It is expected that additional <code>ERROR_TREATMENT</code>s
			will be needed.</replaceable></para>

		<section id="errt_apply_token">
			<title>errt_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; ERROR_TREATMENT</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give an
				<code>ERROR_TREATMENT</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="errt_cond">
			<title>errt_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM ERROR_TREATMENT
e2:      BITSTREAM ERROR_TREATMENT
 -&gt; ERROR_TREATMENT</programlisting>

			<para><replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed. If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="continue">
			<title>continue</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ERROR_TREATMENT</programlisting>

			<para>If an operation with a <replaceable>continue</replaceable>
				<code>ERROR_TREATMENT</code> causes an error, some value of the correct
				<code>SHAPE</code> shall be delivered. This value shall have the same
				properties as is specified in <replaceable>make_value</replaceable>.</para>
		</section>

		<section id="error_jump">
			<title>error_jump</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf">lab: LABEL
 -&gt; ERROR_TREATMENT</programlisting>

			<para><replaceable>error_jump</replaceable> produces an <code>ERROR_TREATMENT</code>
				which requires that control be passed to <replaceable>lab</replaceable> if it
				is invoked. <replaceable>lab</replaceable> will be in scope.</para>

			<para>If a construction has an <replaceable>error_jump</replaceable>
				<code>ERROR_TREATMENT</code> and the jump is taken, the canonical order
				specifies only that the jump occurs after evaluating the construction.
				It is not specified how many further constructions are evaluated.</para>

			<para>This rule implies that a further construction is needed to
				guarantee that errors have been processed. This is not yet included.
				The effect of nearby procedure calls or exits also needs
				definition.
			</para>
		</section>

		<section id="trap">
			<title>trap</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf">trap_list: LIST(ERROR_code)
 -&gt; ERROR_TREATMENT</programlisting>

			<para>The list of <code>ERROR_codeS</code> in <replaceable>trap_list</replaceable>
				specifies a set of possible exceptional behaviours. If any of these
				occur in an construction with <code>ERROR_TREATMENT</code>
				<replaceable>trap</replaceable>, the TDF exception handling is invoked (see
				<link linkend="exceptions-and-jumps">section 7.8</link>).</para>

			<para>The observations on canonical ordering in
				<replaceable>error_jump</replaceable> apply equally here.</para>
		</section>

		<section id="wrap">
			<title>wrap</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ERROR_TREATMENT</programlisting>

			<para><replaceable>wrap</replaceable> is an <code>ERROR_TREATMENT</code> which will
				only be used in constructions with integer operands and delivering
				<code>EXP</code> <code>INTEGER</code>(<replaceable>v</replaceable>) where
				either the lower bound of <replaceable>v</replaceable> is zero or the
				construction is not one of <replaceable>mult, power, div0, div1, div2,
				rem0, rem1, rem2</replaceable>. The result will be evaluated and any bits
				in the result lying outside the representing <code>VARIETY</code> will
				be discarded (see <link linkend="representing-integers">Representing integers</link>
			</para>
		</section>

		<section id="impossible">
			<title>impossible</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ERROR_TREATMENT</programlisting>

			<para><replaceable>impossible</replaceable> is an <code>ERROR_TREATMENT</code> which
				means that this error will not occur in the construct concerned.</para>

			<para><replaceable>impossible is possibly a misnomer. If an error occurs the
				result is undefined.</replaceable>
			</para>
		</section>
	</section>

	<section id="EXP">
		<title>EXP</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>7</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para><code>EXP</code>s are pieces of TDF which are translated into program.
			<code>EXP</code> is by far the richest <code>SORT</code>. There are few
primitive <code>EXP</code>s: most of the constructions take arguments
			which are a mixture of <code>EXP</code>s and other <code>SORT</code>s.
			There are constructs delivering <code>EXP</code>s that correspond to the
			declarations, program structure, procedure calls, assignments, pointer
			manipulation, arithmetic operations, tests etc. of programming languages.</para>

		<section id="exp_apply_token">
			<title>exp_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; EXP x</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give an
				<code>EXP</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="exp_cond">
			<title>exp_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM EXP x
e2:      BITSTREAM EXP y
 -&gt; EXP (control ? x : y)</programlisting>

			<para><replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="abs">
			<title>abs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
arg1:   EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The absolute value of the result produced by <replaceable>arg1</replaceable>
				is delivered.</para>

			<para>If the result cannot be expressed in the <code>VARIETY</code> being used
				to represent <replaceable>v</replaceable>, an overflow error is caused and is
				handled in the way specified by <replaceable>ov_err</replaceable>.</para>
		</section>

		<section id="add_to_ptr">
			<title>add_to_ptr</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP POINTER(x)
arg2: EXP OFFSET(y, z)
 -&gt; EXP POINTER(z)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated, giving <replaceable>p</replaceable>,
				and <replaceable>arg2</replaceable> is evaluated and the results are added to
				produce the answer. The result is derived from the pointer delivered by
				<replaceable>arg1</replaceable>. The intention is to produce a
				<code>POINTER</code> displaced from the argument <code>POINTER</code> by
				the given amount.</para>

			<para><replaceable>x</replaceable> will include <replaceable>y</replaceable>.</para>

			<para><replaceable>arg1</replaceable> may deliver a null <code>POINTER</code>. In
				this case the result is derived from a null <code>POINTER</code> which
				counts as an original <code>POINTER</code>. Further <code>OFFSET</code>s
				may be added to the result, but the only other useful operation on the
				result of adding a number of <code>OFFSET</code>s to a null
				<code>POINTER </code> is to <replaceable>subtract_ptrs</replaceable> a null
				<code>POINTER</code> from it.</para>

			<para>The result will be less than or equal (in the sense of
				<replaceable>pointer_test</replaceable>) to the result of applying
				<replaceable>add_to_ptr</replaceable> to the original pointer from which
				<replaceable>p</replaceable> is derived and the size of the space allocated
				for the original pointer.</para>

			<para>In the simple representation of <code>POINTER</code>
				arithmetic (see <link linkend="memory-model">Memory Model</link>) add_to_ptr is
				represented by addition. The constraint &ldquo;x includes y&rdquo;
				ensures that no padding has to be inserted in this case.
			</para>
		</section>

		<section id="and">
			<title>and</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The arguments are evaluated producing integer values of the same
				<code>VARIETY</code>, <replaceable>v</replaceable>. The result is the bitwise
				<replaceable>and</replaceable> of the two values in the representing
				<code>VARIETY</code>. The result is delivered with the same
				<code>SHAPE</code> as the arguments.</para>

			<para>See <link linkend="representing-integers">Representing integers</link>.</para>
		</section>

		<section id="apply_proc">
			<title>apply_proc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf">result_shape: SHAPE
p:            EXP PROC
params:       LIST(EXP)
var_param:    OPTION(EXP)
 -&gt; EXP result_shape</programlisting>

			<para><replaceable>p, params</replaceable> and <replaceable>var_param</replaceable> (if
				present) are evaluated in any interleaved order. The procedure,
				<replaceable>p</replaceable>, is applied to the parameters. The result of the
				procedure call, which will have <replaceable>result_shape</replaceable>, is
				delivered as the result of the construction.</para>

			<para>The canonical order of evaluation is as if the definition were in-lined.
				That is, the actual parameters are evaluated interleaved in any order
				and used to initialise variables which are identified by the formal
				parameters during the evaluation of the procedure body. When this is
				complete the body is evaluated. So <replaceable>apply_proc</replaceable> is
				evaluated like a <replaceable>variable</replaceable> construction, and obeys
				similar rules for order of evaluation.</para>

			<para>If <replaceable>p</replaceable> delivers a null procedure the effect is
				undefined.</para>

			<para><replaceable>var_param</replaceable> is intended to communicate parameters
				which vary in <code>SHAPE</code> from call to call. Access to these
				parameters during the procedure is performed by using
				<code>OFFSET</code> arithmetic.	Note that it is necessary to place
				these values on <replaceable>var_param_alignment</replaceable> because of the
				definition of <replaceable>make_proc</replaceable>.</para>

			<para>The optional <replaceable>var_param</replaceable> should not be confused with
				variable argument lists in the C (<replaceable>&lt;stdarg.h&gt;</replaceable>
				or <replaceable>&lt;varargs.h&gt;</replaceable>) sense, which are communicated
				by extending the <replaceable>params</replaceable> list.	This is discussed
				further in <link linkend="procedures">section 7.9</link>. If the number of
				arguments in the <replaceable>params</replaceable> list differs from the
				number of elements in the <replaceable>params_intro</replaceable> of the
				corresponding <replaceable>make_proc</replaceable>, then
				<replaceable>var_param</replaceable> must not be present.</para>

			<para>All calls to the same procedure will yield results of the same
				<code>SHAPE</code>.</para>

			<para>For notes on the intended implementation of procedures see <link linkend="procedures">section 7.9</link>.</para>
		</section>

		<section id="apply_general_proc">
			<title>apply_general_proc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf">result_shape:  SHAPE
prcprops:      OPTION(PROCPROPS)
p:             EXP PROC
callers_intro: LIST(OTAGEXP)
callee_pars:   CALLEES
postlude:      EXP TOP
 -&gt; EXP result_shape</programlisting>

			<para><replaceable>p</replaceable>, <replaceable>callers_intro</replaceable> and
				<replaceable>callee_pars</replaceable> are evaluated in any order. The
				procedure, <replaceable>p</replaceable>, is applied to the parameters.	The
				result of the procedure call, which will have
				<replaceable>result_shape</replaceable>, is delivered as the result of the
				construction.</para>

			<para>If <replaceable>p</replaceable> delivers a null procedure the effect is
				undefined.</para>

			<para>Any <code>TAG</code> introduced by an <code>OTAGEXP</code> in
				<replaceable>callers_intro</replaceable> is available in
				<replaceable>postlude</replaceable> which will be evaluated after the
				application.</para>

			<para><replaceable>postlude</replaceable> will not contain any
				<replaceable>local_allocs</replaceable> or calls of procedures with untidy
				returns. If <replaceable>prcprops</replaceable> include
				<replaceable>untidy</replaceable>, <replaceable>postlude</replaceable> will be
				<replaceable>make_top</replaceable>.</para>

			<para>The canonical order of evaluation is as if the definition of
				<replaceable>p</replaceable> were inlined in a manner dependent on
				<replaceable>prcprops</replaceable>.</para>

			<para>If none of the <code>PROCPROPS</code> <replaceable>var_callers</replaceable>,
				<replaceable>var_callees</replaceable> and <replaceable>check_stack</replaceable>
				are present the inlining is as follows, supposing that P is the body of
the definition of <replaceable>p</replaceable>:</para>

			<para>Let R<replaceable>i</replaceable> be the value of the <code>EXP</code> of the
				i<replaceable>th</replaceable> <code>OTAGEXP</code> in
				<replaceable>callers_intro</replaceable> and T<replaceable>i</replaceable> be its
				<code>TAG</code> (if it is present). Let E<replaceable>i</replaceable> be the
				i<replaceable>th</replaceable> value in
				<replaceable>callee_pars</replaceable>. Let r<replaceable>i</replaceable> be
				the i<replaceable>th</replaceable> formal caller parameter <code>TAG</code> of
				<replaceable>p</replaceable>. Let e<replaceable>i</replaceable> be the
				i<replaceable>th</replaceable> formal callee parameter <code>TAG</code> of
				<replaceable>p</replaceable>.</para>

			<para>Each R<replaceable>i</replaceable> is used to initialise a variable which is
				identified by r<replaceable>i</replaceable>; there will be exactly as many
				R<replaceable>i</replaceable> as r<replaceable>i</replaceable>.The scope of these
				variable definitions is a sequence consisting of three components - the
				identification of a <code>TAG</code> <replaceable>res</replaceable> with the
				result of a binding of P, followed by a binding of
				<replaceable>postlude</replaceable>, followed by an
				<replaceable>obtain_tag</replaceable> of <replaceable>res</replaceable> giving the
				result of the inlined procedure call.</para>

			<para>The binding of P consists of using each E<replaceable>i</replaceable> to
				initialise a variable identified with e<replaceable>i</replaceable>; there
				will be exactly as many E<replaceable>i</replaceable> as
				e<replaceable>i</replaceable>. The scope of these variable definitions is P
				modified so that the first <replaceable>return</replaceable> or
				<replaceable>untidy_return</replaceable> encountered in P gives the result of
				the binding. If it ends with a <replaceable>return</replaceable>, any space
				generated by <replaceable>local_allocs</replaceable> within the binding is
				freed (in the sense of <replaceable>local_free</replaceable>) at this point.
				If it ends with <replaceable>untidy_return</replaceable>, no freeing will take
				place.</para>

			<para>The binding of <replaceable>postlude</replaceable> consists of identifying
				each T<replaceable>i</replaceable> (if present) with the contents of the
				variable identified by r<replaceable>i</replaceable>.	The scope of these
				identifications is <replaceable>postlude</replaceable>.</para>

			<para>If the <code>PROCPROPS</code> <replaceable>var_callers</replaceable> is
present, the inlining process is modified by: A compound variable
				is constructed initialised to R<replaceable>i</replaceable> in order; the
				alignment and padding of each individual R<replaceable>i</replaceable> will be
				given by an exact application of
				<replaceable>parameter_alignment</replaceable> on the <code>SHAPE</code> of
				R<replaceable>i</replaceable>. Each r<replaceable>i</replaceable> is then identified
				with a pointer to the copy of R<replaceable>i</replaceable> within the
				compound variable; there will be at least as many
				R<replaceable>i</replaceable> as r<replaceable>i</replaceable>. The evaluation then
				continues as above with the scope of these identifications being the
				sequence.</para>

			<para>If the <code>PROCPROPS</code> <replaceable>var_callees</replaceable> is
present, the inlining process is modified by: The binding of P is
				done by generating (as if by <replaceable>local_alloc</replaceable>) a pointer
				to space for a compound value constructed from each
				E<replaceable>i</replaceable> in order (just as for
				<replaceable>var_callers</replaceable>). Each e<replaceable>i</replaceable> is
				identified with a pointer to the copy of E<replaceable>i</replaceable> within
				the generated space; there will be at least as many
				e<replaceable>i</replaceable> as E<replaceable>i</replaceable>. P is evaluated
				within the scope of these identifications as before. Note that the
				generation of space for these callee parameters is a
				<replaceable>local_alloc</replaceable> with the binding of P, and hence will
				not be freed if P ends with an <replaceable>untidy_return</replaceable>.</para>
		</section>

		<section id="assign">
			<title>assign</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP POINTER(x)
arg2: EXP y
 -&gt; EXP TOP</programlisting>

			<para>The value produced by <replaceable>arg2</replaceable> will be put in the space
				indicated by <replaceable>arg1</replaceable>.</para>

			<para><replaceable>x</replaceable> will include
				<replaceable>alignment</replaceable>(<replaceable>y</replaceable>).</para>

			<para><replaceable>y</replaceable> will not be a <code>BITFIELD</code>.</para>

			<para>If the space which the pointer indicates does not lie wholly within the
				space indicated by the original pointer from which it is derived, the
				effect is undefined.</para>

			<para>If the value delivered by <replaceable>arg1</replaceable> is a null pointer
				the effect is undefined.</para>

			<para>See <link linkend="overlapping">Overlapping</link> and <link linkend="incomplete-assignment">Incomplete assignment</link>.</para>

			<para>The constraint &ldquo;x will include alignment(y)&rdquo;
				ensures in the simple memory model that no change is needed to the
				<code>POINTER</code>.
			</para>
		</section>

		<section id="assign_with_mode">
			<title>assign_with_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>9</td> </tr>
			</informaltable>

			<programlisting language="tdf">md:   TRANSFER_MODE
arg1: EXP POINTER(x)
arg2: EXP y
 -&gt; EXP TOP</programlisting>

			<para>The value produced by <replaceable>arg2</replaceable> will be put in the space
				indicated by <replaceable>arg1</replaceable>. The assignment will be carried
				out as specified by the <code>TRANSFER_MODE</code> (q.v.).</para>

			<para>If <replaceable>md</replaceable> consists of
				<replaceable>standard_transfer_mode</replaceable> only, then
				<replaceable>assign_with_mode</replaceable> is the same as
				<replaceable>assign</replaceable>.</para>

			<para><replaceable>x</replaceable> will include
				<replaceable>alignment</replaceable>(<replaceable>y</replaceable>).</para>

			<para><replaceable>y</replaceable> will not be a <code>BITFIELD</code>.</para>

			<para>If the space which the pointer indicates does not lie wholly within the
				space indicated by the original pointer from which it is derived, the
				effect is undefined.</para>

			<para>If the value delivered by <replaceable>arg1</replaceable> is a null pointer
				the effect is undefined.</para>

			<para>See <link linkend="overlapping">Overlapping</link> and <link linkend="incomplete-assignment">&gt;Incomplete assignment</link>.</para>
		</section>

		<section id="bitfield_assign">
			<title>bitfield_assign</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>10</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP POINTER(x)
arg2: EXP OFFSET(y, z)
arg3: EXP BITFIELD(v)
 -&gt; EXP TOP</programlisting>

			<para>The value delivered by <replaceable>arg3</replaceable> is assigned at a
				displacement given by <replaceable>arg2</replaceable> from the pointer
				delivered by <replaceable>arg1</replaceable>.</para>

			<para><replaceable>x</replaceable> will include <replaceable>y</replaceable> and
				<replaceable>z</replaceable> will include <replaceable>v</replaceable>.</para>

			<para><replaceable>arg2</replaceable>, <code>BITFIELD</code>(<replaceable>v</replaceable>)
				will be <replaceable>variety-enclosed</replaceable> (see <link linkend="representing-bitfields">section 7.24</link>).</para>
		</section>

		<section id="bitfield_assign_with_mode">
			<title>bitfield_assign_with_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>11</td> </tr>
			</informaltable>

			<programlisting language="tdf">md:   TRANSFER_MODE
arg1: EXP POINTER(x)
arg2: EXP OFFSET(y, z)
arg3: EXP BITFIELD(v)
 -&gt; EXP TOP</programlisting>

			<para>The value delivered by <replaceable>arg3</replaceable> is assigned at a
				displacement given by <replaceable>arg2</replaceable> from the pointer
				delivered by <replaceable>arg1</replaceable>.The assignment will be carried
				out as specified by the <code>TRANSFER_MODE</code> (q.v.).</para>

			<para>If <replaceable>md</replaceable> consists of
				<replaceable>standard_transfer_mode</replaceable> only, then
				<replaceable>bitfield_assign_with_mode</replaceable> is the same as
				<replaceable>bitfield_assign</replaceable>.</para>

			<para><replaceable>arg2</replaceable>, <code>BITFIELD</code>(<replaceable>v</replaceable>)
				will be <replaceable>variety-enclosed</replaceable>.(see <link linkend="representing-bitfields">section 7.24</link>).</para>
		</section>

		<section id="bitfield_contents">
			<title>bitfield_contents</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>12</td> </tr>
			</informaltable>

			<programlisting language="tdf">v:    BITFIELD_VARIETY
arg1: EXP POINTER(x)
arg2: EXP OFFSET(y, z)
 -&gt; EXP BITFIELD(v)</programlisting>

			<para>The bitfield of <code>BITFIELD_VARIETY</code> <replaceable>v</replaceable>,
				located at the displacement delivered by <replaceable>arg2</replaceable> from
				the pointer delivered by <replaceable>arg1</replaceable> is extracted and
				delivered.</para>

			<para><replaceable>x</replaceable> will include <replaceable>y</replaceable> and
				<replaceable>z</replaceable> will include <replaceable>v</replaceable>.</para>

			<para><replaceable>arg2</replaceable>, <code>BITFIELD</code>(<replaceable>v</replaceable>)
				will be <replaceable>variety_enclosed</replaceable> (see <link linkend="representing-bitfields">section 7.24</link>).</para>
		</section>

		<section id="bitfield_contents_with_mode">
			<title>bitfield_contents_with_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>13</td> </tr>
			</informaltable>

			<programlisting language="tdf">md:   TRANSFER_MODE
v:    BITFIELD_VARIETY
arg1: EXP POINTER(x)
arg2: EXP OFFSET(y, z)
 -&gt; EXP BITFIELD(v)</programlisting>

			<para>The bitfield of <code>BITFIELD_VARIETY </code><replaceable>v</replaceable>,
				located at the displacement delivered by <replaceable>arg2</replaceable> from
				the pointer delivered by <replaceable>arg1</replaceable> is extracted and
				delivered.The operation will be carried out as specified by the
				<code>TRANSFER_MODE</code> (q.v.).</para>

			<para>If <replaceable>md</replaceable> consists of
				<replaceable>standard_transfer_mode</replaceable> only, then
				<replaceable>bitfield_contents_with_mode</replaceable> is the same as
				<replaceable>bitfield_contents</replaceable>.</para>

			<para><replaceable>x</replaceable> will include <replaceable>y</replaceable> and
				<replaceable>z</replaceable> will include <replaceable>v</replaceable>.</para>

			<para><replaceable>arg2</replaceable>, <code>BITFIELD</code>(<replaceable>v</replaceable>)
				will be <replaceable>variety_enclosed</replaceable> (see <link linkend="representing-bitfields">section 7.24</link>).</para>
		</section>

		<section id="case">
			<title>case</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>14</td> </tr>
			</informaltable>

			<programlisting language="tdf">exhaustive: BOOL
control:    EXP INTEGER(v)
branches:   LIST(CASELIM)
 -&gt; EXP (exhaustive ? BOTTOM : TOP)</programlisting>

			<para><replaceable>control</replaceable> is evaluated to produce an integer value,
				<replaceable>c</replaceable>. Then <replaceable>c</replaceable> is tested to see if
				it lies inclusively between <replaceable>lower</replaceable> and
				<replaceable>upper</replaceable>, for each element of
				<replaceable>branches</replaceable>. If this tests succeeds, control passes to
				the label <replaceable>branch</replaceable> belonging to that
				<code>CASELIM</code> (see <link linkend="CASELIM">section 5.13</link>). If
				<replaceable>c</replaceable> lies between no pair, the construct delivers a
				value of <code>SHAPE TOP</code>. The order in which the comparisons are
				made is undefined.</para>

			<para>The sets of <code>SIGNED_NAT</code>s in <replaceable>branches</replaceable>
				will be disjoint.</para>

			<para>If <replaceable>exhaustive</replaceable> is true the value delivered by
				<replaceable>control</replaceable> will lie between one of the
				<replaceable>lower</replaceable>/<replaceable>upper</replaceable> pairs.</para>
		</section>

		<section id="change_bitfield_to_int">
			<title>change_bitfield_to_int</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>15</td> </tr>
			</informaltable>

			<programlisting language="tdf">v:    VARIETY
arg1: EXP BITFIELD(bv)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and converted to a
				<code>INTEGER</code>(<replaceable>v</replaceable>).</para>

			<para>If <replaceable>arg1</replaceable> exceed the bounds of
				<replaceable>v</replaceable>, the effect is undefined.</para>
		</section>

		<section id="change_floating_variety">
			<title>change_floating_variety</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>16</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
r:        FLOATING_VARIETY
arg1:     EXP FLOATING(f)
 -&gt; EXP FLOATING(r)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and will produce floating point
				value, <replaceable>fp</replaceable>. The value <replaceable>fp</replaceable> is
				delivered, changed to the representation of the
				<code>FLOATING_VARIETY</code> <replaceable>r</replaceable>.</para>

			<para>Either <replaceable>r</replaceable> and <replaceable>f</replaceable> will both real
				or both complex.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>.</para>

			<para>See <link linkend="float-errors">Floating point errors</link>.</para>
		</section>

		<section id="change_variety">
			<title>change_variety</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>17</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
r:      VARIETY
arg1:   EXP INTEGER(v)
 -&gt; EXP INTEGER(r)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and will produce an integer
				value, <replaceable>a</replaceable>.	The value <replaceable>a</replaceable> is
				delivered, changed to the representation of the <code>VARIETY</code>
				<replaceable>r</replaceable>.</para>

			<para>If <replaceable>a</replaceable> is not contained in the <code>VARIETY</code>
				being used to represent <replaceable>r</replaceable>, an overflow occurs and
				is handled according to <replaceable>ov_err</replaceable>.</para>
		</section>

		<section id="change_int_to_bitfield">
			<title>change_int_to_bitfield</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>18</td> </tr>
			</informaltable>

			<programlisting language="tdf">bv:   BITFIELD_VARIETY
arg1: EXP INTEGER(v)
 -&gt; EXP BITFIELD(bv)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and converted to a
				<code>BITFIELD</code>(<replaceable>bv</replaceable>).</para>

			<para>If <replaceable>arg1</replaceable> exceed the bounds of
				<replaceable>bv</replaceable>, the effect is undefined.</para>
		</section>

		<section id="complex_conjugate">
			<title>complex_conjugate</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>19</td> </tr>
			</informaltable>

			<programlisting language="tdf">c: EXP FLOATING(cv)
 -&gt; EXP FLOATING(cv)</programlisting>

			<para>Delivers the complex conjugate of <replaceable>c</replaceable>.</para>

			<para><replaceable>cv</replaceable> will be a complex floating variety.</para>
		</section>

		<section id="component">
			<title>component</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>20</td> </tr>
			</informaltable>

			<programlisting language="tdf">sha:  SHAPE
arg1: EXP COMPOUND(EXP OFFSET(x, y))
arg2: EXP OFFSET(x, alignment(sha))
 -&gt; EXP sha</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated to produce a
				<code>COMPOUND</code> value.	The component of this value at the
				<code>OFFSET</code> given by <replaceable>arg2</replaceable> is delivered.
		This will have <code>SHAPE</code> <replaceable>sha</replaceable>.</para>

			<para><replaceable>arg2</replaceable> will be a constant and non-negative (see <link linkend="constant-evaluation">Constant evaluation</link>).</para>

			<para>If <replaceable>sha</replaceable> is a <code>BITFIELD</code> then
				<replaceable>arg2</replaceable>, <replaceable>sha</replaceable> will be
				<replaceable>variety_enclosed</replaceable> (see <link linkend="representing-bitfields">section
				7.24</link>).</para>
		</section>

		<section id="concat_nof">
			<title>concat_nof</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>21</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP NOF(n, s)
arg2: EXP NOF(m, s)
 -&gt; EXP NOF(n+m, s)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and their results concatenated. In the result the components derived
				from <replaceable>arg1</replaceable> will have lower indices than those
				derived from <replaceable>arg2</replaceable>.</para>
		</section>

		<section id="conditional">
			<title>conditional</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>22</td> </tr>
			</informaltable>

			<programlisting language="tdf">altlab_intro: LABEL
first:        EXP x
alt:          EXP z
 -&gt; EXP (x LUB z)</programlisting>

			<para><replaceable>first</replaceable> is evaluated. If <replaceable>first</replaceable>
				produces a result, <replaceable>f</replaceable>, this value is delivered as
				the result of the whole construct, and <replaceable>alt</replaceable> is not
				evaluated.</para>

			<para>If <replaceable>goto</replaceable>(<replaceable>altlab_intro</replaceable>) or any
				other jump (including <replaceable>long_jump</replaceable>) to
				<replaceable>altlab_intro</replaceable> is obeyed during the evaluation of
				<replaceable>first</replaceable>, then the evaluation of
				<replaceable>first</replaceable> will stop, <replaceable>alt</replaceable> will be
				evaluated and its result delivered as the result of the construction.</para>

			<para>The lifetime of <replaceable>altlab_intro</replaceable> is the evaluation of
				<replaceable>first</replaceable>. <replaceable>altlab_intro</replaceable> will not
				be used within <replaceable>alt</replaceable>.</para>

			<para>The actual order of evaluation of the constituents shall be
				indistinguishable in all observable effects (apart from time) from
				evaluating all the obeyed parts of <replaceable>first</replaceable> before any
				obeyed part of <replaceable>alt</replaceable>.	Note that this specifically
				includes any defined error handling.</para>

			<para>For LUB see <link linkend="least-upper-bound">Least Upper Bound</link>.</para>
		</section>

		<section id="contents">
			<title>contents</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>23</td> </tr>
			</informaltable>

			<programlisting language="tdf">s:    SHAPE
arg1: EXP POINTER(x)
 -&gt; EXP s</programlisting>

			<para>A value of <code>SHAPE</code> <replaceable>s</replaceable> will be extracted
				from the start of the space indicated by the pointer, and this is
				delivered.</para>

			<para><replaceable>x</replaceable> will include
				<replaceable>alignment</replaceable>(<replaceable>s</replaceable>).</para>

			<para><replaceable>s</replaceable> will not be a <code>BITFIELD</code>.</para>

			<para>If the space which the pointer indicates does not lie wholly within the
				space indicated by the original pointer from which it is derived, the
				effect is undefined.</para>

			<para>If the value delivered by <replaceable>arg1</replaceable> is a null pointer
				the effect is undefined.</para>

			<para>The constraint &ldquo;x will include alignment(s)&rdquo;
				ensures in the simple memory model that no change is needed to the
				<code>POINTER</code>.
			</para>
		</section>

		<section id="contents_with_mode">
			<title>contents_with_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>24</td> </tr>
			</informaltable>

			<programlisting language="tdf">md:   TRANSFER_MODE
s:    SHAPE
arg1: EXP POINTER(x)
 -&gt; EXP s</programlisting>

			<para>A value of <code>SHAPE</code> <replaceable>s</replaceable> will be extracted
				from the start of the space indicated by the pointer, and this is
				delivered. The operation will be carried out as specified by the
				<code>TRANSFER_MODE</code> (q.v.).</para>

			<para>If <replaceable>md</replaceable> consists of
				<replaceable>standard_transfer_mode</replaceable> only, then
				<replaceable>contents_with_mode</replaceable> is the same as
				<replaceable>contents</replaceable>.</para>

			<para><replaceable>x</replaceable> will include
				<replaceable>alignment</replaceable>(<replaceable>s</replaceable>).</para>

			<para><replaceable>s</replaceable> will not be a <code>BITFIELD</code>.</para>

			<para>If the space which the pointer indicates does not lie wholly within the
				space indicated by the original pointer from which it is derived, the
				effect is undefined.</para>

			<para>If the value delivered by <replaceable>arg1</replaceable> is a null pointer
				the effect is undefined.</para>
		</section>

		<section id="current_env">
			<title>current_env</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>25</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; EXP POINTER(fa)</programlisting>

			<para>A value of <code>SHAPE POINTER</code>(<replaceable>fa</replaceable>) is
				created and delivered.	It gives access to the variables, identities and
				parameters in the current procedure activation which are declared as
				having <code>ACCESS</code> <replaceable>visible</replaceable>.</para>

			<para>If the immediately enclosing procedure is defined by
				<replaceable>make_general_proc</replaceable>, then <replaceable>fa</replaceable> is
				the set union of <replaceable>local_alignment</replaceable> and the alignments
				of the kinds of parameters defined. That is to say, if there are caller
				parameters, then the alignment includes
				<replaceable>callers_alignment</replaceable>(<replaceable>x</replaceable>) where
				<replaceable>x</replaceable> is true if and only if the <code>PROCPROPS</code>
				<replaceable>var_callers</replaceable> is present; if there are callee
				parameters, the alignment includes
				<replaceable>callees_alignment</replaceable>(<replaceable>x</replaceable>) where
				<replaceable>x</replaceable> is true if and only if the <code>PROCPROPS</code>
				<replaceable>var_callees</replaceable> is present.</para>

			<para>If the immediately enclosing procedure is defined by
				<replaceable>make_proc</replaceable>, then <replaceable>fa</replaceable> = {
				<replaceable>locals_alignment</replaceable>,
				<replaceable>callers_alignment</replaceable>(<replaceable>false</replaceable>) }.</para>

			<para>If an <code>OFFSET</code> produced by <replaceable>env_offset</replaceable> is
				added to a <code>POINTER</code> produced by
				<replaceable>current_env</replaceable> from an activation of the procedure
				which contains the declaration of the <code>TAG</code> used by
				<replaceable>env_offset</replaceable>, then the result is an original
				<code>POINTER</code>, notwithstanding the normal rules for
				<replaceable>add_to_ptr</replaceable> (see <link linkend="original-pointers">Original
				pointers</link>).</para>

			<para>If an <code>OFFSET</code> produced by env_offset is added to such a
				pointer from an inappropriate procedure the effect is undefined.</para>
		</section>

		<section id="div0">
			<title>div0</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>26</td> </tr>
			</informaltable>

			<programlisting language="tdf">div_by_0_err: ERROR_TREATMENT
ov_err:       ERROR_TREATMENT
arg1:         EXP INTEGER(v)
arg2:         EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. Either the value <replaceable>a</replaceable> D1
				<replaceable>b</replaceable> or the value <replaceable>a</replaceable> D2
				<replaceable>b</replaceable> is delivered as the result of the construct, with
				the same <code>SHAPE</code> as the arguments. Different occurrences of
				<replaceable>div0</replaceable> in the same capsule can use D1 or D2
				independently.</para>

			<para>If <replaceable>b</replaceable> is zero a div_by_zero error occurs and is
				handled by <replaceable>div_by_0_err</replaceable>.</para>

			<para>If <replaceable>b</replaceable> is not zero and the result cannot be expressed
				in the <code>VARIETY</code> being used to represent
				<replaceable>v</replaceable> an overflow occurs and is handled by
				<replaceable>ov_err</replaceable>.</para>

			<para>Producers may assume that shifting and <replaceable>div0</replaceable> by a
				constant which is a power of two yield equally good code.</para>

			<para>See <link linkend="division-and-modulus">Division and modulus</link> for the definitions
				of D1, D2, M1 and M2.</para>
		</section>

		<section id="div1">
			<title>div1</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>27</td> </tr>
			</informaltable>

			<programlisting language="tdf">div_by_0_err: ERROR_TREATMENT
ov_err:       ERROR_TREATMENT
arg1:         EXP INTEGER(v)
arg2:         EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The value <replaceable>a</replaceable> D1
				<replaceable>b</replaceable> is delivered as the result of the construct, with
				the same <code>SHAPE</code> as the arguments.</para>

			<para>If <replaceable>b</replaceable> is zero a div_by_zero error occurs and is
				handled by <replaceable>div_by_0_err</replaceable>.</para>

			<para>If <replaceable>b</replaceable> is not zero and the result cannot be expressed
				in the <code>VARIETY</code> being used to represent
				<replaceable>v</replaceable> an overflow occurs and is handled by
				<replaceable>ov_err</replaceable>.</para>

			<para>Producers may assume that shifting and <replaceable>div1</replaceable> by a
				constant which is a power of two yield equally good code.</para>

			<para>See <link linkend="division-and-modulus">Division and modulus</link> for the definitions
				of D1, D2, M1 and M2.</para>
		</section>

		<section id="div2">
			<title>div2</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>28</td> </tr>
			</informaltable>

			<programlisting language="tdf">div_by_0_err: ERROR_TREATMENT
ov_err:       ERROR_TREATMENT
arg1:         EXP INTEGER(v)
arg2:         EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The value <replaceable>a</replaceable> D2
				<replaceable>b</replaceable> is delivered as the result of the construct, with
				the same <code>SHAPE</code> as the arguments.</para>

			<para>If <replaceable>b</replaceable> is zero a div_by_zero error occurs and is
				handled by <replaceable>div_by_0_err</replaceable>.</para>

			<para>If <replaceable>b</replaceable> is not zero and the result cannot be expressed
				in the <code>VARIETY</code> being used to represent
				<replaceable>v</replaceable> an overflow occurs and is handled by
				<replaceable>ov_err</replaceable>.</para>

			<para>Producers may assume that shifting and <replaceable>div2</replaceable> by a
				constant which is a power of two yield equally good code if the lower
				bound of <replaceable>v</replaceable> is zero.</para>

			<para>See <link linkend="division-and-modulus">Division and modulus</link> for the definitions
				of D1, D2, M1 and M2.</para>
		</section>

		<section id="env_offset">
			<title>env_offset</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>29</td> </tr>
			</informaltable>

			<programlisting language="tdf">fa: ALIGNMENT
y:  ALIGNMENT
t:  TAG x
 -&gt; EXP OFFSET(fa, y)</programlisting>

			<para><replaceable>t</replaceable> will be the tag of a
				<replaceable>variable</replaceable>, <replaceable>identify</replaceable> or
				procedure parameter with the <replaceable>visible</replaceable> property
				within a procedure defined by <replaceable>make_general_proc</replaceable> or
				<replaceable>make_proc</replaceable>.</para>

			<para>If it is defined in a make_general_proc, let P be its associated
				<code>PROCPROPS</code>; otherwise let P be the <code>PROCPROPS</code>
				{<replaceable>locals_alignment</replaceable>,
				<replaceable>caller_alignment</replaceable>(<replaceable>false</replaceable>)}.</para>

			<para>If <replaceable>t</replaceable> is the <code>TAG</code> of a
				<replaceable>variable</replaceable> or <replaceable>identify, fa</replaceable> will
				contain <replaceable>locals_alignment</replaceable>; if it is a caller
				parameter <replaceable>fa</replaceable> will contain a
				<replaceable>caller_alignment</replaceable>(<replaceable>b</replaceable>) where
				<replaceable>b </replaceable>is true if and only if P contains
				<replaceable>var_callers</replaceable> ; if it is a callee parameter
				<replaceable>fa</replaceable> will contain a
				<replaceable>callee_alignment</replaceable>(<replaceable>b</replaceable>) where
				<replaceable>b</replaceable> is true if and only if P contains
				<replaceable>var_callees</replaceable>.</para>

			<para>If t is the <code>TAG</code> of a <replaceable>variable</replaceable> or
				parameter, the result is the <code>OFFSET</code> of its position, within
				any procedure environment which derives from the procedure containing
				the declaration of the variable or parameter, relative to its
				environment pointer. In this case <replaceable>x</replaceable> will be
				<code>POINTER</code>(<replaceable>y).</replaceable>
			</para>

			<para>If t is the <code>TAG</code> of an <replaceable>identify</replaceable>, the
				result will be an <code>OFFSET</code> of space which holds the value.
				This pointer will not be used to alter the value. In this case
				<replaceable>y</replaceable> will be
				<replaceable>alignment</replaceable>(<replaceable>x</replaceable>).</para>

			<para>See <link linkend="frames">section 7.10</link>.</para>
		</section>

		<section id="env_size">
			<title>env_size</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>30</td> </tr>
			</informaltable>

			<programlisting language="tdf">proctag: TAG PROC
 -&gt; EXP OFFSET(locals_alignment, {})</programlisting>

			<para>Delivers an <code>OFFSET</code> of a space sufficient to contain all the
				variables and identifications, explicit or implicit in the procedure
				identified by <replaceable>proctag</replaceable>. This will not include the
				space required for any <replaceable>local_allocs</replaceable> or procedure
				calls within the procedure.</para>

			<para><replaceable>proctag</replaceable> will be defined in the current
				<code>CAPSULE</code> by a <code>TAGDEF</code> identification of a
				<replaceable>make_proc</replaceable> or a
				<replaceable>make_general_proc</replaceable>.</para>
		</section>

		<section id="fail_installer">
			<title>fail_installer</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>31</td> </tr>
			</informaltable>

			<programlisting language="tdf">message: STRING(k, n)
 -&gt; EXP BOTTOM</programlisting>

			<para>Any attempt to use this operation to produce code will result in a
				failure of the installation process. <replaceable>message</replaceable> will
				give information about the reason for this failure which should be
				passed to the installation manager.</para>
		</section>

		<section id="float_int">
			<title>float_int</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>32</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
f:        FLOATING_VARIETY
arg1:     EXP INTEGER(v)
 -&gt; EXP FLOATING(f)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated to produce an integer value,
				which is converted to the representation of <replaceable>f</replaceable> and
				delivered.</para>

			<para>If <replaceable>f</replaceable> is complex the real part of the result will be
				derived from <replaceable>arg1</replaceable> and the imaginary part will be
				zero.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>. See <link linkend="float-errors">Floating point
				errors</link>.</para>
		</section>

		<section id="floating_abs">
			<title>floating_abs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>33</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     EXP FLOATING(f)
 -&gt; EXP FLOATING(f)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and will produce a floating point
				value, <replaceable>a</replaceable>, of the <code>FLOATING_VARIETY</code>,
				<replaceable>f</replaceable>. The absolute value of <replaceable>a</replaceable> is
				delivered as the result of the construct, with the same
				<code>SHAPE</code> as the argument.</para>

			<para>Though <replaceable>floating_abs</replaceable> cannot produce an overflow it
				can give an invalid operand exception which is handled by
				<replaceable>flpt_err</replaceable>.</para>

			<para><replaceable>f</replaceable> will not be complex.</para>

			<para>See also <link linkend="float-accuracy">Floating point accuracy</link>.</para>
		</section>

		<section id="floating_div">
			<title>floating_div</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>34</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     EXP FLOATING(f)
arg2:     EXP FLOATING(f)
 -&gt; EXP FLOATING(f)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce floating point values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>FLOATING_VARIETY</code>,
				<replaceable>f</replaceable>. The value
				<replaceable>a</replaceable>/<replaceable>b</replaceable> is delivered as the result
				of the construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>. See <link linkend="float-errors">Floating point
				errors</link>.</para>

			<para>See also <link linkend="float-accuracy">Floating point accuracy</link>.</para>
		</section>

		<section id="floating_minus">
			<title>floating_minus</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>35</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     EXP FLOATING(f)
arg2:     EXP FLOATING(f)
 -&gt; EXP FLOATING(f)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce floating point values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>FLOATING_VARIETY</code>,
				<replaceable>f</replaceable>. The value
				<replaceable>a</replaceable>-<replaceable>b</replaceable> is delivered as the result
				of the construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>. See <link linkend="float-errors">Floating point
				errors</link>.</para>

			<para>See also <link linkend="float-accuracy">Floating point accuracy</link>.</para>
		</section>

		<section id="floating_maximum">
			<title>floating_maximum</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>36</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     EXP FLOATING(f)
arg2:     EXP FLOATING(f)
 -&gt; EXP FLOATING(f)</programlisting>

			<para>The maximum of the values delivered by <replaceable>arg1</replaceable> and
				<replaceable>arg2</replaceable> is the result. <replaceable>f</replaceable> will not
				be complex.</para>

			<para>If <replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are
				incomparable, <replaceable>flpt_err</replaceable> will be invoked.</para>

			<para>See also <link linkend="float-accuracy">Floating
				point accuracy</link>.</para>
		</section>

		<section id="floating_minimum">
			<title>floating_minimum</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>37</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     EXP FLOATING(f)
arg2:     EXP FLOATING(f)
 -&gt; EXP FLOATING(f)</programlisting>

			<para>The minimum of the values delivered by <replaceable>arg1</replaceable> and
				<replaceable>arg2</replaceable> is the result. <replaceable>f</replaceable> will not
				be complex.</para>

			<para>If <replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are
				incomparable, <replaceable>flpt_err</replaceable> will be invoked.</para>

			<para>See also <link linkend="float-accuracy">Floating
				point accuracy</link>.</para>
		</section>

		<section id="floating_mult">
			<title>floating_mult</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>38</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     LIST(EXP)
 -&gt; EXP FLOATING(f)</programlisting>

			<para>The arguments, <replaceable>arg1</replaceable>, are evaluated producing
				floating point values all of the same <code>FLOATING_VARIETY</code>,
				<replaceable>f</replaceable>. These values are multiplied in any order and the
				result of this multiplication is delivered as the result of the
				construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>. See <link linkend="float-errors">Floating point
				errors</link>.</para>

			<para>Note that separate floating_mult operations cannot in general
				be combined, because rounding errors need to be controlled.	The reason
				for allowing floating_mult to take a variable number of arguments is to
				make it possible to specify that a number of multiplications can be
				re-ordered.
			</para>

			<para>If <replaceable>arg1</replaceable> contains one element the result is the
				value of that element. There will be at least one element in
				<replaceable>arg1</replaceable>.</para>

			<para>See also <link linkend="float-accuracy">Floating
				point accuracy</link>.</para>
		</section>

		<section id="floating_negate">
			<title>floating_negate</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>39</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     EXP FLOATING(f)
 -&gt; EXP FLOATING(f)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and will produce a floating point
				value, <replaceable>a</replaceable>, of the <code>FLOATING_VARIETY</code>,
				<replaceable>f</replaceable>. The value -<replaceable>a</replaceable> is delivered
				as the result of the construct, with the same <code>SHAPE</code> as the
				argument.</para>

			<para>Though <replaceable>floating_negate</replaceable> cannot produce an overflow
				it can give an invalid operand exception which is handled by
				<replaceable>flpt_err</replaceable>.</para>

			<para>See also <link linkend="float-accuracy">Floating
				point accuracy</link>.</para>
		</section>

		<section id="floating_plus">
			<title>floating_plus</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>40</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     LIST(EXP)
 -&gt; EXP FLOATING(f)</programlisting>

			<para>The arguments, <replaceable>arg1</replaceable>, are evaluated producing
				floating point values, all of the same <code>FLOATING_VARIETY</code>,
				<replaceable>f</replaceable>. These values are added in any order and the
				result of this addition is delivered as the result of the construct,
				with the same <code>SHAPE</code> as the arguments.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>.	See <link linkend="float-errors">Floating point
				errors</link>.</para>

			<para>Note that separate floating_plus operations cannot in general
				be combined, because rounding errors need to be controlled.	The reason
				for allowing floating_plus to take a variable number of arguments is to
				make it possible to specify that a number of multiplications can be
				re-ordered.
			</para>

			<para>If <replaceable>arg1</replaceable> contains one element the result is the
				value of that element. There will be at least one element in
				<replaceable>arg1</replaceable>.</para>

			<para>See also <link linkend="float-accuracy">Floating
				point accuracy</link>.</para>
		</section>

		<section id="floating_power">
			<title>floating_power</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>41</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
arg1:     EXP FLOATING(f)
arg2:     EXP INTEGER(v)
 -&gt; EXP FLOATING(f)</programlisting>

			<para>The result of <replaceable>arg1</replaceable> is raised to the power given by
				<replaceable>arg2</replaceable>.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>.	See <link linkend="float-errors">Floating point
				errors</link>.</para>

			<para>See also <link linkend="float-accuracy">Floating
				point accuracy</link>.</para>
		</section>

		<section id="floating_test">
			<title>floating_test</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>42</td> </tr>
			</informaltable>

			<programlisting language="tdf">prob:     OPTION(NAT)
flpt_err: ERROR_TREATMENT
nt:       NTEST
dest:     LABEL
arg1:     EXP FLOATING(f)
arg2:     EXP FLOATING(f)
 -&gt; EXP TOP</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce floating point values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>FLOATING_VARIETY</code>,
				<replaceable>f</replaceable>. These values are compared using
				<replaceable>nt</replaceable>.</para>

			<para>If <replaceable>f</replaceable> is complex then <replaceable>nt</replaceable> will
				be <replaceable>equal</replaceable> or <replaceable>not_equal</replaceable>.</para>

			<para>If <replaceable>a nt b</replaceable>, this construction yields
				<code>TOP</code>. Otherwise control passes to <replaceable>dest</replaceable>.</para>

			<para>If <replaceable>prob</replaceable> is present<replaceable>, prob</replaceable>/100
				gives the probability that control will continue to the next construct
				(ie. not pass to <replaceable>dest</replaceable>). If
				<replaceable>prob</replaceable> is absent this probability is unknown.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>.	See <link linkend="float-errors">Floating point
				errors</link>.</para>

			<para>See also <link linkend="float-accuracy">Floating
				point accuracy</link>.</para>
		</section>

		<section id="goto">
			<title>goto</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>43</td> </tr>
			</informaltable>

			<programlisting language="tdf">dest: LABEL
 -&gt; EXP BOTTOM</programlisting>

			<para>Control passes to the <code>EXP</code> labelled
				<replaceable>dest</replaceable>. This construct will only be used where
				<replaceable>dest</replaceable> is in scope.</para>
		</section>

		<section id="goto_local_lv">
			<title>goto_local_lv</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>44</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP POINTER({code})
 -&gt; EXP BOTTOM</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated. The label from which the value
				delivered by <replaceable>arg1</replaceable> was created will be within its
				lifetime and this construction will be obeyed in the same activation of
				the same procedure as the creation of the
				<code>POINTER(</code><replaceable>{code</replaceable><code>})</code> by
				<replaceable>make_local_lv</replaceable>. Control passes to this activation of
				this <code>LABEL</code>.</para>

			<para>If <replaceable>arg1</replaceable> delivers a null <code>POINTER</code> the
				effect is undefined.</para>
		</section>

		<section id="identify">
			<title>identify</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>45</td> </tr>
			</informaltable>

			<programlisting language="tdf">opt_access: OPTION(ACCESS)
name_intro: TAG x
definition: EXP x
body: EXP y
 -&gt; EXP y</programlisting>

			<para><replaceable>definition</replaceable> is evaluated to produce a value,
				<replaceable>v</replaceable>. Then <replaceable>body</replaceable> is evaluated.
				During this evaluation, <replaceable>v</replaceable> is bound to
				<replaceable>name_intro</replaceable>. This means that inside
				<replaceable>body</replaceable> an evaluation of
				<replaceable>obtain_tag</replaceable>(<replaceable>name_intro</replaceable>) will
				produce the value, <replaceable>v</replaceable>.</para>

			<para>The value delivered by <replaceable>identify</replaceable> is that produced by
				<replaceable>body</replaceable>.</para>

			<para>The <code>TAG</code> given for <replaceable>name_intro</replaceable> will not
				be reused within the current <code>UNIT</code>. No rules for the hiding
of one <code>TAG</code> by another are given: this will not happen. The
				lifetime of <replaceable>name_intro</replaceable> is the evaluation of
				<replaceable>body</replaceable>.</para>

			<para>If <replaceable>opt_access</replaceable> contains
				<replaceable>visible</replaceable>, it means that the value must not be
				aliased while the procedure containing this declaration is not the
				current procedure. Hence if there are any copies of this value they will
				need to be refreshed when the procedure is returned to. The easiest
				implementation when <replaceable>opt_access</replaceable> is
				<replaceable>visible</replaceable> may be to keep the value in memory, but
				this is not a necessary requirement.</para>

			<para>The order in which the constituents of <replaceable>definition</replaceable>
				and <replaceable>body</replaceable> are evaluated shall be indistinguishable
				in all observable effects (apart from time) from completely evaluating
				<replaceable>definition</replaceable> before starting
				<replaceable>body</replaceable>. See the note about order in <link linkend="sequence">sequence</link>.</para>
		</section>

		<section id="ignorable">
			<title>ignorable</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>46</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP x
 -&gt; EXP x</programlisting>

			<para>If the result of this construction is discarded,
				<replaceable>arg1</replaceable> need not be evaluated, though evaluation is
				permitted. If the result is used it is the result of
				<replaceable>arg1</replaceable>.</para>
		</section>

		<section id="imaginary_part">
			<title>imaginary_part</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>47</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP c
 -&gt; EXP FLOATING (float_of_complex(c))</programlisting>

			<para><replaceable>c</replaceable> will be complex. Delivers the imaginary part of
				the value produced by <replaceable>arg1</replaceable>.</para>
		</section>

		<section id="initial_value">
			<title>initial_value</title>


			<informaltable>
				<tr> <td>Encoding number</td> <td>48</td> </tr>
			</informaltable>

			<programlisting language="tdf">init: EXP s
 -&gt; EXP s</programlisting>

			<para>Any tag used as an argument of an <replaceable>obtain_tag</replaceable> in
				<replaceable>init</replaceable> will be global or defined within
				<replaceable>init</replaceable>.</para>

			<para>All labels used in <replaceable>init</replaceable> will be defined within
				<replaceable>init</replaceable>.</para>

			<para><replaceable>init</replaceable> will be evaluated once only before any
				procedure application, other than those involved in this or other
				<replaceable>initial_value</replaceable> constructions, but after all
				load-time constant initialisations of TAGDEFs. The result of this
				evaluation is the value of the construction.</para>

			<para>The order of evaluation of the different
				<replaceable>initial_values</replaceable> in a program is undefined.</para>

			<para>See <link linkend="dynamic-initialisation">section 7.29</link>.</para>
		</section>

		<section id="integer_test">
			<title>integer_test</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>49</td> </tr>
			</informaltable>

			<programlisting language="tdf">prob: OPTION(NAT)
nt:   NTEST
dest: LABEL
arg1: EXP INTEGER(v)
arg2: EXP INTEGER(v)
 -&gt; EXP TOP</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>.	These values are compared using
				<replaceable>nt</replaceable>.</para>

			<para>If <replaceable>a nt b</replaceable>, this construction yields
				<code>TOP</code>. Otherwise control passes to <replaceable>dest</replaceable>.</para>

			<para>If <replaceable>prob</replaceable> is present, <replaceable>prob</replaceable>/100
				gives the probability that control will continue to the next construct
				(ie. not pass to <replaceable>dest</replaceable>). If
				<replaceable>prob</replaceable> is absent this probability is unknown.</para>
		</section>

		<section id="labelled">
			<title>labelled</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>50</td> </tr>
			</informaltable>

			<programlisting language="tdf">labs_intro: LIST(LABEL)
starter:    EXP x
places:     LIST(EXP)
 -&gt; EXP w</programlisting>

			<para>The lists <replaceable>labs_intro</replaceable> and
				<replaceable>places</replaceable> shall have the same number of elements.</para>

			<para>To evaluate the construction <replaceable>starter</replaceable> is evaluated.
				If its evaluation runs to completion producing a value, then this is
				delivered as the result of the whole construction. If a
				<replaceable>goto</replaceable> one of the <code>LABEL</code>s in
				<replaceable>labs_intro</replaceable> or any other jump to one of these
				<code>LABEL</code>s is evaluated, then the evaluation of
				<replaceable>starter</replaceable> stops and the corresponding element of
				<replaceable>places</replaceable> is evaluated. In the canonical ordering all
				the operations which are evaluated from <replaceable>starter</replaceable> are
				completed before any from an element of <replaceable>places</replaceable> is
				started. If the evaluation of the member of <replaceable>places</replaceable>
				produces a result this is the result of the construction.</para>

			<para>If a jump to any of the <replaceable>labs_intro</replaceable> is obeyed then
				evaluation continues similarly. Such jumping may continue indefinitely,
				but if any <replaceable>places</replaceable> terminates, then the value it
				produces is the value delivered by the construction.</para>

			<para>The <code>SHAPE</code> <replaceable>w</replaceable> is the LUB of
				<replaceable>x</replaceable> and all the <replaceable>places</replaceable>. See
				<link linkend="least-upper-bound">Least Upper Bound</link>.</para>

			<para>The actual order of evaluation of the constituents shall be
				indistinguishable in all observable effects (apart from time) from that
				described above. Note that this specifically includes any defined error
				handling.</para>

			<para>The lifetime of each of the <code>LABEL</code>s in
				<replaceable>labs_intro</replaceable>, is the evaluation of
				<replaceable>starter</replaceable> and all the elements of
				<replaceable>places</replaceable>.</para>
		</section>

		<section id="last_local">
			<title>last_local</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>51</td> </tr>
			</informaltable>

			<programlisting language="tdf">x: EXP OFFSET(y, z)
 -&gt; EXP POINTER(alloca_alignment)</programlisting>

			<para>If the last use of <replaceable>local_alloc</replaceable> in the current
				activation of the current procedure was after the last use of
				<replaceable>local_free</replaceable> or <replaceable>local_free_all</replaceable>,
				then the value returned is the last <code>POINTER</code> allocated with
				<replaceable>local_alloc</replaceable>.</para>

			<para>If the last use of <replaceable>local_free</replaceable> in the current
				activation of the current procedure was after the last use of
				<replaceable>local_alloc</replaceable>, then the result is the
				<code>POINTER</code> last allocated which is still active.</para>

			<para>The <code>ALIGNMENT</code>, <replaceable>alloca_alignment</replaceable>,
				includes the set union of all the <code>ALIGNMENT</code>s which can be
				produced by <replaceable>alignment</replaceable> from any <code>SHAPE</code>.
				See <link linkend="special-alignments">Special alignments</link>.</para>
		</section>

		<section id="local_alloc">
			<title>local_alloc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>52</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, y)
 -&gt; EXP POINTER(alloca_alignment)</programlisting>

			<para>The <replaceable>arg1</replaceable> expression is evaluated and space is
				allocated sufficient to hold a value of the given size. The result is an
				original pointer to this space.</para>

			<para><replaceable>x</replaceable> will not consist entirely of bitfield alignments.</para>

			<para>The initial contents of the space are not specified.</para>

			<para>This allocation is as if on the stack of the current procedure, and the
				lifetime of the pointer ends when the current activation of the current
				procedure ends with a <replaceable>return</replaceable>,
				<replaceable>return_to_label</replaceable> or <replaceable>tail_call</replaceable>
				or if there is a long jump out of the activation.	Any use of the
				pointer thereafter is undefined. Note the specific exclusion of the
				procedure ending with <replaceable>untidy_return</replaceable>; in this case
				the calling procedure becomes the current activation.</para>

			<para>The uses of <replaceable>local_alloc</replaceable> within the procedure are
				ordered dynamically as they occur, and this order affects the meaning of
				<replaceable>local_free</replaceable> and <replaceable>last_local</replaceable>.</para>

			<para><replaceable>arg1</replaceable> may be a zero <code>OFFSET</code>. In this
				case suppose the result is <replaceable>p</replaceable>. Then a subsequent
				use, in the same activation of the procedure, of</para>

			<para><replaceable>local_free</replaceable>(<replaceable>offset_zero</replaceable>(<replaceable>alloca_alignment</replaceable>),
				<replaceable>p</replaceable>)
			</para>

			<para>will return the <replaceable>alloca</replaceable> stack to the state it was in
				immediately before the use of <replaceable>local_alloc</replaceable>.</para>

			<para>Note that if a procedure which uses <replaceable>local_alloc</replaceable> is
				inlined, it may be necessary to use <replaceable>local_free</replaceable> to
				get the correct semantics.</para>

			<para>See also <link linkend="alloca">section 7.12</link>.</para>
		</section>

		<section id="local_alloc_check">
			<title>local_alloc_check</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>53</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, y)
 -&gt; EXP POINTER(alloca_alignment)</programlisting>

			<para>If the <code>OFFSET</code> <replaceable>arg1</replaceable> can be accomodated
				within the limit of the local_alloc stack (see <link linkend="set_stack_limit">section 5.16.108</link>), the action is precisely
				the same as <replaceable>local_alloc</replaceable>.</para>

			<para>If not, normal action is stopped and a TDF exception is raised with
				ERROR_code <replaceable>stack_overflow</replaceable>.</para>
		</section>

		<section id="local_free">
			<title>local_free</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>54</td> </tr>
			</informaltable>

			<programlisting language="tdf">a: EXP OFFSET(x, y)
p: EXP POINTER(alloca_alignment)
 -&gt; EXP TOP</programlisting>

			<para>The <code>POINTER</code>, <replaceable>p</replaceable>, will be an original
				pointer to space allocated by <replaceable>local_alloc</replaceable> within
				the current call of the current procedure. It and all spaces allocated
				after it by <replaceable>local_alloc</replaceable> will no longer be used.
				This <code>POINTER</code> will have been created by
				<replaceable>local_alloc</replaceable> with the value of its
				<replaceable>arg1</replaceable> equal to the value of <replaceable>a</replaceable>.</para>

			<para>Any subsequent use of pointers to the spaces no longer used will be
				undefined.</para>
		</section>

		<section id="local_free_all">
			<title>local_free_all</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>55</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; EXP TOP</programlisting>

			<para>Every space allocated by <replaceable>local_alloc</replaceable> within the
				current call of the current procedure will no longer be used.</para>

			<para>Any use of a pointer to space allocated before this operation within the
				current call of the current procedure is undefined.</para>

			<para>Note that if a procedure which uses <replaceable>local_free_all</replaceable>
				is inlined, it may be necessary to use <replaceable>local_free</replaceable>
				to get the correct semantics.</para>
		</section>

		<section id="long_jump">
			<title>long_jump</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>56</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP POINTER(fa)
arg2: EXP POINTER({code})
 -&gt; EXP BOTTOM</programlisting>

			<para><replaceable>arg1</replaceable> will be a pointer produced by an application
				of <replaceable>curent_env</replaceable> in a currently active procedure.</para>

			<para>The frame produced by <replaceable>arg1</replaceable> is reinstated as the
				current procedure. This frame will still be active. Evaluation
				recommences at the label given by <replaceable>arg2</replaceable>. This
				operation will only be used during the lifetime of that label.</para>

			<para>Only <code>TAG</code>s declared to have
				<replaceable>long_jump_access</replaceable> will be defined at the re-entry.</para>

			<para>If <replaceable>arg2</replaceable> delivers a null
				<code>POINTER(</code>{<replaceable>code</replaceable><code>})</code> the
				effect is undefined.</para>
		</section>

		<section id="make_complex">
			<title>make_complex</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>57</td> </tr>
			</informaltable>

			<programlisting language="tdf">c:    FLOATING_VARIETY
arg1: EXP FLOATING(f)
arg2: EXP FLOATING(f)
 -&gt; EXP FLOATING(c)</programlisting>

			<para><replaceable>c</replaceable> will be complex and derived from the same
				parameters as <replaceable>f</replaceable>.</para>

			<para>Delivers a complex number with <replaceable>arg1</replaceable> delivering the
				real part and <replaceable>arg2</replaceable> the imaginary.</para>
		</section>

		<section id="make_compound">
			<title>make_compound</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>58</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(base, y)
arg2: LIST(EXP)
 -&gt; EXP COMPOUND(arg1)</programlisting>

			<para>Let the <replaceable>i</replaceable>th component (<replaceable>i</replaceable>
				starts at one) of <replaceable>arg2</replaceable> be
				<replaceable>x</replaceable>[<replaceable>i</replaceable>]. The list may be empty.</para>

			<para>The components <replaceable>x</replaceable>[2 * <replaceable>k</replaceable>] are
				values which are to be placed at <code>OFFSET</code>s given by
				<replaceable>x</replaceable>[2 * <replaceable>k</replaceable> - 1]. These
				<code>OFFSET</code>s will be constants and non-negative.</para>

			<para>The <code>OFFSET</code> <replaceable>x</replaceable>[2 *
				<replaceable>k</replaceable> - 1] will have the <code>SHAPE</code>
				<code>OFFSET</code>(<replaceable>z</replaceable><replaceable>k</replaceable>,
				<replaceable>alignment</replaceable>(<replaceable>shape</replaceable>(<replaceable>x</replaceable>[2
				* <replaceable>k</replaceable>]))), where
				<replaceable>shape</replaceable> gives the <code>SHAPE</code> of the component
				and <replaceable>base</replaceable> includes
				<replaceable>z</replaceable><replaceable>k</replaceable>.</para>

			<para><replaceable>arg1</replaceable> will be a constant non-negative
				<code>OFFSET</code>, see <link linkend="offset_pad">offset_pad</link>.</para>

			<para>The values <replaceable>x</replaceable>[2 * <replaceable>k</replaceable> - 1] will
				be such that the components when in place either do not overlap or
				exactly coincide, in the sense that the <code>OFFSET</code>s are equal
				and the values have the same <code>SHAPE</code>. If they coincide the
				corresponding values <replaceable>x</replaceable>[2 * <replaceable>k</replaceable>]
				will have <code>VARIETY SHAPE</code>s and will be
				<replaceable>ored</replaceable> together.</para>

			<para>The <code>SHAPE</code> of a <replaceable>x</replaceable>[2 *
				<replaceable>k</replaceable>] component can be <code>TOP</code>. In this case
				the component is evaluated, but no value is placed at the corresponding
				<code>OFFSET</code>.</para>

			<para>If <replaceable>x[2 * k]</replaceable> is a <code>BITFIELD</code> then
				<replaceable>x[2 * k - 1]</replaceable>, <replaceable>shape(x[2 * k])</replaceable>
				will be <replaceable>variety-enclosed</replaceable> (see <link linkend="representing-bitfields">section 7.24</link>).</para>
		</section>

		<section id="make_floating">
			<title>make_floating</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>59</td> </tr>
			</informaltable>

			<programlisting language="tdf">f:        FLOATING_VARIETY
rm:       ROUNDING_MODE
negative: BOOL
mantissa: STRING(k, n)
base:     NAT
exponent: SIGNED_NAT
 -&gt; EXP FLOATING(f)</programlisting>

			<para><replaceable>f</replaceable> will not be complex.</para>

			<para><replaceable>mantissa</replaceable> will be a <code>STRING</code> of 8-bit
				integers, each of which is either	46 or is greater than or equal to 48.
				Those values, <replaceable>c</replaceable>, which lie between 48 and 63 will
				represent the digit <replaceable>c</replaceable>-48.	A decimal point is
				represented by 46.</para>

			<para>The <code>BOOL</code> <replaceable>negative</replaceable> determines the sign
				of the result, if true the result will be negative, if false, positive.</para>

			<para>A floating point number, <replaceable>mantissa</replaceable>*(<replaceable>
				base</replaceable><superscript><replaceable>exponent</replaceable></superscript>)
				 is created and rounded to the representation of
				<replaceable>f</replaceable> as specified by <replaceable>rm</replaceable>.
				<replaceable>rm</replaceable> will not be <replaceable>round_as_state</replaceable>.
				<replaceable>mantissa</replaceable> is read as a sequence of digits to base
				<replaceable>base</replaceable> and may contain one point symbol.</para>

			<para><replaceable>base</replaceable> will be one of the numbers 2, 4, 8, 10, 16.
				Note that in base 16 the digit 10 is represented by the character number
				58 etc.</para>

			<para>The result will lie in <replaceable>f</replaceable>.</para>
		</section>

		<section id="make_general_proc">
			<title>make_general_proc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>60</td> </tr>
			</informaltable>

			<programlisting language="tdf">result_shape: SHAPE
prcprops:     OPTION(PROCPROPS)
caller_intro: LIST(TAGSHACC)
callee_intro: LIST(TAGSHACC)
body:         EXP BOTTOM
 -&gt; EXP PROC</programlisting>

			<para>Evaluation of <replaceable>make_general_proc</replaceable> delivers a
				<code>PROC</code>. When this procedure is applied to parameters using
				<replaceable>apply_general_proc</replaceable>, space is allocated to hold the
				actual values of the parameters <replaceable>caller_intro </replaceable> and
				<replaceable>callee_intro</replaceable>. The values produced by the actual
				parameters are used to initialise these spaces. Then
				<replaceable>body</replaceable> is evaluated. During this evaluation the
				<code>TAG</code>s in <replaceable>caller_intro</replaceable> and
				<replaceable>callee_intro</replaceable> are bound to original
				<code>POINTER</code>s to these spaces. The lifetime of these
				<code>TAG</code>s is the evaluation of <replaceable>body</replaceable>.</para>

			<para>The <code>SHAPE</code> of <replaceable>body</replaceable> will be
				<code>BOTTOM</code>.	<replaceable>caller_intro</replaceable> and
				<replaceable>callee_intro</replaceable> may be empty.</para>

			<para>The <code>TAG</code>s introduced in the parameters will not be reused
				within the current <code>UNIT</code>.</para>

			<para>The <code>SHAPE</code>s in the parameters specify the <code>SHAPE</code>
				of the corresponding <code>TAG</code>s.</para>

			<para>The <code>OPTION(ACCESS)</code> (in <replaceable>params_intro</replaceable>)
				specifies the <code>ACCESS</code> properties of the corresponding
				parameter, just as for a variable declaration.</para>

			<para>In <replaceable>body</replaceable> the only <code>TAG</code>s which may be
				used as an argument of <replaceable>obtain_tag</replaceable> are those which
				are declared by <replaceable>identify</replaceable> or
				<replaceable>variable</replaceable> constructions in <replaceable>body</replaceable>
				and which are in scope, or <code>TAG</code>s which are declared by
				<replaceable>make_id_tagdef</replaceable>,
				<replaceable>make_var_tagdef</replaceable> or
				<replaceable>common_tagdef</replaceable> or are in
				<replaceable>caller_intro</replaceable> or <replaceable>callee_intro</replaceable>.
				If a <replaceable>make_proc</replaceable> occurs in <replaceable>body</replaceable>
				its <code>TAG</code>s are not in scope.</para>

			<para>The argument of every <replaceable>return</replaceable> or
				<replaceable>untidy_return</replaceable> construction in
				<replaceable>body</replaceable> will have <code>SHAPE</code>
				<replaceable>result_shape</replaceable>. Every
				<replaceable>apply_general_proc</replaceable> using the procedure will specify
				the <code>SHAPE</code> of its result to be
				<replaceable>result_shape</replaceable>.</para>

			<para>The presence or absence of each of the <code>PROCPROPS</code>
				<replaceable>var_callers</replaceable>, <replaceable>var_callees,
				check_stack</replaceable> and <replaceable>untidy</replaceable> in
				<replaceable>prcprops</replaceable> will be reflected in every
				<replaceable>apply_general_proc</replaceable> or
				<replaceable>tail_call</replaceable> on this procedure.</para>

			<para>The definition of the canonical ordering of the evaluation of
				<replaceable>apply_general_proc</replaceable> gives the definition of these
				<code>PROCPROPS</code>.</para>

			<para>If <replaceable>prcprocs</replaceable> contains
				<replaceable>check_stack</replaceable>, a TDF exception will be raised if the
				static space required for the procedure call (in the sense of
				<replaceable>env_size</replaceable>) would exceed the limit given by
				<replaceable>set_stack_limit</replaceable>.</para>

			<para>If <replaceable>prcprops</replaceable> contains
				<replaceable>no_long_jump_dest</replaceable>, the body of the procedure will
				never contain the destination label of a <replaceable>long_jump</replaceable>.</para>

			<para>For notes on the intended implementation of procedures see <link linkend="procedures">section 7.9</link>.</para>
		</section>

		<section id="make_int">
			<title>make_int</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>61</td> </tr>
			</informaltable>

			<programlisting language="tdf">v:     VARIETY
value: SIGNED_NAT
 -&gt; EXP INTEGER(v)</programlisting>

			<para>An integer value is delivered of which the value is given by
				<replaceable>value</replaceable>, and the <code>VARIETY</code> by
				<replaceable>v</replaceable>. The <code>SIGNED_NAT</code>
				<replaceable>value</replaceable> will lie between the bounds of
				<replaceable>v</replaceable>.</para>
		</section>

		<section id="make_local_lv">
			<title>make_local_lv</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>62</td> </tr>
			</informaltable>

			<programlisting language="tdf">lab: LABEL
 -&gt; EXP POINTER({code})</programlisting>

			<para>A <code>POINTER(</code><replaceable>{code</replaceable><code>})</code>
				<replaceable>lv</replaceable> is created and delivered. It can be used as an
				argument to <replaceable>goto_local_lv</replaceable> or
				<replaceable>long_jump</replaceable>. If and when one of these is evaluated
				with <replaceable>lv</replaceable> as an argument, control will pass to
				<replaceable>lab</replaceable>.</para>
		</section>

		<section id="make_nof">
			<title>make_nof</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>63</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: LIST(EXP)
 -&gt; EXP NOF(n, s)</programlisting>

			<para>Creates an array of <replaceable>n</replaceable> values of <code>SHAPE</code>
				<replaceable>s</replaceable>, containing the given values produced by
				evaluating the members of <replaceable>arg1</replaceable> in the same order as
				they occur in the list.</para>

			<para><replaceable>n</replaceable> will not be zero.</para>
		</section>

		<section id="make_nof_int">
			<title>make_nof_int</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>64</td> </tr>
			</informaltable>

			<programlisting language="tdf">v:   VARIETY
str: STRING(k, n)
 -&gt; EXP NOF(n, INTEGER(v))</programlisting>

			<para>An <code>NOF INTEGER</code> is delivered. The conversions are carried
				out as if the elements of <replaceable>str</replaceable> were
				<code>INTEGER</code>(<replaceable>var_limits</replaceable>(0,
				2<superscript><replaceable>k</replaceable></superscript>-1)).
				<replaceable>n</replaceable> may be zero.</para>
		</section>

		<section id="make_null_local_lv">
			<title>make_null_local_lv</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>65</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; EXP POINTER({code})</programlisting>

			<para>Makes a null <code>POINTER</code>({<replaceable>code</replaceable>}) which can
				be detected by <replaceable>pointer_test</replaceable>. The effect of
				<replaceable>goto_local_lv</replaceable> or <replaceable>long_jump</replaceable>
				applied to this value is undefined.</para>

			<para>All null <code>POINTER</code>({<replaceable>code</replaceable>}) are equal to
				each other and unequal to any other <code>POINTER</code>s.</para>
		</section>

		<section id="make_null_proc">
			<title>make_null_proc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>66</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; EXP PROC</programlisting>

			<para>A null <code>PROC</code> is created and delivered. The null
				<code>PROC</code> may be tested for by using
				<replaceable>proc_test</replaceable>. The effect of using it as the first
				argument of <replaceable>apply_proc</replaceable> is undefined.</para>

			<para>All null <code>PROC</code> are equal to each other and unequal to any
				other <code>PROC</code>.</para>
		</section>

		<section id="make_null_ptr">
			<title>make_null_ptr</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>67</td> </tr>
			</informaltable>

			<programlisting language="tdf">a: ALIGNMENT
 -&gt; EXP POINTER(a)</programlisting>

			<para>A null <code>POINTER</code>(<replaceable>a</replaceable>) is created and
				delivered. The null <code>POINTER</code> may be tested for by
				<replaceable>pointer_test</replaceable>.</para>

			<para><replaceable>a</replaceable> will not include <replaceable>code</replaceable>.</para>

			<para>All null <code>POINTER</code>(<replaceable>x</replaceable>) are equal to each
				other and unequal to any other
				<code>POINTER</code>(<replaceable>x</replaceable>).</para>
		</section>

		<section id="make_proc">
			<title>make_proc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>68</td> </tr>
			</informaltable>

			<programlisting language="tdf">result_shape: SHAPE
params_intro: LIST(TAGSHACC)
var_intro:    OPTION(TAGACC)
body:         EXP BOTTOM
 -&gt; EXP PROC</programlisting>

			<para>Evaluation of <replaceable>make_proc</replaceable> delivers a
				<code>PROC</code>. When this procedure is applied to parameters using
				<replaceable>apply_proc</replaceable>, space is allocated to hold the actual
				values of the parameters <replaceable>params_intro</replaceable> and
				<replaceable>var_intro</replaceable> (if present). The values produced by the
				actual parameters are used to initialise these spaces. Then
				<replaceable>body</replaceable> is evaluated. During this evaluation the
				<code>TAG</code>s in <replaceable>params_intro</replaceable> and
				<replaceable>var_intro</replaceable> are bound to original
				<code>POINTER</code>s to these spaces. The lifetime of these
				<code>TAG</code>s is the evaluation of <replaceable>body</replaceable>.</para>

			<para>If <replaceable>var_intro</replaceable> is present, it may be used for one of
				two purposes, with different consequences for corresponding uses of
				<replaceable>apply_proc</replaceable>. See <link linkend="procedures">section
				7.9</link>. The <code>ALIGNMENT</code>,
				<replaceable>var_param_alignment</replaceable>, includes the set union of all
				the <code>ALIGNMENT</code>s which can be produced by
				<replaceable>alignment</replaceable> from any <code>SHAPE</code>. Note that
				<replaceable>var_intro</replaceable> does not contain an <code>ACCESS</code>
				component and so cannot be marked <replaceable>visible</replaceable>. Hence it
				is not a possible argument of <replaceable>env_offset</replaceable>. If
				present, <replaceable>var_intro</replaceable> is an original pointer.</para>

			<para>The <code>SHAPE</code> of <replaceable>body</replaceable> will be
				<code>BOTTOM</code>. <replaceable>params_intro</replaceable> may be empty.</para>

			<para>The <code>TAG</code>s introduced in the parameters will not be reused
				within the current <code>UNIT</code>.</para>

			<para>The <code>SHAPE</code>s in the parameters specify the <code>SHAPE</code>
				of the corresponding <code>TAG</code>s.</para>

			<para>The <code>OPTION(ACCESS</code>) (in <replaceable>params_intro</replaceable>)
				specifies the <code>ACCESS</code> properties of the corresponding
				parameter, just as for a variable declaration.</para>

			<para>In <replaceable>body</replaceable> the only <code>TAG</code>s which may be
				used as an argument of <replaceable>obtain_tag</replaceable> are those which
				are declared by <replaceable>identify</replaceable> or
				<replaceable>variable</replaceable> constructions in <replaceable>body</replaceable>
				and which are in scope, or <code>TAG</code>s which are declared by
				<replaceable>make_id_tagdef</replaceable>,
				<replaceable>make_var_tagdef</replaceable> or
				<replaceable>common_tagdef</replaceable> or are in
				<replaceable>params_intro</replaceable> or <replaceable>var_intro</replaceable>.	If
				a <replaceable>make_proc</replaceable> occurs in <replaceable>body</replaceable> its
				<code>TAG</code>s are not in scope.</para>

			<para>The argument of every <replaceable>return</replaceable> construction in
				<replaceable>body</replaceable> will have <code>SHAPE</code>
				<replaceable>result_shape</replaceable>. Every <replaceable>apply_proc</replaceable>
				using the procedure will specify the <code>SHAPE</code> of it result to
				be <replaceable>result_shape</replaceable>.</para>

			<para>For notes on the intended implementation of procedures see <link linkend="procedures">section 7.9</link>.</para>
		</section>

		<section id="make_stack_limit">
			<title>make_stack_limit</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>116</td> </tr>
			</informaltable>

			<programlisting language="tdf">stack_base: EXP POINTER(fa)
frame_size: EXP OFFSET(locals_alignment, x)
alloc_size: EXP OFFSET(alloca_alignment, y)
 -&gt; EXP POINTER(fb)</programlisting>

			<para>This creates a POINTER suitable for use with
				<replaceable>set_stack_limit</replaceable>.</para>

			<para><replaceable>fa</replaceable> and <replaceable>fb</replaceable> will include
				<replaceable>locals_alignment</replaceable> and, if
				<replaceable>alloc_size</replaceable> is not the zero offset, will also
				contain <replaceable>alloca_alignment</replaceable>.</para>

			<para>The result will be the same as if given by:</para>

			<!-- TODO: ... by what? -->

			<para>Assume <replaceable>stack_base</replaceable> is the current frame-pointer as given by
				<replaceable>current_env</replaceable> in a hypothetical procedure P with
				<replaceable>env_size</replaceable> equal to <replaceable>frame_size</replaceable>
				and which has generated <replaceable>alloc_size</replaceable> by a
				<replaceable>local_alloc</replaceable>. If P then calls Q, the result will be
				the same as that of a <replaceable>current_env</replaceable> performed
				immediately in the body of Q.</para>

			<para>If the following construction isperformed:</para> 

			<programlisting language="tdf">set_stack_limit(make_stack_limit(current_env, F, A))</programlisting> 

			<para>the frame space and local_alloc space that would be available
				for use by this supposed call of Q will not be reused by procedure calls
				with <replaceable>check_stack</replaceable> or uses of
				<replaceable>local_alloc_check</replaceable> after the
				<replaceable>set_stack_limit</replaceable>. Any attempt to do so will raise a
				TDF exception, <replaceable>stack_overflow</replaceable>.</para>
		</section>

		<section id="make_top">
			<title>make_top</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>69</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; EXP TOP</programlisting>

			<para><replaceable>make_top</replaceable> delivers a value of <code>SHAPE TOP</code>
				(i.e. <replaceable>void</replaceable>).</para>
		</section>

		<section id="make_value">
			<title>make_value</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>70</td> </tr>
			</informaltable>

			<programlisting language="tdf">s: SHAPE
 -&gt; EXP s</programlisting>

			<para>This <code>EXP</code> creates some value with the representation of the
				<code>SHAPE</code> <replaceable>s</replaceable>. This value will have the
				correct size, but its representation is not specified. It can be
				assigned, be the result of a <replaceable>contents</replaceable>, a parameter
				or result of a procedure, or the result of any construction (like
				<replaceable>sequence</replaceable>) which delivers the value delivered by an
				internal <code>EXP</code>. But if it is used for arithmetic or as a
				<code>POINTER</code> for taking <replaceable>contents</replaceable> or
				<replaceable>add_to_ptr</replaceable> etc. the effect is undefined.</para>

			<para>Installers will usually be able to implement this operation by producing
				no code.</para>

			<para><replaceable>Note that a floating point NaN is a possible value for this
				purpose.</replaceable>
			</para>

			<para>The <code>SHAPE</code> <replaceable>s</replaceable> will not be
				<code>BOTTOM</code>.</para>
		</section>

		<section id="maximum">
			<title>maximum</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>71</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The arguments will be evaluated and the maximum of the values delivered
				is the result.</para>
		</section>

		<section id="minimum">
			<title>minimum</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>72</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The arguments will be evaluated and the minimum of the values delivered
				is the result.</para>
		</section>

		<section id="minus">
			<title>minus</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>73</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
arg1:   EXP INTEGER(v)
arg2:   EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The difference
				<replaceable>a</replaceable>-<replaceable>b</replaceable> is delivered as the result
				of the construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>If the result cannot be expressed in the <code>VARIETY</code> being used
				to represent <replaceable>v</replaceable>, an overflow error is caused and is
				handled in the way specified by <replaceable>ov_err</replaceable>.</para>
		</section>

		<section id="move_some">
			<title>move_some</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>74</td> </tr>
			</informaltable>

			<programlisting language="tdf">md:   TRANSFER_MODE
arg1: EXP POINTER(x)
arg2: EXP POINTER(y)
arg3: EXP OFFSET(z, t)
 -&gt; EXP TOP</programlisting>

			<para>The arguments are evaluated to produce <replaceable>p1</replaceable>,
				<replaceable>p2</replaceable>, and <replaceable>sz</replaceable> respectively. A
				quantity of data measured by <replaceable>sz</replaceable> in the space
				indicated by <replaceable>p1</replaceable> is moved to the space indicated by
				<replaceable>p2</replaceable>.	The operation will be carried out as specified
				by the <code>TRANSFER_MODE</code> (q.v.).</para>

			<para><replaceable>x</replaceable> will include <replaceable>z</replaceable> and
				<replaceable>y</replaceable> will include <replaceable>z</replaceable>.</para>

			<para><replaceable>sz</replaceable> will be a non-negative <code>OFFSET</code>, see
				<link linkend="offset_pad">offset_pad</link>.</para>

			<para>If the spaces of size <replaceable>sz</replaceable> to which
				<replaceable>p1</replaceable> and <replaceable>p2</replaceable> point do not lie
				entirely within the spaces indicated by the original pointers from which
				they are derived, the effect of the operation is undefined.</para>

			<para>If the value delivered by <replaceable>arg1</replaceable> or
				<replaceable>arg2</replaceable> is a null pointer the effect is undefined.</para>

			<para>See <link linkend="overlapping">Overlapping</link>.</para>
		</section>

		<section id="mult">
			<title>mult</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>75</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
arg1:   EXP INTEGER(v)
arg2:   EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The product
				<replaceable>a</replaceable>*<replaceable>b</replaceable> is delivered as the result
				of the construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>If the result cannot be expressed in the <code>VARIETY</code> being used
				to represent <replaceable>v</replaceable>, an overflow error is caused and is
				handled in the way specified by <replaceable>ov_err</replaceable>.</para>
		</section>

		<section id="n_copies">
			<title>n_copies</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>76</td> </tr>
			</informaltable>

			<programlisting language="tdf">n:    NAT
arg1: EXP x
 -&gt; EXP NOF(n, x)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and an <code>NOF</code> value is
				delivered which contains <replaceable>n</replaceable> copies of this value.
				<replaceable>n</replaceable> can be zero or one or greater.</para>

			<para>Producers are encouraged to use <replaceable>n_copies</replaceable> to
				initialise arrays of known size.</para>
		</section>

		<section id="negate">
			<title>negate</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>78</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
arg1:   EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated and will produce an integer
				value, <replaceable>a</replaceable>. The value -<replaceable>a</replaceable> is
				delivered as the result of the construct, with the same
				<code>SHAPE</code> as the argument.</para>

			<para>If the result cannot be expressed in the <code>VARIETY</code> being used
				to represent <replaceable>v</replaceable>, an overflow error is caused and is
				handled in the way specified by <replaceable>ov_err</replaceable>.</para>
		</section>

		<section id="not">
			<title>not</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>78</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The argument is evaluated producing an integer value, of
				<code>VARIETY</code>, <replaceable>v</replaceable>. The result is the bitwise
				<replaceable>not</replaceable> of this value in the representing
				<code>VARIETY</code>. The result is delivered as the result of the
				construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>See <link linkend="representing-integers">Representing integers</link>.</para>
		</section>

		<section id="obtain_tag">
			<title>obtain_tag</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>79</td> </tr>
			</informaltable>

			<programlisting language="tdf">t: TAG x
 -&gt; EXP x</programlisting>

			<para>The value with which the <code>TAG</code> <replaceable>t</replaceable> is
				bound is delivered. The <code>SHAPE</code> of the result is the
				<code>SHAPE</code> of the value with which the <code>TAG</code> is
				bound.</para>
		</section>

		<section id="offset_add">
			<title>offset_add</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>80</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, y)
arg2: EXP OFFSET(z, t)
 -&gt; EXP OFFSET(x, t)</programlisting>

			<para>The two arguments deliver <code>OFFSET</code>s. The result is the sum of
				these <code>OFFSET</code>s, as an <code>OFFSET</code>.</para>

			<para><replaceable>y</replaceable> will include <replaceable>z</replaceable>.</para>

			<para>The effect of the constraint &ldquo;y will include z&rdquo;
				is that, in the simple representation of pointer arithmetic, this
				operation can be represented by addition. offset_add can lose
				information, so that offset_subtract does not have the usual relation
				with it.
			</para>
		</section>

		<section id="offset_div">
			<title>offset_div</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>81</td> </tr>
			</informaltable>

			<programlisting language="tdf">v:    VARIETY
arg1: EXP OFFSET(x, x)
arg2: EXP OFFSET(x, x)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The two arguments deliver <code>OFFSET</code>s, <replaceable>a</replaceable>
				and <replaceable>b</replaceable>.	The result is <replaceable>a/b</replaceable>, as
				an <code>INTEGER</code> of <code>VARIETY</code>, <replaceable>v</replaceable>.
				Division is interpreted in the same sense (with respect to remainder) as
				in <replaceable>div0</replaceable>.</para>

			<para>The value produced by <replaceable>arg2</replaceable> will be non-zero.</para>
		</section>

		<section id="offset_div_by_int">
			<title>offset_div_by_int</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>82</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, x)
arg2: EXP INTEGER(v)
 -&gt; EXP OFFSET(x, x)</programlisting>

			<para>The result is the <code>OFFSET</code> produced by
				<replaceable>arg1</replaceable> divided by <replaceable>arg2</replaceable>, as an
				<code>OFFSET</code>(<replaceable>x</replaceable>, <replaceable>x</replaceable>).</para>

			<para>The value produced by <replaceable>arg2</replaceable> will be greater than
				zero.</para>

			<para>The following identity will apply for all A and n:</para>

			<para><replaceable>offset_mult</replaceable>(<replaceable>offset_div_by_int</replaceable>(A,
				n), n) = A</para>
		</section>

		<section id="offset_max">
			<title>offset_max</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>83</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, y)
arg2: EXP OFFSET(z, y)
 -&gt; EXP OFFSET(unite_alignments(x, z), y)</programlisting>

			<para>The two arguments deliver <code>OFFSET</code>s. The result is the
				maximum of these <code>OFFSET</code>s, as an <code>OFFSET</code>.</para>

			<para>See <link linkend="pointers-and-offsets">Comparison of pointers and offsets</link>.</para>

			<para>In the simple memory model this operation is represented by
				maximum. The constraint that the second <code>ALIGNMENT</code>
				parameters are both y is to permit the representation of
				<code>OFFSET</code>s in installers by a simple homomorphism.</para>
		</section>

		<section id="offset_mult">
			<title>offset_mult</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>84</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, x)
arg2: EXP INTEGER(v)
 -&gt; EXP OFFSET(x, x)</programlisting>

			<para>The first argument gives an <code>OFFSET</code>,
				<replaceable>off</replaceable>, and the second an integer,
				<replaceable>n</replaceable>. The result is the product of these, as an
				offset.</para>

			<para>The result shall be equal to <replaceable>offset_adding off n</replaceable>
				times to <replaceable>offset_zero</replaceable>(<replaceable>x</replaceable>).</para>
		</section>

		<section id="offset_negate">
			<title>offset_negate</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>85</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, x)
 -&gt; EXP OFFSET(x, x)</programlisting>

			<para>The inverse of the argument is delivered.</para>

			<para>In the simple memory model this can be represented by
				negate.</para>
		</section>

		<section id="offset_pad">
			<title>offset_pad</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>86</td> </tr>
			</informaltable>

			<programlisting language="tdf">a:    ALIGNMENT
arg1: EXP OFFSET(z, t)
 -&gt; EXP OFFSET(unite_alignments(z, a), a)</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated giving <replaceable>off</replaceable>.
				The next greater or equal <code>OFFSET</code> at which a value of
				<code>ALIGNMENT</code> <replaceable>a</replaceable> can be placed is
				delivered. That is, there shall not exist an <code>OFFSET</code> of the
				same <code>SHAPE</code> as the result which is greater than or equal to
				<replaceable>off</replaceable> and less than the result, in the sense of
				<replaceable>offset_test</replaceable>.</para>

			<para><replaceable>off</replaceable> will be a non-negative <code>OFFSET</code>,
				that is it will be greater than or equal to a zero <code>OFFSET</code>
				of the same <code>SHAPE</code> in the sense of
				<replaceable>offset_test</replaceable>.</para>

			<para>In the simple memory model this operation can be represented
				by <replaceable>((off + a - 1) / a) * a</replaceable>.
				In the simple model this is the only
				operation which is not represented by a simple corresponding integer
				operation.</para>
		</section>

		<section id="offset_subtract">
			<title>offset_subtract</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>87</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP OFFSET(x, y)
arg2: EXP OFFSET(x, z)
 -&gt; EXP OFFSET(z, y)</programlisting>

			<para>The two arguments deliver offsets, <replaceable>p</replaceable> and
				<replaceable>q</replaceable>. The result is
				<replaceable>p</replaceable>-<replaceable>q</replaceable>, as an offset.</para>

			<para>Note that <replaceable>x</replaceable> will include <replaceable>y</replaceable>,
				<replaceable>x</replaceable> will include <replaceable>z</replaceable> and
				<replaceable>z</replaceable> will include <replaceable>y</replaceable>, by the
				constraints on <code>OFFSET</code>s.</para>

			<para><replaceable>offset_subtract</replaceable> and <replaceable>offset_add</replaceable>
				do not have the conventional
				relationship because offset_add can lose information, which cannot be
				regenerated by offset_subtract.</para>
		</section>

		<section id="offset_test">
			<title>offset_test</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>88</td> </tr>
			</informaltable>

			<programlisting language="tdf">prob: OPTION(NAT)
nt:   NTEST
dest: LABEL
arg1: EXP OFFSET(x, y)
arg2: EXP OFFSET(x, y)
 -&gt; EXP TOP</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce offset values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>. These values are compared using
				<replaceable>nt</replaceable>.</para>

			<para>If <replaceable>a nt b</replaceable>, this construction yields
				<code>TOP</code>. Otherwise control passes to <replaceable>dest</replaceable>.</para>

			<para>If <replaceable>prob</replaceable> is present, <replaceable>prob</replaceable>/100
				gives the probability that control will continue to the next construct
				(ie. not pass to <replaceable>dest</replaceable>).	If
				<replaceable>prob</replaceable> is absent this probability is unknown.</para>

			<para><replaceable>a greater_than_or_equal b</replaceable> is equivalent to
				<replaceable>offset_max</replaceable>(<replaceable>a</replaceable>,
				<replaceable>b</replaceable>) = <replaceable>a</replaceable>, and similarly for the
				other comparisons.</para>

			<para><replaceable>In the simple memory model this can be represented by
				integer_test.</replaceable></para>
		</section>

		<section id="offset_zero">
			<title>offset_zero</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>89</td> </tr>
			</informaltable>

			<programlisting language="tdf">a: ALIGNMENT
 -&gt; EXP OFFSET(a, a)</programlisting>

			<para>A zero offset of <code>SHAPE OFFSET</code>(<replaceable>a</replaceable>,
				<replaceable>a</replaceable>).</para>

			<para><replaceable>offset_pad</replaceable>(<replaceable>b</replaceable>,
				<replaceable>offset_zero</replaceable>(<replaceable>a</replaceable>)) is a zero
				offset of <code>SHAPE
				OFFSET</code>(<replaceable>unite_alignments</replaceable>(<replaceable>a</replaceable>,
				<replaceable>b</replaceable>), <replaceable>b</replaceable>).</para>
		</section>

		<section id="or">
			<title>or</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>90</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The arguments are evaluated producing integer values of the same
				<code>VARIETY</code>, <replaceable>v</replaceable>. The result is the bitwise
				<replaceable>or</replaceable> of these two integers in the representing
				<code>VARIETY</code>. The result is delivered as the result of the
				construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>See <link linkend="representing-integers">Representing integers</link>.</para>
		</section>

		<section id="plus">
			<title>plus</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>91</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
arg1:   EXP INTEGER(v)
arg2:   EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The sum
				<replaceable>a</replaceable>+<replaceable>b</replaceable> is delivered as the result
				of the construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>If the result cannot be expressed in the <code>VARIETY</code> being used
				to represent <replaceable>v</replaceable>, an overflow error is caused and is
				handled in the way specified by <replaceable>ov_err</replaceable>.</para>
		</section>

		<section id="pointer_test">
			<title>pointer_test</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>92</td> </tr>
			</informaltable>

			<programlisting language="tdf">prob: OPTION(NAT)
nt:   NTEST
dest: LABEL
arg1: EXP POINTER(x)
arg2: EXP POINTER(x)
 -&gt; EXP TOP</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce pointer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, which will be derived from the same original
				pointer. These values are compared using <replaceable>nt</replaceable>.</para>

			<para>If <replaceable>a nt b</replaceable>, this construction yields
				<code>TOP</code>. Otherwise control passes to <replaceable>dest</replaceable>.</para>

			<para>If <replaceable>prob</replaceable> is present, <replaceable>prob</replaceable>/100
				gives the probability that control will continue to the next construct
				(ie. not pass to <replaceable>dest</replaceable>). If
				<replaceable>prob</replaceable> is absent this probability is unknown.</para>

			<para>The effect of this construction is the same as:</para>

			<para><replaceable>offset_test</replaceable>(<replaceable>prob, nt</replaceable>,
				<replaceable>dest</replaceable>,
				<replaceable>subtract_ptrs</replaceable>(<replaceable>arg1 </replaceable>,
				<replaceable>arg2</replaceable>),
				<replaceable>offset_zero</replaceable>(<replaceable>x</replaceable>))</para>

			<para><replaceable>In the simple memory model this construction can be
				represented by integer_test.</replaceable></para>
		</section>

		<section id="power">
			<title>power</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>93</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
arg1:   EXP INTEGER(v)
arg2:   EXP INTEGER(w)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg2</replaceable> will be non-negative. The result is the result
				of <replaceable>arg1</replaceable> raised to the power given by
				<replaceable>arg2</replaceable>.</para>

			<para>If the result cannot be expressed in the <code>VARIETY</code> being used
				to represent <replaceable>v</replaceable>, an overflow error is caused and is
				handled in the way specified by <replaceable>ov_err</replaceable>.</para>
		</section>

		<section id="proc_test">
			<title>proc_test</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>94</td> </tr>
			</informaltable>

			<programlisting language="tdf">prob: OPTION(NAT)
nt:   NTEST
dest: LABEL
arg1: EXP PROC
arg2: EXP PROC
 -&gt; EXP TOP</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce <code>PROC</code> values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>. These values are compared using
				<replaceable>nt</replaceable>.	The only permitted values of
				<replaceable>nt</replaceable> are <replaceable>equal</replaceable> and
				<replaceable>not_equal</replaceable>.</para>

			<para>If <replaceable>a nt b</replaceable>, this construction yields
				<code>TOP</code>. Otherwise control passes to <replaceable>dest</replaceable>.</para>

			<para>If <replaceable>prob</replaceable> is present, <replaceable>prob</replaceable>/100
				gives the probability that control will continue to the next construct
				(ie. not pass to <replaceable>dest</replaceable>).	If
				<replaceable>prob</replaceable> is absent this probability is unknown.</para>

			<para>Two <code>PROC</code>s are equal if they were produced by the same
				instantiation of <replaceable>make_proc</replaceable> or if they were both
				made with <replaceable>make_null_proc</replaceable>. Otherwise they are
				unequal.</para>
		</section>

		<section id="profile">
			<title>profile</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>95</td> </tr>
			</informaltable>

			<programlisting language="tdf">uses: NAT
 -&gt; EXP TOP</programlisting>

			<para>The integer <replaceable>uses</replaceable> gives the number of times which
				this construct is expected to be evaluated.</para>

			<para>All uses of <replaceable>profile</replaceable> in the same capsule are to the
				same scale.	They will be mutually consistent.</para>
		</section>

		<section id="real_part">
			<title>real_part</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>96</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP c
 -&gt; EXP FLOATING (float_of_complex(c))</programlisting>

			<para><replaceable>c</replaceable> will be complex. Delivers the real part of the
				value produced by <replaceable>arg1</replaceable>.</para>
		</section>

		<section id="rem0">
			<title>rem0</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>97</td> </tr>
			</informaltable>

			<programlisting language="tdf">div_by_0_err: ERROR_TREATMENT
ov_err:       ERROR_TREATMENT
arg1:         EXP INTEGER(v)
arg2:         EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The value <replaceable>a</replaceable> M1
				<replaceable>b</replaceable> or the value <replaceable>a</replaceable> M2
				<replaceable>b</replaceable> is delivered as the result of the construct, with
				the same <code>SHAPE</code> as the arguments. Different occurrences of
				<replaceable>rem0</replaceable> in the same capsule can use M1 or M2
				independently.</para>

			<para>The following equivalence shall hold:</para>

			<programlisting language="tdf">x = plus(mult(div0(x, y), y), rem0(x, y))</programlisting>

			<para>if all the <code>ERROR_TREATMENT</code>s are
				<replaceable>impossible</replaceable>, and <replaceable>x</replaceable> and
				<replaceable>y</replaceable> have no side effects.</para>

			<para>If <replaceable>b</replaceable> is zero a div_by_zero error occurs and is
				handled by <replaceable>div_by_0_err</replaceable>.</para>

			<para>If <replaceable>b</replaceable> is not zero and
				<replaceable>div0</replaceable>(<replaceable>a</replaceable>,
				<replaceable>b</replaceable>) cannot be expressed in the <code>VARIETY</code>
				being used to represent <replaceable>v</replaceable> an overflow may occur in
				which case it is handled by <replaceable>ov_err</replaceable>.</para>

			<para>Producers may assume that suitable masking and <replaceable>rem0</replaceable>
				by a power of two yield equally good code.</para>

			<para>See <link linkend="division-and-modulus">Division and modulus</link> for the definitions
				of D1, D2, M1 and M2.</para>
		</section>

		<section id="rem1">
			<title>rem1</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>98</td> </tr>
			</informaltable>

			<programlisting language="tdf">div_by_0_err: ERROR_TREATMENT
ov_err:       ERROR_TREATMENT
arg1:         EXP INTEGER(v)
arg2:         EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The value <replaceable>a</replaceable> M1
				<replaceable>b</replaceable> is delivered as the result of the construct, with
				the same <code>SHAPE</code> as the arguments.</para>

			<para>If <replaceable>b</replaceable> is zero a div_by_zero error occurs and is
				handled by <replaceable>div_by_0_err</replaceable>.</para>

			<para>If <replaceable>b</replaceable> is not zero and
				<replaceable>div1</replaceable>(<replaceable>a</replaceable>,
				<replaceable>b</replaceable>) cannot be expressed in the <code>VARIETY</code>
				being used to represent <replaceable>v</replaceable> an overflow may occur, in
				which case it is handled by <replaceable>ov_err</replaceable>.</para>

			<para>Producers may assume that suitable masking and <replaceable>rem1</replaceable>
				by a power of two yield equally good code.</para>

			<para>See <link linkend="division-and-modulus">Division and modulus</link> for the definitions
				of D1, D2, M1 and M2.</para>
		</section>

		<section id="rem2">
			<title>rem2</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>99</td> </tr>
			</informaltable>

			<programlisting language="tdf">div_by_0_err: ERROR_TREATMENT
ov_err:       ERROR_TREATMENT
arg1:         EXP INTEGER(v)
arg2:         EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>, of the same <code>VARIETY</code>,
				<replaceable>v</replaceable>. The value <replaceable>a</replaceable> M2
				<replaceable>b</replaceable> is delivered as the result of the construct, with
				the same <code>SHAPE</code> as the arguments.</para>

			<para>If <replaceable>b</replaceable> is zero a div_by_zero error occurs and is
				handled by</para>

			<para>If <replaceable>b</replaceable> is not zero and
				<replaceable>div2</replaceable>(<replaceable>a</replaceable>,
				<replaceable>b</replaceable>) cannot be expressed in the <code>VARIETY</code>
				being used to represent <replaceable>v</replaceable> an overflow may occur, in
				which case it is handled by <replaceable>ov_err</replaceable>.</para>

			<para>Producers may assume that suitable masking and <replaceable>rem2</replaceable>
				by a power of two yield equally good code if the lower bound of
				<replaceable>v</replaceable> is zero.</para>

			<para>See <link linkend="division-and-modulus">Division and modulus</link> for the definitions
				of D1, D2, M1 and M2.</para>
		</section>

		<section id="repeat">
			<title>repeat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>100</td> </tr>
			</informaltable>

			<programlisting language="tdf">replab_intro: LABEL
start:        EXP TOP
body:         EXP y
 -&gt; EXP y</programlisting>

			<para><replaceable>start</replaceable> is evaluated. Then <replaceable>body</replaceable>
				is evaluated.</para>

			<para>If <replaceable>body</replaceable> produces a result, this is the result of
				the whole construction. However if <replaceable>goto</replaceable> or any
				other jump to <replaceable>replab_intro</replaceable> is encountered during
				the evaluation then the current evaluation stops and
				<replaceable>body</replaceable> is evaluated again. In the canonical order all
				evaluated components are completely evaluated before any of the next
				iteration of <replaceable>body</replaceable>. The lifetime of
				<replaceable>replab_intro</replaceable> is the evaluation of
				<replaceable>body</replaceable>.</para>

			<para>The actual order of evaluation of the constituents shall be
				indistinguishable in all observable effects (apart from time) from that
				described above. Note that this specifically includes any defined error
				handling.</para>
		</section>

		<section id="return">
			<title>return</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>101</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP x
 -&gt; EXP BOTTOM</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated to produce a value,
				<replaceable>v</replaceable>. The evaluation of the immediately enclosing
				procedure ceases and <replaceable>v</replaceable> is delivered as the result
				of the procedure.</para>

			<para>Since the <replaceable>return</replaceable> construct can never produce a
				value, the <code>SHAPE</code> of its result is <code>BOTTOM</code>.</para>

			<para>All uses of <replaceable>return</replaceable> in the <replaceable>body</replaceable>
				of a <replaceable>make_proc</replaceable> or
				<replaceable>make_general_proc</replaceable> will have
				<replaceable>arg1</replaceable> with the same <code>SHAPE</code>.</para>
		</section>

		<section id="return_to_label">
			<title>return_to_label</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>102</td> </tr>
			</informaltable>

			<programlisting language="tdf">lab_val: EXP POINTER code_alignment
 -&gt; EXP BOTTOM</programlisting>

			<para><replaceable>lab_val</replaceable> will be a label value in the calling
				procedure.</para>

			<para>The evaluation of the immediately enclosing procedure ceases and control
				is passed to the calling procedure at the label given by
				<replaceable>lab_val</replaceable>.</para>
		</section>

		<section id="round_with_mode">
			<title>round_with_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>103</td> </tr>
			</informaltable>

			<programlisting language="tdf">flpt_err: ERROR_TREATMENT
mode:     ROUNDING_MODE
r:        VARIETY
arg1:     EXP FLOATING(f)
 -&gt; EXP INTEGER(r)</programlisting>

			<para><replaceable>arg</replaceable> is evaluated to produce a floating point value,
				<replaceable>v</replaceable>. This is rounded to an integer of
				<code>VARIETY</code>, <replaceable>r</replaceable>, using the
				<code>ROUNDING_MODE</code>, <replaceable>mode</replaceable>. This is the
				result of the construction.</para>

			<para>If <replaceable>f</replaceable> is complex the result is derived from the real
				part of <replaceable>arg1</replaceable>.</para>

			<para>If there is a floating point error it is handled by
				<replaceable>flpt_err</replaceable>.	See <link linkend="float-errors">Floating point
				errors</link>.</para>
		</section>

		<section id="rotate_left">
			<title>rotate_left</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>104</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(w)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The value delivered by <replaceable>arg1</replaceable> is rotated left
				<replaceable>arg2</replaceable> places.</para>

			<para><replaceable>arg2</replaceable> will be non-negative and will be strictly less
				than the number of bits needed to represent <replaceable>v</replaceable>.</para>

			<para>The use of this construct assumes knowledge of the representational
				variety of <replaceable>v</replaceable>.</para>
		</section>

		<section id="rotate_right">
			<title>rotate_right</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>105</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(w)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The value delivered by <replaceable>arg1</replaceable> is rotated right
				<replaceable>arg2</replaceable> places.</para>

			<para><replaceable>arg2</replaceable> will be non-negative and will be strictly less
				than the number of bits needed to represent <replaceable>v</replaceable>.</para>

			<para>The use of this construct assumes knowledge of the representational
				variety of <replaceable>v</replaceable>.</para>
		</section>

		<section id="sequence">
			<title>sequence</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>106</td> </tr>
			</informaltable>

			<programlisting language="tdf">statements: LIST(EXP)
result:     EXP x
 -&gt; EXP x</programlisting>

			<para>The statements are evaluated in the same order as the list,
				<replaceable>statements</replaceable>, and their results are discarded. Then
				<replaceable>result</replaceable> is evaluated and its result forms the result
				of the construction.</para>

			<para>A canonical order is one in which all the components of each statement
				are completely evaluated before any component of the next statement is
				started. A similar constraint applies between the last statement and the
				<replaceable>result</replaceable>. The actual order in which the statements
				and their components are evaluated shall be indistinguishable in all
				observable effects (apart from time) from a canonical order.</para>

			<para>Note that this specifically includes any defined error handling.
				However, if in any canonical order the effect of the program is
				undefined, the actual effect of the sequence is undefined.</para>

			<para>Hence constructions with <replaceable>impossible</replaceable> error handlers
				may be performed before or after those with specified error handlers, if
				the resulting order is otherwise acceptable.</para>
		</section>

		<section id="set_stack_limit">
			<title>set_stack_limit</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>107</td> </tr>
			</informaltable>

			<programlisting language="tdf">lim: EXP POINTER({locals_alignment, alloca_alignment})
 -&gt; EXP TOP</programlisting>

			<para><replaceable>set_stack_limit</replaceable> sets the limits of remaining free
				stack space to <replaceable>lim</replaceable>. This include both the frame
				stack limit and the local_alloc stack. Note that, in implementations
				where the frame stack and local_alloc stack are distinct, this pointer
				will have a special representation, appropriate to its frame alignment.
				Thus the pointer should always be generated using
				<replaceable>make_stack_limit</replaceable> or its equivalent formation.</para>

			<para>Any later <replaceable>apply_general_proc</replaceable> with
				<code>PROCPROPS</code> including <replaceable>check_stack</replaceable> up to
				the dynamically next <replaceable>set_stack_limit</replaceable> will check
				that the frame required for the procedure will be within the frame stack
				limit. If it is not, normal execution is stopped and a TDF exception
				with ERROR_code <replaceable>stack_overflow</replaceable> is raised.</para>

			<para>Any later <replaceable>local_alloc_check</replaceable> will check that the
				locally allocated space required is within the local_alloc stack limit.
				If it is not, normal execution is stopped and a TDF exception with
				ERROR_code <replaceable>stack_overflow</replaceable> is raised.</para>
		</section>

		<section id="shape_offset">
			<title>shape_offset</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>108</td> </tr>
			</informaltable>

			<programlisting language="tdf">s: SHAPE
 -&gt; EXP OFFSET(alignment(s), {})</programlisting>

			<para>This construction delivers the &ldquo;size&rdquo; of a value of the
				given <code>SHAPE</code>.</para>

			<para>Suppose that a value of <code>SHAPE</code>, <replaceable>s</replaceable>, is
				placed in a space indicated by a
				<code>POINTER</code>(<replaceable>x</replaceable>), <replaceable>p</replaceable>,
				where <replaceable>x</replaceable> includes <replaceable>alignment(s</replaceable>).
				Suppose that a value of <code>SHAPE</code>, <replaceable>t</replaceable>,
				where <replaceable>a</replaceable> is
				<replaceable>alignment</replaceable>(<replaceable>t</replaceable>) and
				<replaceable>x</replaceable> includes <replaceable>a</replaceable>, is placed at
			</para>

			<para><replaceable>add_to_ptr</replaceable>(<replaceable>p</replaceable>,
				<replaceable>offset_pad(a,
				shape_offset</replaceable>(<replaceable>s</replaceable>)))
			</para>

			<para>Then the values shall not overlap. This shall be true for all legal
				<replaceable>s</replaceable>, <replaceable>x</replaceable> and
				<replaceable>t</replaceable>.</para>
		</section>

		<section id="shift_left">
			<title>shift_left</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>109</td> </tr>
			</informaltable>

			<programlisting language="tdf">ov_err: ERROR_TREATMENT
arg1:   EXP INTEGER(v)
arg2:   EXP INTEGER(w)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>. The value <replaceable>a</replaceable> shifted left
				<replaceable>b</replaceable> places is delivered as the result of the
				construct, with the same <code>SHAPE</code> as <replaceable>a</replaceable>.</para>

			<para><replaceable>b</replaceable> will be non-negative and will be strictly less
				than the number of bits needed to represent <replaceable>v</replaceable>.</para>

			<para>If the result cannot be expressed in the <code>VARIETY</code> being used
				to represent <replaceable>v</replaceable>, an overflow error is caused and is
				handled in the way specified by <replaceable>ov_err</replaceable>.</para>

			<para>Producers may assume that <replaceable>shift_left</replaceable> and
				multiplication by a power of two yield equally efficient code.</para>
		</section>

		<section id="shift_right">
			<title>shift_right</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>110</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(w)
 -&gt; EXP INTEGER(v)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated
				and will produce integer values, <replaceable>a</replaceable> and
				<replaceable>b</replaceable>. The value <replaceable>a</replaceable> shifted right
				<replaceable>b</replaceable> places is delivered as the result of the
				construct, with the same <code>SHAPE</code> as
				<replaceable>arg1</replaceable>.</para>

			<para><replaceable>b</replaceable> will be non-negative and will be strictly less
				than the number of bits needed to represent <replaceable>v</replaceable>.</para>

			<para>If the lower bound of <replaceable>v</replaceable> is negative, the sign will
				be propagated.</para>
		</section>

		<section id="subtract_ptrs">
			<title>subtract_ptrs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>111</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP POINTER(y)
arg2: EXP POINTER(x)
 -&gt; EXP OFFSET(x, y)</programlisting>

			<para><replaceable>arg1</replaceable> and <replaceable>arg2</replaceable> are evaluated to
				produce pointers <replaceable>p1</replaceable> and <replaceable>p2</replaceable>,
				which will be derived from the same original pointer.	The result,
				<replaceable>r</replaceable>, is the <code>OFFSET</code> from
				<replaceable>p2</replaceable> to <replaceable>p1</replaceable>. Both arguments will
				be derived from the same original pointer.</para>

			<para>Note that <replaceable>add_to_ptr</replaceable>(<replaceable>p2</replaceable>,
				<replaceable>r</replaceable>) = <replaceable>p1</replaceable>.</para>
		</section>

		<section id="tail_call">
			<title>tail_call</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>112</td> </tr>
			</informaltable>

			<programlisting language="tdf">prcprops:    OPTION(PROCPROPS)
p:           EXP PROC
callee_pars: CALLEES
 -&gt; EXP BOTTOM</programlisting>

			<para><replaceable>p</replaceable> is called in the sense of
				<replaceable>apply_general_proc</replaceable> with the caller parameters of
				the immediately enclosing proc and <code>CALLEES</code> given by
				<replaceable>callee_pars</replaceable> and <code>PROCPROPS</code>
				<replaceable>prcprops</replaceable>.</para>

			<para>The result of the call is delivered as the result of the immediately
				enclosing proc in the sense of <replaceable>return</replaceable>. The
				<code>SHAPE</code> of the result of <replaceable>p</replaceable> will be
				identical to the <code>SHAPE</code> specified as the result of
				immediately enclosing procedure.</para>

			<para>The presence or absence of each of the <code>PROCPROPS</code>
				<replaceable>check_stack</replaceable> and <replaceable>untidy</replaceable>, in
				<replaceable>prcprops</replaceable> will be reflected in the
				<code>PROCPROPS</code> of the immediately enclosing procedure.</para>
		</section>

		<section id="untidy_return">
			<title>untidy_return</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>113</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP x
 -&gt; EXP BOTTOM</programlisting>

			<para><replaceable>arg1</replaceable> is evaluated to produce a value,
				<replaceable>v</replaceable>. The evaluation of the immediately enclosing
				procedure ceases and <replaceable>v</replaceable> is delivered as the result
				of the procedure, in such a manner as that pointers to any callee
				parameters or local allocations are valid in the calling procedure.</para>

			<para><replaceable>untidy_return</replaceable> can only occur in a procedure defined
				by <replaceable>make_general_proc</replaceable> with <code>PROCPROPS</code>
				including <replaceable>untidy</replaceable>.</para>
		</section>

		<section id="variable">
			<title>variable</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>114</td> </tr>
			</informaltable>

			<programlisting language="tdf">opt_access: OPTION(ACCESS)
name_intro: TAG POINTER(alignment(x))
init:       EXP x
body:       EXP y
 -&gt; EXP y</programlisting>

			<para><replaceable>init</replaceable> is evaluated to produce a value,
				<replaceable>v</replaceable>. Space is allocated to hold a value of
				<code>SHAPE</code> <replaceable>x</replaceable> and this is initialised with
				<replaceable>v</replaceable>. Then <replaceable>body</replaceable> is evaluated.
				During this evaluation, an original <code>POINTER</code> pointing to the
				allocated space is bound to <replaceable>name_intro</replaceable>. This means
				that inside <replaceable>body</replaceable> an evaluation of
				<replaceable>obtain_tag</replaceable>(<replaceable>name_intro</replaceable>) will
				produce a <code>POINTER</code> to this space. The lifetime of
				<replaceable>name_intro</replaceable> is the evaluation of
				<replaceable>body</replaceable>.</para>

			<para>The value delivered by <replaceable>variable</replaceable> is that produced by
				<replaceable>body</replaceable>.</para>

			<para>If <replaceable>opt_access</replaceable> contains
				<replaceable>visible</replaceable>, it means that the contents of the space
				may be altered while the procedure containing this declaration is not
				the current procedure. Hence if there are any copies of this value they
				will need to be refreshed from the variable when the procedure is
				returned to. The easiest implementation when
				<replaceable>opt_access</replaceable> is <replaceable>visible</replaceable> may be
				to keep the value in memory, but this is not a necessary requirement.</para>

			<para>The <code>TAG</code> given for <replaceable>name_intro</replaceable> will not
				be reused within the current <code>UNIT</code>. No rules for the hiding
of one <code>TAG</code> by another are given: this will not happen.</para>

			<para>The order in which the constituents of <replaceable>init</replaceable> and
				<replaceable>body</replaceable> are evaluated shall be indistinguishable in
				all observable effects (apart from time) from completely evaluating
				<replaceable>init</replaceable> before starting <replaceable>body</replaceable>.
				See the note about order in <link linkend="sequence">sequence</link>.</para>

			<para>When compiling languages which permit uninitialised variable
				declarations, <replaceable>make_value</replaceable> may be used to provide an
				initialisation.</para>
		</section>

		<section id="xor">
			<title>xor</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>115</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: EXP INTEGER(v)
arg2: EXP INTEGER(v)
 -&gt; EXP INTEGER(v)</programlisting>

			<para>The arguments are evaluated producing integer values of the same
				<code>VARIETY</code>, <replaceable>v</replaceable>. The result is the bitwise
				<replaceable>xor</replaceable> of these two integers in the representing
				<code>VARIETY</code>. The result is delivered as the result of the
				construct, with the same <code>SHAPE</code> as the arguments.</para>

			<para>See <link linkend="representing-integers">Representing integers</link>.</para>
		</section>
	</section>

	<section id="EXTERNAL">
		<title>EXTERNAL</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>An <code>EXTERNAL</code> defines the classes of external name available
			for connecting the internal names inside a <code>CAPSULE</code> to the
			world outside the <code>CAPSULE</code>.</para>

		<section id="string_extern">
			<title>string_extern</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">s: BYTE_ALIGN TDFIDENT(n)
 -&gt; EXTERNAL</programlisting>

			<para><replaceable>string_extern</replaceable> produces an <code>EXTERNAL</code>
				identified by the <code>TDFIDENT</code> <replaceable>s</replaceable>.</para>
		</section>

		<section id="unique_extern">
			<title>unique_extern</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">u: BYTE_ALIGN UNIQUE
 -&gt; EXTERNAL</programlisting>

			<para><replaceable>unique_extern</replaceable> produces an <code>EXTERNAL</code>
				identified by the <code>UNIQUE</code> <replaceable>u</replaceable>.</para>
		</section>

		<section id="chain_extern">
			<title>chain_extern</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">s:    BYTE_ALIGN TDFIDENT
prev: TDFINT
 -&gt; EXTERNAL</programlisting>

			<para>This construct is redundant and should not be used.</para>
		</section>
	</section>

	<section id="EXTERN_LINK">
		<title>EXTERN_LINK</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>An auxiliary <code>SORT</code> providing a list of
			<code>LINKEXTERN</code>.</para>

		<section id="make_extern_link">
			<title>make_extern_link</title>


			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">el: SLIST(LINKEXTERN)
 -&gt; EXTERN_LINK</programlisting>

			<para><replaceable>make_capsule</replaceable> requires a
				<code>SLIST</code>(<code>EXTERN_LINK</code>) to express the links
				between the linkable entities and the named (by <code>EXTERNAL</code>s)
				values outside the <code>CAPSULE</code>.</para>
		</section>
	</section>

	<section id="FLOATING_VARIETY">
		<title>FLOATING_VARIETY</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These describe kinds of floating point number.</para>

		<section id="flvar_apply_token">
			<title>flvar_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; FLOATING_VARIETY</programlisting>

			<para>The token is applied to the arguments to give a
				<code>FLOATING_VARIETY</code>
			</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="flvar_cond">
			<title>flvar_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM FLOATING_VARIETY
e2:      BITSTREAM FLOATING_VARIETY
 -&gt; FLOATING_VARIETY</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="flvar_parms">
			<title>flvar_parms</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">base:          NAT
mantissa_digs: NAT
min_exponent:  NAT
max_exponent:  NAT
 -&gt; FLOATING_VARIETY</programlisting>

			<para><replaceable>base</replaceable> is the base with respect to which the
				remaining numbers refer. <replaceable>base</replaceable> will be a power of 2.</para>

			<para><replaceable>mantissa_digs</replaceable> is the required number of
				<replaceable>base</replaceable> digits, <replaceable>q</replaceable>, such that any
				number with <replaceable>q</replaceable> digits can be rounded to a floating
				point number of the variety and back again without any change to the
				<replaceable>q</replaceable> digits.</para>

			<para><replaceable>min_exponent</replaceable> is the negative of the required
				minimum integer such that <replaceable>base</replaceable> raised to that power
				can be represented as a non-zero floating point number in the
				<code>FLOATING_VARIETY</code>.</para>

			<para><replaceable>max_exponent</replaceable> is the required maximum integer such
				that <replaceable>base</replaceable> raised to that power can be represented
				in the <code>FLOATING_VARIETY</code>.</para>

			<para>A TDF translator is required to make available a representing
				<code>FLOATING_VARIETY</code> such that, if only values within the given
				requirements are produced, no overflow error will occur. Where several
				such representative <code>FLOATING_VARIETY</code>s exist, the translator
				will choose one to minimise space requirements or maximise the speed of
				operations.</para>

			<para>All numbers of the form xb1	M*<replaceable>base N+1-q</replaceable> are
				required to be represented exactly where M and N are integers such
			that <replaceable>base</replaceable><replaceable>q-1</replaceable>	M &lt;
			<replaceable>base</replaceable><replaceable>q</replaceable>
				-<replaceable>min_exponent</replaceable>	N <replaceable>max_exponent</replaceable>
			</para>

			<para>Zero will also be represented exactly in any
				<code>FLOATING_VARIETY</code>.</para>
		</section>

		<section id="complex_parms">
			<title>complex_parms</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf">base:          NAT
mantissa_digs: NAT
min_exponent:  NAT
max_exponent:  NAT
 -&gt; FLOATING_VARIETY</programlisting>

			<para>A <code>FLOATING_VARIETY</code> described by
				<replaceable>complex_parms</replaceable> holds a complex number which is
				likely to be represented by its real and imaginary parts, each of which
				is as if defined by <replaceable>flvar_parms</replaceable> with the same
				arguments.</para>
		</section>

		<section id="float_of_complex">
			<title>float_of_complex</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf">csh: SHAPE
 -&gt; FLOATING_VARIETY</programlisting>

			<para><replaceable>csh</replaceable> will be a complex <code>SHAPE</code>.</para>

			<para>Delivers the <code>FLOATING_VARIETY</code> required for the real (or
				imaginary) part of a complex <code>SHAPE</code>
				<replaceable>csh</replaceable>.</para>
		</section>

		<section id="complex_of_float">
			<title>complex_of_float</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf">fsh: SHAPE
 -&gt; FLOATING_VARIETY</programlisting>

			<para><replaceable>fsh</replaceable> will be a floating <code>SHAPE</code>.</para>

			<para>Delivers <code>FLOATING_VARIETY</code> required for a complex number
				whose real (and imaginary) parts have <code>SHAPE</code>
				<replaceable>fsh</replaceable>.</para>
		</section>
	</section>

	<section id="GROUP">
		<title>GROUP</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>A <code>GROUP</code> is a list of <code>UNIT</code>s with the same unit
			identification.</para>

		<section id="make_group">
			<title>make_group</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">us: SLIST(UNIT)
 -&gt; GROUP</programlisting>

			<para><replaceable>make_capsule</replaceable> contains a list of
				<code>GROUPS</code>. Each member of this list has a different unit
				identification deduced from the <replaceable>prop_name</replaceable> argument
				of <replaceable>make_capsule</replaceable>.</para>
		</section>
	</section>

	<section id="LABEL">
		<title>LABEL</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>A <code>LABEL</code> marks an <code>EXP</code> in certain constructions,
			and is used in jump-like constructions to change the control to the
			labelled construction.</para>

		<section id="label_apply_token">
			<title>label_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; LABEL x</programlisting>

			<para>The token is applied to the arguments to give a <code>LABEL</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="make_label">
			<title>make_label</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">labelno: TDFINT
 -&gt; LABEL</programlisting>

			<para>Labels are represented in TDF by integers, but they are not linkable.
				Hence the definition and all uses of a <code>LABEL</code> occur in the
				same <code>UNIT</code>.</para>
		</section>
	</section>

	<section id="LINK">
		<title>LINK</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>A <code>LINK</code> expresses the connection between two variables of the
			same <code>SORT</code>.</para>

		<section id="make_link">
			<title>make_link</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">unit_name:    TDFINT
capsule_name: TDFINT
 -&gt; LINK</programlisting>

			<para>A <code>LINK</code> defines a linkable entity declared inside a
				<code>UNIT</code> as <replaceable>unit_name</replaceable> to correspond to a
				<code>CAPSULE</code> linkable entity having the same linkable entity
				identification. The <code>CAPSULE</code> linkable entity is
				<replaceable>capsule_name</replaceable>.</para>

			<para>A <code>LINK</code> is normally constructed by the TDF builder in the
				course of resolving sharing and name clashes when constructing a
				composite <code>CAPSULE</code>.</para>
		</section>
	</section>

	<section id="LINKEXTERN">
		<title>LINKEXTERN</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>A value of <code>SORT LINKEXTERN</code> expresses the connection between
			the name by which an object is known inside a <code>CAPSULE</code> and a
			name by which it is known outside.</para>

		<section id="make_linkextern">
			<title>make_linkextern</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">internal: TDFINT
ext:      EXTERNAL
 -&gt; LINKEXTERN</programlisting>

			<para><replaceable>make_linkextern</replaceable> produces a <code>LINKEXTERN</code>
				connecting an object identified within a <code>CAPSULE</code> by a
				<code>TAG</code>, <code>TOKEN</code>, <code>AL_TAG</code> or any
				linkable entity constructed from <replaceable>internal</replaceable>, with an
				<code>EXTERNAL</code>, <replaceable>ext</replaceable>. The
				<code>EXTERNAL</code> is an identifier which linkers and similar
				programs can use.</para>
		</section>
	</section>

	<section id="LINKS">
		<title>LINKS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<section id="make_links">
			<title>make_links</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">ls: SLIST(LINK)
 -&gt; LINKS</programlisting>

			<para><replaceable>make_unit</replaceable> uses a
				<code>SLIST</code>(<code>LINKS</code>) to define which linkable entities
				within a <code>UNIT</code> correspond to the <code>CAPSULE</code>
				linkable entities. Each <code>LINK</code> in a <code>LINKS</code> has
				the same linkable entity identification.</para>
		</section>
	</section>

	<section id="NAT">
		<title>NAT</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These are non-negative integers of unlimited size.</para>

		<section id="nat_apply_token">
			<title>nat_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; NAT</programlisting>

			<para>The token is applied to the arguments to give a <code>NAT</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="nat_cond">
			<title>nat_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM NAT
e2:      BITSTREAM NAT
 -&gt; NAT</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="computed_nat">
			<title>computed_nat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg: EXP INTEGER(v)
 -&gt; NAT</programlisting>

			<para><replaceable>arg</replaceable> will be an install-time non-negative constant.
				The result is that constant.</para>
		</section>

		<section id="error_val">
			<title>error_val</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf">err: ERROR_code
 -&gt; NAT</programlisting>

			<para>Gives the <code>NAT</code> corresponding to the <code>ERROR_code</code>
				<replaceable>err</replaceable>. Each distinct <code>ERROR_code</code> will
				give a different <code>NAT</code>.</para>
		</section>

		<section id="make_nat">
			<title>make_nat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf">n: TDFINT
 -&gt; NAT</programlisting>

			<para><replaceable>n</replaceable> is a non-negative integer of unbounded magnitude.</para>
		</section>
	</section>

	<section id="NTEST">
		<title>NTEST</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>4</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These describe the comparisons which are possible in the various
			<replaceable>test</replaceable> constructions. Note that
			<replaceable>greater_than</replaceable> is not necessarily the same as
			<replaceable>not_less_than_or_equal</replaceable>, since the result need not be
			defined (e.g. in IEEE floating point).</para>

		<section id="ntest_apply">
			<title>ntest_apply</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; NTEST</programlisting>

			<para>The token is applied to the arguments to give a <code>NTEST</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="ntest_cond">
			<title>ntest_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM NTEST
e2:      BITSTREAM NTEST
 -&gt; NTEST</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="equal">
			<title>equal</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;equal&rdquo; test.</para>
		</section>

		<section id="greater_than">
			<title>greater_than</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;greater than&rdquo; test.</para>
		</section>

		<section id="greater_than_or_equal">
			<title>greater_than_or_equal</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;greater than or equal&rdquo; test.</para>
		</section>

		<section id="less_than">
			<title>less_than</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;less than&rdquo; test.</para>
		</section>

		<section id="less_than_or_equal">
			<title>less_than_or_equal</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;less than or equal&rdquo; test.</para>
		</section>

		<section id="not_equal">
			<title>not_equal</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;not equal&rdquo; test.</para>
		</section>

		<section id="not_greater_than">
			<title>not_greater_than</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>9</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;not greater than&rdquo; test.</para>
		</section>

		<section id="not_greater_than_or_equal">
			<title>not_greater_than_or_equal</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>10</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;not (greater than or equal)&rdquo; test.</para>
		</section>

		<section id="not_less_than">
			<title>not_less_than</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>11</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;not less than&rdquo; test.</para>
		</section>

		<section id="not_less_than_or_equal">
			<title>not_less_than_or_equal</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>12</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;not (less than or equal)&rdquo; test.</para>
		</section>

		<section id="less_than_or_greater_than">
			<title>less_than_or_greater_than</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>13</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;less than or greater than&rdquo; test.</para>
		</section>

		<section id="not_less_than_and_not_greater_than">
			<title>not_less_than_and_not_greater_than</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>14</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;not less than and not greater than&rdquo; test.</para>
		</section>

		<section id="comparable">
			<title>comparable</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>15</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;comparable&rdquo; test.</para>

			<para>With all operands <code>SHAPE</code>s except <code>FLOATING</code>, this
				comparison is always true.</para>
		</section>

		<section id="not_comparable">
			<title>not_comparable</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>16</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; NTEST</programlisting>

			<para>Signifies &ldquo;not comparable&rdquo; test.</para>

			<para>With all operands <code>SHAPE</code>s except <code>FLOATING</code>, this
				comparison is always false.</para>
		</section>
	</section>

	<section id="OTAGEXP">
		<title>OTAGEXP</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>This is a auxilliary <code>SORT</code> used in
			<replaceable>apply_general_proc</replaceable>.</para>

		<section id="make_otagexp">
			<title>make_otagexp</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">tgopt: OPTION(TAG x)
e:     EXP x
 -&gt; OTAGEXP</programlisting>

			<para><replaceable>e</replaceable> is evaluated and its value is the actual caller
				parameter. If <replaceable>tgopt</replaceable> is present, the
				<code>TAG</code> will be bound to the final value of caller parameter in
				the <replaceable>postlude</replaceable> part of the
				<replaceable>apply_general_proc</replaceable>.</para>
		</section>
	</section>

	<section id="PROCPROPS">
		<title>PROCPROPS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>4</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para><code>PROCPROPS</code> is a set of properties ascribed to procedure
			definitions and calls.</para>

		<section id="procprops_apply_token">
			<title>procprops_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; PROCPROPS</programlisting>

			<para>The token is applied to the arguments to give a <code>PROCPROPS</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters in the order specified.</para>
		</section>

		<section id="procprops_cond">
			<title>procprops_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM PROCPROPS
e2:      BITSTREAM PROCPROPS
 -&gt; PROCPROPS</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="add_procprops">
			<title>add_procprops</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: PROCPROPS
arg2: PROCPROPS
 -&gt; PROCPROPS</programlisting>

			<para>Delivers the join of <replaceable>arg1</replaceable> and <replaceable>arg2</replaceable>.</para>
		</section>

		<section id="check_stack">
			<title>check_stack</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; PROCPROPS</programlisting>

			<para>The procedure body is required to check for stack overflow.</para>
		</section>

		<section id="inline">
			<title>inline</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; PROCPROPS</programlisting>

			<para>The procedure body is a good candidate for inlining at its application.</para>
		</section>

		<section id="no_long_jump_dest">
			<title>no_long_jump_dest</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; PROCPROPS</programlisting>

			<para>The procedure body will contain no label which is the destination of a
				long_jump.</para>
		</section>

		<section id="untidy">
			<title>untidy</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; PROCPROPS</programlisting>

			<para>The procedure body may be exited using an
				<replaceable>untidy_return</replaceable>.</para>
		</section>

		<section id="var_callees">
			<title>var_callees</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; PROCPROPS</programlisting>

			<para>Applications of the procedure may have different numbers of actual
				callee parameters.</para>
		</section>

		<section id="var_callers">
			<title>var_callers</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>9</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; PROCPROPS</programlisting>

			<para>Applications of the procedure may have different numbers of actual
				caller parameters.</para>
		</section>
	</section>

	<section id="PROPS">
		<title>PROPS</title>

		<para>A <code>PROPS</code> is an assemblage of program information. This
			standard offers various ways of constructing a <code>PROPS</code>
			- i.e. it defines kinds of information which it is useful to express.
These are:</para>

		<itemizedlist>
			<listitem>
				<para>definitions of <code>AL_TAG</code>s standing for
					<code>ALIGNMENT</code>s;</para>
			</listitem>

			<listitem>
				<para>declarations of <code>TAG</code>s standing for <code>EXP</code>s;</para>
			</listitem>

			<listitem>
				<para>definitions of the <code>EXP</code>s for which <code>TAG</code>sstand;
				</para>
			</listitem>

			<listitem>
				<para>declarations of <code>TOKEN</code>s standing for pieces of TDF
					program;</para>
			</listitem>

			<listitem>
				<para>definitions of the pieces of TDF program for which <code>TOKEN</code>s
					stand;</para>
			</listitem>

			<listitem>
				<para>linkage and naming information;</para>
			</listitem>

			<listitem>
				<para>version information</para>
			</listitem>
		</itemizedlist>

		<para><code>PROPS</code> giving diagnostic information are described in a
			separate document.</para>

		<para>The standard can be extended by the definition of new kinds of
			<code>PROPS</code> information and new <code>PROPS</code> constructs for
			expressing them; and private standards can define new kinds of information
			and corresponding constructs without disruption to adherents to the
			present standard.</para>

		<para>Each <code>GROUP</code> of <code>UNIT</code>s is identified by a unit
			identification - a <code>TDFIDENT</code>. All the <code>UNIT</code>s in
			that <code>GROUP</code> are of the same kind.</para>

		<para>In addition there is a <replaceable>tld</replaceable> <code>UNIT</code>, see
			<link linkend="tdf-encoding">The TDF encoding</link>.</para>
	</section>

	<section id="ROUNDING_MODE">
		<title>ROUNDING_MODE</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para><code>ROUNDING_MODE</code> specifies the way rounding is to be performed
			in floating point arithmetic.</para>

		<section id="rounding_mode_apply_token">
			<title>rounding_mode_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; ROUNDING_MODE</programlisting>

			<para>The token is applied to the arguments to give a
				<code>ROUNDING_MODE</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="rounding_mode_cond">
			<title>rounding_mode_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM ROUNDING_MODE
e2:      BITSTREAM ROUNDING_MODE
 -&gt; ROUNDING_MODE</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="round_as_state">
			<title>round_as_state</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ROUNDING_MODE</programlisting>

			<para>Round as specified by the current state of the machine.</para>
		</section>

		<section id="to_nearest">
			<title>to_nearest</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ROUNDING_MODE</programlisting>

			<para>Signifies rounding to nearest. The effect when the number lies half-way
				is not specified.</para>
		</section>

		<section id="toward_larger">
			<title>toward_larger</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ROUNDING_MODE</programlisting>

			<para>Signifies rounding toward next largest.</para>
		</section>

		<section id="toward_smaller">
			<title>toward_smaller</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ROUNDING_MODE</programlisting>

			<para>Signifies rounding toward next smallest.</para>
		</section>

		<section id="toward_zero">
			<title>toward_zero</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; ROUNDING_MODE</programlisting>

			<para>Signifies rounding toward zero.</para>
		</section>
	</section>

	<section id="SHAPE">
		<title>SHAPE</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>4</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para><code>SHAPE</code>s express symbolic size and representation information
			about run time values.</para>

		<para><code>SHAPE</code>s are constructed from primitive <code>SHAPE</code>s
			which describe values such as procedures and integers, and recursively
			from compound construction in terms of other <code>SHAPE</code>s.</para>

		<section id="shape_apply_token">
			<title>shape_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; SHAPE</programlisting>

			<para>The token is applied to the arguments to give a <code>SHAPE</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="shape_cond">
			<title>shape_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM SHAPE
e2:      BITSTREAM SHAPE
 -&gt; SHAPE</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="bitfield">
			<title>bitfield</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">bf_var: BITFIELD_VARIETY
 -&gt; SHAPE</programlisting>

			<para>A <code>BITFIELD</code> is used to represent a pattern of bits which
				will be packed, provided that the <replaceable>variety_enclosed</replaceable>
				constraints are not violated.	(see See <link linkend="representing-bitfields">section
				7.24</link>)
			</para>

			<para>A <code>BITFIELD_VARIETY</code> specifies the number of bits and whether
				they are considered to be signed.</para>

			<para>There are very few operations on <code>BITFIELD</code>s, which have to
				be converted to <code>INTEGER</code>s before arithmetic can be performed
				on them.</para>

			<para>An installer may place a limit on the number of bits it implements.	See
				<link linkend="permitted-limits">Permitted limits</link>.</para>
		</section>

		<section id="bottom">
			<title>bottom</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SHAPE</programlisting>

			<para><code>BOTTOM</code> is the <code>SHAPE</code> which describes a piece of
				program which does not evaluate to any result. Examples include
				<replaceable>goto</replaceable> and <replaceable>return</replaceable>.</para>

			<para>If <code>BOTTOM</code> is a parameter to any other <code>SHAPE</code>
				constructor, the result is <code>BOTTOM</code>.</para>
		</section>

		<section id="compound">
			<title>compound</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf">sz: EXP OFFSET(x, y)
 -&gt; SHAPE</programlisting>

			<para>The <code>SHAPE</code> constructor <code>COMPOUND</code> describes
				cartesian products and unions.</para>

			<para>The alignments <replaceable>x</replaceable> and <replaceable>y</replaceable> will be
				<replaceable>alignment</replaceable>(<replaceable>sx</replaceable>) and
				<replaceable>alignment</replaceable>(<replaceable>sy</replaceable>) for some
				<code>SHAPE</code>s <replaceable>sx</replaceable> and <replaceable>sy</replaceable>.</para>

			<para><replaceable>sz</replaceable> will evaluate to a constant, non-negative
				<code>OFFSET</code> (see <link linkend="offset_pad">offset_pad</link>).
				The resulting <code>SHAPE</code> describes a value whose size is given
				by <replaceable>sz</replaceable>.</para>
		</section>

		<section id="floating">
			<title>floating</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf">fv: FLOATING_VARIETY
 -&gt; SHAPE</programlisting>

			<para>Most of the floating point arithmetic operations,
				<replaceable>floating_plus</replaceable>, <replaceable>floating_minus</replaceable>
				etc., are defined to work in the same way on different kinds of floating
				point number. If these operations have more than one argument the
				arguments have to be of the same kind, and the result is of the same
				kind.</para>

			<para>See <link linkend="representing-floats">Representing floating point</link>.</para>

			<para>An installer may limit the <code>FLOATING_VARIETY</code>s it can
				represent. A statement of any such limits shall be part of the
				specification of an installer. See <link linkend="representing-floats">Representing
				floating point</link>.</para>
		</section>

		<section id="integer">
			<title>integer</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf">var: VARIETY
 -&gt; SHAPE</programlisting>

			<para>The different kinds of <code>INTEGER</code> are distinguished by having
				different <code>VARIETY</code>s. A fundamental <code>VARIETY</code> (not
				a <code>TOKEN</code> or conditional) is represented by two
				<code>SIGNED_NAT</code>s, respectively the lower and upper bounds
				(inclusive) of the set of values belonging to the <code>VARIETY</code>.</para>

			<para>Most architectures require that dyadic integer arithmetic operations
				take arguments of the same size, and so TDF does likewise. Because TDF
				is completely architecture neutral and makes no assumptions about word
				length, this means that the <code>VARIETY</code>s of the two arguments
				must be identical. An example illustrates this. A piece of TDF which
attempted to add two values whose <code>SHAPE</code>s were:</para>

			<para>INTEGER(0, 60000)	<replaceable>and</replaceable>	INTEGER(0, 30000)</para>

			<para>would be undefined. The reason is that without knowledge of the target
				architecture's word length, it is impossible to guarantee that the two
				values are going to be represented in the same number of bytes.	On a
				16-bit machine they probably would, but not on a 15-bit machine.	The
				only way to ensure that two <code>INTEGER</code>s are going to be
				represented in the same way in all machines is to stipulate that their
				<code>VARIETY</code>s are exactly the same.</para>

			<para>When any construct delivering an <code>INTEGER</code> of a given
				<code>VARIETY</code> produces a result which is not representable in the
				space which an installer has chosen to represent that
				<code>VARIETY</code>, an integer overflow occurs. Whether it occurs in a
				particular case depends on the target, because the installers' decisions
				on representation are inherently target-defined.</para>

			<para>A particular installer may limit the ranges of integers that it
				implements. See <link linkend="representing-integers">Representing integers</link>.</para>
		</section>

		<section id="nof">
			<title>nof</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf">n: NAT
s: SHAPE
 -&gt; SHAPE</programlisting>

			<para>The <code>NOF</code> constructor describes the <code>SHAPE</code> of a
				value consisting of an array of <replaceable>n</replaceable> values of the
				same <code>SHAPE</code>, <replaceable>s</replaceable>.</para>
		</section>

		<section id="offset">
			<title>offset</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>9</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: ALIGNMENT
arg2: ALIGNMENT
 -&gt; SHAPE</programlisting>

			<para>The <code>SHAPE</code> constructor <code>OFFSET</code> describes values
				which represent the differences between <code>POINTER</code>s, that is
				they measure offsets in memory. It should be emphasised that these are
				in general run-time values.</para>

			<para>An <code>OFFSET</code> measures the displacement from the value
				indicated by a <code>POINTER</code>(<replaceable>arg1</replaceable>) to the
				value indicated by a <code>POINTER</code>(<replaceable>arg2</replaceable>).
				Such an offset is only defined if the <code>POINTER</code>s are derived
				from the same original <code>POINTER</code>.</para>

			<para>An <code>OFFSET</code> may also measure the displacement from a
				<code>POINTER</code> to the start of a <code>BITFIELD_VARIETY</code>, or
				from the start of one <code>BITFIELD_VARIETY</code> to the start of
				another. Hence, unlike the argument of <replaceable>pointer</replaceable>,
				<replaceable>arg1</replaceable> or <replaceable>arg2</replaceable> may consist
				entirely of <code>BITFIELD_VARIETY</code>s.</para>

			<para>The set <replaceable>arg1</replaceable> will include the set
				<replaceable>arg2</replaceable>.</para>

			<para>See <link linkend="memory-model">Memory Model</link>.</para>
		</section>

		<section id="pointer">
			<title>pointer</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>10</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg: ALIGNMENT
 -&gt; SHAPE</programlisting>

			<para>A <code>POINTER</code> is a value which points to space allocated in a
				computer's memory. The <code>POINTER</code> constructor takes an
				<code>ALIGNMENT</code> argument. This argument will not consist entirely
				of <code>BITFIELD_VARIETY</code>s. See <link linkend="memory-model">Memory
				Model</link>.</para>
		</section>

		<section id="proc">
			<title>proc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>11</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SHAPE</programlisting>

			<para><code>PROC</code> is the <code>SHAPE</code> which describes pieces of
				program.</para>
		</section>

		<section id="top">
			<title>top</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>12</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SHAPE</programlisting>

			<para><code>TOP</code> is the <code>SHAPE</code> which describes pieces of
program which return no useful value. assign is an example: it performs
				an assignment, but does not deliver any useful value.</para>
		</section>
	</section>

	<section id="SIGNED_NAT">
		<title>SIGNED_NAT</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These are positive or negative integers of unbounded size.</para>

		<section id="signed_nat_apply_token">
			<title>signed_nat_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; SIGNED_NAT</programlisting>

			<para>The token is applied to the arguments to give a <code>SIGNED_NAT</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="signed_nat_cond">
			<title>signed_nat_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM SIGNED_NAT
e2:      BITSTREAM SIGNED_NAT
 -&gt; SIGNED_NAT</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="computed_signed_nat">
			<title>computed_signed_nat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg: EXP INTEGER(v)
 -&gt; SIGNED_NAT</programlisting>

			<para><replaceable>arg</replaceable> will be an install-time constant. The result is
				that constant.</para>
		</section>

		<section id="make_signed_nat">
			<title>make_signed_nat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf">neg: TDFBOOL
n:   TDFINT
 -&gt; SIGNED_NAT</programlisting>

			<para><replaceable>n</replaceable> is a non-negative integer of unbounded magnitude.
				The result is negative if and only if <replaceable>neg</replaceable> is true.</para>
		</section>

		<section id="snat_from_nat">
			<title>snat_from_nat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf">neg: BOOL
n:   NAT
 -&gt; SIGNED_NAT</programlisting>

			<para>The result is negated if and only if <replaceable>neg</replaceable> is true.</para>
		</section>
	</section>

	<section id="SORTNAME">
		<title>SORTNAME</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>5</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These are the names of the <code>SORT</code>s which can be parameters of
			<code>TOKEN</code> definitions.</para>

		<section id="access">
			<title>access</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="al_tag">
			<title>al_tag</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="alignment_sort">
			<title>alignment_sort</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="bitfield_variety">
			<title>bitfield_variety</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="bool">
			<title>bool</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="error_treatment">
			<title>error_treatment</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="exp">
			<title>exp</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="floating_variety">
			<title>floating_variety</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="foreign_sort">
			<title>foreign_sort</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>9</td> </tr>
			</informaltable>

			<programlisting language="tdf">foreign_name: STRING(k, n)
 -&gt; SORTNAME</programlisting>

			<para>This <code>SORT</code> enables unanticipated kinds of information to be
				placed in TDF.</para>
		</section>

		<section id="label">
			<title>label</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>10</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="nat">
			<title>nat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>11</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="ntest">
			<title>ntest</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>12</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="procprops">
			<title>procprops</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>13</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="rounding_mode">
			<title>rounding_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>14</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="shape">
			<title>shape</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>15</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="signed_nat">
			<title>signed_nat</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>16</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="string">
			<title>string</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>17</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="tag">
			<title>tag</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>18</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>

			<para>The <code>SORT</code> of <code>TAG</code>.</para>
		</section>

		<section id="transfer_mode">
			<title>transfer_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>19</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>

		<section id="token">
			<title>token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>20</td> </tr>
			</informaltable>

			<programlisting language="tdf">result: SORTNAME
params: LIST(SORTNAME)
 -&gt; SORTNAME</programlisting>

			<para>The <code>SORTNAME</code> of a <code>TOKEN</code>. Note that it can have
				tokens as parameters, but not as result.</para>
		</section>

		<section id="variety">
			<title>variety</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>21</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; SORTNAME</programlisting>
		</section>
	</section>

	<section id="STRING">
		<title>STRING</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<section id="string_apply_token">
			<title>string_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; STRING(k, n)</programlisting>

			<para>The token is applied to the arguments to give a <code>STRING</code></para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="string_cond">
			<title>string_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM STRING
e2:      BITSTREAM STRING
 -&gt; STRING(k, n)</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="concat_string">
			<title>concat_string</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg1: STRING(k, n)
arg2: STRING(k, m)
 -&gt; STRING(k, n+m)</programlisting>

			<para>Gives a <code>STRING</code> which is the concatenation of
				<replaceable>arg1</replaceable> with <replaceable>arg2</replaceable>.</para>
		</section>

		<section id="make_string">
			<title>make_string</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf">arg: TDFSTRING(k, n)
 -&gt; STRING(k, n)</programlisting>

			<para>Delivers the <code>STRING</code> identical to the
				<replaceable>arg</replaceable>.</para>
		</section>
	</section>

	<section id="TAG">
		<title>TAG</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
			<tr> <td>Linkable entity identification</td> <td>tag</td> </tr>
		</informaltable>

		<para>These are used to name values and variables in the run time program.</para>

		<section id="tag_apply_token">
			<title>tag_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; TAG x</programlisting>

			<para>The token is applied to the arguments to give a <code>TAG</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="make_tag">
			<title>make_tag</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">tagno: TDFINT
 -&gt; TAG x</programlisting>

			<para><replaceable>make_tag</replaceable> produces a <code>TAG</code> identified by
				<replaceable>tagno</replaceable>.</para>
		</section>
	</section>

	<section id="TAGACC">
		<title>TAGACC</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>Constructs a pair of a <code>TAG</code> and an <code>OPTION(ACCESS)</code>
			for use in <replaceable>make_proc</replaceable>.</para>

		<section id="make_tagacc">
			<title>make_tagacc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">tg:  TAG POINTER var_param_alignment
acc: OPTION(ACCESS)
 -&gt; TAGACC</programlisting>

			<para>Constructs the pair for <replaceable>make_proc</replaceable>.</para>
		</section>
	</section>

	<section id="TAGDEC">
		<title>TAGDEC</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>A <code>TAGDEC</code> declares a <code>TAG</code> for incorporation into a
			<code>TAGDEC_PROPS.</code></para>

		<section id="make_id_tagdec">
			<title>make_id_tagdec</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">t_intro:   TDFINT
acc:       OPTION(ACCESS)
signature: OPTION(STRING)
x:         SHAPE
 -&gt; TAGDEC</programlisting>

			<para>A <code>TAGDEC</code> announcing that the <code>TAG</code>
				<replaceable>t_intro</replaceable> identifies an <code>EXP</code> of
				<code>SHAPE</code> <replaceable>x</replaceable> is constructed.</para>

			<para><replaceable>acc</replaceable> specifies the <code>ACCESS</code> properties of
				the <code>TAG</code>.</para>

			<para>If there is a <replaceable>make_id_tagdec</replaceable> for a <code>TAG</code>
				then all other <replaceable>make_id_tagdec</replaceable> for the same
				<code>TAG</code> will specify the same <code>SHAPE</code> and there will
				be no <replaceable>make_var_tagdec</replaceable> or
				<replaceable>common_tagdec</replaceable> for the <code>TAG</code>.</para>

			<para>If two <replaceable>make_id_tagdecs</replaceable> specify the same tag and
				both have <replaceable>signatures</replaceable> present, the strings will be
				identical. Possible uses of this signature argument are outlined in
				<link linkend="signatures">section 7.28</link>.</para>
		</section>

		<section id="make_var_tagdec">
			<title>make_var_tagdec</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">t_intro:   TDFINT
acc:       OPTION(ACCESS)
signature: OPTION(STRING)
x:         SHAPE
 -&gt; TAGDEC</programlisting>

			<para>A <code>TAGDEC</code> announcing that the <code>TAG</code>
				<replaceable>t_intro</replaceable> identifies an <code>EXP</code> of
				<code>SHAPE POINTER</code>(<replaceable>alignment
				</replaceable>(<replaceable>x</replaceable>)) is constructed.</para>

			<para><replaceable>acc</replaceable> specifies the <code>ACCESS</code> properties of
				the <code>TAG</code>.</para>

			<para>If there is a <replaceable>make_var_tagdec</replaceable> for a
				<code>TAG</code> then all other <replaceable>make_var_tagdec</replaceable>s
				for the same <code>TAG</code> will specify <code>SHAPE</code>s with
				identical <code>ALIGNMENT</code> and there will be no
				<replaceable>make_id_tagdec</replaceable> or
				<replaceable>common_tagdec</replaceable> for the <code>TAG</code>.</para>

			<para>If two <replaceable>make_var_tagdec</replaceable>s specify the same tag and
				both have <replaceable>signature</replaceable> present, the strings will be
				identical. Possible uses of this signature argument are outlined in
				<link linkend="signatures">section 7.28</link>.</para>
		</section>

		<section id="common_tagdec">
			<title>common_tagdec</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">t_intro:   TDFINT
acc:       OPTION(ACCESS)
signature: OPTION(STRING)
x:         SHAPE
 -&gt; TAGDEC</programlisting>

			<para>A <code>TAGDEC</code> announcing that the <code>TAG</code>
				<replaceable>t_intro</replaceable> identifies an <code>EXP</code> of
				<code>SHAPE POINTER</code>(<replaceable>alignment
				</replaceable>(<replaceable>x</replaceable>)) is constructed.</para>

			<para><replaceable>acc</replaceable> specifies the <code>ACCESS</code> properties of
				the <code>TAG</code>.</para>

			<para>If there is a <replaceable>common_tagdec</replaceable> for a <code>TAG</code>
				then there will be no <replaceable>make_id_tagdec</replaceable> or
				<replaceable>make_var_tagdec</replaceable> for that <code>TAG</code>. If there
				is more than one <replaceable>common_tagdec</replaceable> for a
				<code>TAG</code> the one having the maximum <code>SHAPE</code> shall be
				taken to apply for the <code>CAPSULE</code>. Each pair of such
				<code>SHAPE</code>s will have a maximum. The maximum of two
				<code>SHAPE</code>s, <replaceable>a</replaceable> and <replaceable>b</replaceable>,
is defined as follows:
			</para>

			<itemizedlist>
				<listitem>
					<para>If the <replaceable>a</replaceable> is equal to <replaceable>b</replaceable> the
						maximum is <replaceable>a</replaceable>.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>a</replaceable> and <replaceable>b</replaceable> are
						<code>COMPOUND</code>(<replaceable>x</replaceable>) and
						<code>COMPOUND</code>(<replaceable>y</replaceable>) respectively and
						<replaceable>a</replaceable> is an initial segment of
						<replaceable>b</replaceable>, then <replaceable>b</replaceable> is the maximum.
						Similarly if <replaceable>b</replaceable> is an initial segment of
						<replaceable>a</replaceable> then <replaceable>a</replaceable> is the maximum.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>a</replaceable> and <replaceable>b</replaceable> are
						<code>NOF</code>(<replaceable>n</replaceable>, <replaceable>x</replaceable>) and
						<code>NOF</code>(<replaceable>m</replaceable>, <replaceable>x</replaceable>)
						respectively and <replaceable>n</replaceable> is less than or equal to
						<replaceable>m</replaceable>, then <replaceable>b</replaceable> is the maximum.
						Similarly if <replaceable>m</replaceable> is less than or equal to
						<replaceable>n</replaceable> then <replaceable>a</replaceable> is the maximum.</para>
				</listitem>

				<listitem>
					<para>Otherwise <replaceable>a</replaceable> and <replaceable>b</replaceable> have no
						maximum.</para>
				</listitem>
			</itemizedlist>

			<para>If two <replaceable>common_tagdecs</replaceable> specify the same tag and both
				have <replaceable>signatures</replaceable> present, the strings will be
				identical. Possible uses of this signature argument are outlined in
				<link linkend="signatures">section 7.28</link>.</para>
		</section>
	</section>

	<section id="TAGDEC_PROPS">
		<title>TAGDEC_PROPS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
			<tr> <td>Unit identification</td> <td>tagdec</td> </tr>
		</informaltable>

		<section id="make_tagdecs">
			<title>make_tagdecs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">no_labels: TDFINT
tds:       SLIST(TAGDEC)
 -&gt; TAGDEC_PROPS</programlisting>

			<para><replaceable>no_labels</replaceable> is the number of local
				<code>LABEL</code>s used in <replaceable>tds</replaceable>.
				<replaceable>tds</replaceable> is a list of <code>TAGDEC</code>s which declare
				the <code>SHAPE</code>s associated with <code>TAG</code>s.</para>
		</section>
	</section>

	<section id="TAGDEF">
		<title>TAGDEF</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>A value of <code>SORT TAGDEF</code> gives the definition of a
			<code>TAG</code> for incorporation into a <code>TAGDEF_PROPS</code>.</para>

		<section id="make_id_tagdef">
			<title>make_id_tagdef</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">t:         TDFINT
signature: OPTION(STRING)
e:         EXP x
 -&gt; TAGDEF</programlisting>

			<para><replaceable>make_id_tagdef</replaceable> produces a <code>TAGDEF</code>
				defining the <code>TAG</code> <replaceable>x</replaceable> constructed from
				the <code>TDFINT</code>, <replaceable>t</replaceable>. This <code>TAG</code>
				is defined to stand for the value delivered by <replaceable>e</replaceable>.</para>

			<para><replaceable>e</replaceable> will be a constant which can be evaluated at
				load_time or <replaceable>e</replaceable> will be some
				<replaceable>initial_value</replaceable>(E) (see <link linkend="initial_value">section 5.16.48</link>).</para>

			<para><replaceable>t</replaceable> will be declared in the <code>CAPSULE</code>
				using <replaceable>make_id_tagdec</replaceable>.	If both the
				<replaceable>make_id_tagdec</replaceable> and
				<replaceable>make_id_tagdef</replaceable> have <replaceable>signatures</replaceable>
				present, the strings will be identical.</para>

			<para>If <replaceable>x</replaceable> is <code>PROC</code> and the <code>TAG</code>
				represented by <replaceable>t</replaceable> is named externally via a
				<code>CAPSULE_LINK</code>, e will be some <replaceable>make_proc</replaceable>
				or <replaceable>make_general_proc</replaceable>.</para>

			<para>There will not be more than one <code>TAGDEF</code> defining
				<replaceable>t</replaceable> in a <code>CAPSULE</code>.</para>
		</section>

		<section id="make_var_tagdef">
			<title>make_var_tagdef</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">t:          TDFINT
opt_access: OPTION(ACCESS)
signature:  OPTION(STRING)
e:          EXP x
 -&gt; TAGDEF</programlisting>

			<para><replaceable>make_var_tagdef</replaceable> produces a <code>TAGDEF</code>
				defining the <code>TAG POINTER</code>(<replaceable>alignment(x)</replaceable>)
				constructed from the <code>TDFINT</code>, <replaceable>t</replaceable>. This
				<code>TAG</code> stands for a variable which is initialised with the
				value delivered by <replaceable>e</replaceable>.	The <code>TAG</code> is
				bound to an original pointer which has the evaluation of the program as
				its lifetime.</para>

			<para>If <replaceable>opt_access</replaceable> contains
				<replaceable>visible</replaceable>, the meaning is that the variable may be
				used by agents external to the capsule, and so it must not be optimised
				away. If it contains constant, the initialising value will remain in it
				throughout the program.</para>

			<para><replaceable>e</replaceable> will be a constant which can be evaluated at
				load_time or <replaceable>e</replaceable> will be some
				<replaceable>initial_value</replaceable>(<replaceable>e1</replaceable>) (see <link linkend="initial_value">section 5.16.48</link>).</para>

			<para><replaceable>t</replaceable> will be declared in the <code>CAPSULE</code>
				using <replaceable>make_var_tagdec</replaceable>.	If both the
				<replaceable>make_var_tagdec</replaceable> and
				<replaceable>make_var_tagdef</replaceable> have
				<replaceable>signatures</replaceable> present, the strings will be identical.</para>

			<para>There will not be more than one <code>TAGDEF</code> defining
				<replaceable>t</replaceable> in a <code>CAPSULE</code>.</para>
		</section>

		<section id="common_tagdef">
			<title>common_tagdef</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">t:          TDFINT
opt_access: OPTION(ACCESS)
signature:  OPTION(STRING)
e:          EXP x
 -&gt; TAGDEF</programlisting>

			<para><replaceable>common_tagdef</replaceable> produces a <code>TAGDEF</code>
				defining the <code>TAG</code>
				<code>POINTER</code>(<replaceable>alignment(x)</replaceable>) constructed from
				the <code>TDFINT</code>, <replaceable>t</replaceable>. This <code>TAG</code>
				stands for a variable which is initialised with the value delivered by
				<replaceable>e</replaceable>. The <code>TAG</code> is bound to an original
				pointer which has the evaluation of the program as its lifetime.</para>

			<para>If <replaceable>opt_access</replaceable> contains
				<replaceable>visible</replaceable>, the meaning is that the variable may be
				used by agents external to the capsule, and so it must not be optimised
				away. If it contains constant, the initialising value will remain in it
				throughout the program.</para>

			<para><replaceable>e</replaceable> will be a constant evaluable at load_time or
				<replaceable>e</replaceable> will be some
				<replaceable>initial_value</replaceable>(E) (see <link linkend="initial_value">section 5.16.48 </link>).</para>

			<para><replaceable>t</replaceable> will be declared in the <code>CAPSULE</code>
				using <replaceable>common_tagdec</replaceable>.If both the
				<replaceable>common_tagdec</replaceable> and
				<replaceable>common_tagdef</replaceable> have <replaceable>signatures</replaceable>
				present, the strings will be identical. Let the maximum
				<code>SHAPE</code> of these (see <link linkend="common_tagdec">common_tagdec</link>) be <replaceable>s</replaceable>.</para>

			<para>There may be any number of <replaceable>common_tagdef</replaceable>
				definitions for <replaceable>t</replaceable> in a <code>CAPSULE</code>. Of the
				<replaceable>e</replaceable> parameters of these, one will be a maximum.	This
				maximum definition is chosen as the definition of
				<replaceable>t</replaceable>. Its value of <replaceable>e</replaceable> will have
				<code>SHAPE</code> <replaceable>s</replaceable>.</para>

			<para>The maximum of two <replaceable>common_tagdef</replaceable> <code>EXP</code>s,
				<replaceable>a</replaceable> and <replaceable>b</replaceable>, is defined as
follows:
			</para>

			<itemizedlist>
				<listitem>
					<para>If <replaceable>a</replaceable> has the form
						<replaceable>make_value</replaceable>(<replaceable>s</replaceable>),
						<replaceable>b</replaceable> is the maximum.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>b</replaceable> has the form
						<replaceable>make_value</replaceable>(<replaceable>s</replaceable>),
						<replaceable>a</replaceable> is the maximum.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>a</replaceable> and <replaceable>b</replaceable> have
						<code>SHAPE COMPOUND</code>(<replaceable>x</replaceable>) and
						<code>COMPOUND</code>(<replaceable>y</replaceable>) respectively and the
						value produced by <replaceable>a</replaceable> is an initial segment of
						the value produced by <replaceable>b</replaceable>, then
						<replaceable>b</replaceable> is the maximum. Similarly if
						<replaceable>b</replaceable> is an initial segment of
						<replaceable>a</replaceable> then <replaceable>a</replaceable> is the maximum.</para>
				</listitem>

				<listitem>
					<para>If <replaceable>a</replaceable> and <replaceable>b</replaceable> have
						<code>SHAPE NOF</code>(<replaceable>n</replaceable>,
						<replaceable>x</replaceable>) and <code>NOF</code>(<replaceable>m</replaceable>,
						<replaceable>x</replaceable>) respectively and the value produced by
						<replaceable>a</replaceable> is an initial segment of the value produced
						by <replaceable>b</replaceable>, then <replaceable>b</replaceable> is the
						maximum. Similarly if <replaceable>b</replaceable> is an initial segment
						of <replaceable>a</replaceable> then <replaceable>a</replaceable> is the
						maximum.</para>
				</listitem>

				<listitem>
					<para>If the value produced by <replaceable>a</replaceable> is equal to the
						value produced by <replaceable>b</replaceable> the maximum is
						<replaceable>a</replaceable>.</para>
				</listitem>

				<listitem>
					<para>Otherwise <replaceable>a</replaceable> and <replaceable>b</replaceable> have no
						maximum.</para>
				</listitem>
			</itemizedlist>
		</section>
	</section>

	<section id="TAGDEF_PROPS">
		<title>TAGDEF_PROPS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
			<tr> <td>Unit identification</td> <td>tagdef</td> </tr>
		</informaltable>

		<section id="make_tagdefs">
			<title>make_tagdefs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">no_labels: TDFINT
tds:       SLIST(TAGDEF)
 -&gt; TAGDEF_PROPS</programlisting>

			<para><replaceable>no_labels</replaceable> is the number of local
				<code>LABEL</code>s used in <replaceable>tds</replaceable>.
				<replaceable>tds</replaceable> is a list of <code>TAGDEF</code>s which give
				the <code>EXP</code>s which are the definitions of values associated
				with <code>TAG</code>s.</para>
		</section>
	</section>

	<section id="TAGSHACC">
		<title>TAGSHACC</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<section id="make_tagshacc">
			<title>make_tagshacc</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">sha:        SHAPE
opt_access: OPTION(ACCESS)
tg_intro:   TAG
 -&gt; TAGSHACC</programlisting>

			<para>This is an auxiliary construction to make the elements of
				<replaceable>params_intro</replaceable> in <replaceable>make_proc</replaceable>.</para>
		</section>
	</section>

	<section id="TDFBOOL">
		<title>TDFBOOL</title>

		<para>A <code>TDFBOOL</code> is the TDF encoding of a boolean. See <link linkend="fundamental-encodings">Fundamental encoding</link>.</para>
	</section>

	<section id="TDFIDENT">
		<title>TDFIDENT</title>

		<para>A <code>TDFIDENT</code>(<replaceable>k</replaceable>, <replaceable>n</replaceable>)
			encodes a sequence of <replaceable>n</replaceable> unsigned integers of size
			<replaceable>k</replaceable> bits. <replaceable>k</replaceable> will be a multiple of
			8. See <link linkend="fundamental-encodings">Fundamental encoding</link>.</para>

		<para>This construction will not be used inside a <code>BITSTREAM</code>.</para>
	</section>

	<section id="TDFINT">
		<title>TDFINT</title>

		<para>A <code>TDFINT</code> is the TDF encoding of an unbounded unsigned integer
			constant. See <link linkend="fundamental-encodings">Fundamental encoding</link>.</para>
	</section>

	<section id="TDFSTRING">
		<title>TDFSTRING</title>

		<para>A <code>TDFSTRING</code>(<replaceable>k</replaceable>, <replaceable>n</replaceable>)
			encodes a sequence of <replaceable>n</replaceable> unsigned integers of size
			<replaceable>k</replaceable> bits. See <link linkend="fundamental-encodings">Fundamental
			encoding</link>.</para>
	</section>

	<section id="TOKDEC">
		<title>TOKDEC</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>A <code>TOKDEC</code> declares a <code>TOKEN</code> for incorporation into
			a <code>UNIT</code>.</para>

		<section id="make_tokdec">
			<title>make_tokdec</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">tok:       TDFINT
signature: OPTION(STRING)
s:         SORTNAME
 -&gt; TOKDEC</programlisting>

			<para>The sort of the token <replaceable>tok</replaceable> is declared to be
				<replaceable>s</replaceable>. Note that <replaceable>s</replaceable> will always be
				a token <code>SORT</code>, with a list of parameter <code>SORT</code>s
				(possible empty) and a result <code>SORT</code>.</para>

			<para>If <replaceable>signature</replaceable> is present, it will be produced by
				<replaceable>make_string</replaceable>.</para>

			<para>If two <replaceable>make_tokdecs</replaceable> specify the same token and both
				have <replaceable>signatures</replaceable> present, the strings will be
				identical. Possible uses of this signature argument are outlined in
				<link linkend="signatures">section 7.28</link>.</para>
		</section>
	</section>

	<section id="TOKDEC_PROPS">
		<title>TOKDEC_PROPS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
			<tr> <td>Unit identification</td> <td>tokdec</td> </tr>
		</informaltable>

		<section id="make_tokdecs">
			<title>make_tokdecs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">tds: SLIST(TOKDEC)
 -&gt; TOKDEC_PROPS</programlisting>

			<para><replaceable>tds</replaceable> is a list of <code>TOKDEC</code>s which gives
				the sorts associated with <code>TOKEN</code>s.</para>
		</section>
	</section>

	<section id="TOKDEF">
		<title>TOKDEF</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para><replaceable>tds</replaceable> is a list of <code>TOKDEC</code>s which gives the
			sorts associated with <code>TOKEN</code>s.</para>

		<section id="make_tokdef">
			<title>make_tokdef</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">tok:       TDFINT
signature: OPTION(STRING)
def:       BITSTREAM TOKEN_DEFN
 -&gt; TOKDEF</programlisting>

			<para>A <code>TOKDEF</code> is constructed which defines the
				<code>TOKEN</code> <replaceable>tok</replaceable> to stand for the fragment of
				TDF, <replaceable>body</replaceable>, which may be of any <code>SORT</code>
				with a <code>SORTNAME</code>, except for <replaceable>token</replaceable>. The
				<code>SORT</code> of the result, <replaceable>result_sort</replaceable>, is
				given by the first component of the <code>BITSTREAM</code>. See <link linkend="token_definition">token_definition</link>.</para>

			<para>If <replaceable>signature</replaceable> is present, it will be produced by
				<replaceable>make_string</replaceable>.</para>

			<para><replaceable>tok</replaceable> may have been introduced by a
				<replaceable>make_tokdec</replaceable>. If both the
				<replaceable>make_tokdec</replaceable> and <replaceable>make_tokdef</replaceable>
				have <replaceable>signatures</replaceable> present, the strings will be
				identical.</para>

			<para>At the application of this <code>TOKEN</code> actual pieces of TDF
				having <code>SORT</code> <replaceable>sn</replaceable>[<replaceable>i</replaceable>]
				are supplied to correspond to the
				<replaceable>tk</replaceable>[<replaceable>i</replaceable>]. The application denotes
				the piece of TDF obtained by substituting these actual parameters for
				the corresponding <code>TOKEN</code>s within <replaceable>body</replaceable>.</para>
		</section>
	</section>

	<section id="TOKDEF_PROPS">
		<title>TOKDEF_PROPS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
			<tr> <td>Unit identification</td> <td>tokdef</td> </tr>
		</informaltable>

		<section id="make_tokdefs">
			<title>make_tokdefs</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">no_labels: TDFINT
tds:       SLIST(TOKDEF)
 -&gt; TOKDEF_PROPS</programlisting>

			<para><replaceable>no_labels</replaceable> is the number of local
				<code>LABEL</code>s used in <replaceable>tds</replaceable>.
			<replaceable>tds</replaceable> is a list of <code>TOKDEF</code>s which gives
				the definitions associated with <code>TOKEN</code>s.</para>
		</section>
	</section>

	<section id="TOKEN">
		<title>TOKEN</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
			<tr> <td>Linkable entity identification</td> <td>token</td> </tr>
		</informaltable>

		<para>These are used to stand for functions evaluated at installation time.
			They are represented by <code>TDFINT</code>s.</para>

		<section id="token_apply_token">
			<title>token_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; TOKEN</programlisting>

			<para>The token is applied to the arguments to give a <code>TOKEN</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="make_tok">
			<title>make_tok</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">tokno: TDFINT
 -&gt; TOKEN</programlisting>

			<para><replaceable>make_tok</replaceable> constructs a <code>TOKEN</code> identified
				by <replaceable>tokno</replaceable>.</para>
		</section>

		<section id="use_tokdef">
			<title>use_tokdef</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">tdef: BITSTREAM TOKEN_DEFN
 -&gt; TOKEN</programlisting>

			<para><replaceable>tdef</replaceable> is used to supply the definition, as in
				<replaceable>make_tokdef</replaceable>. Note that <code>TOKEN</code>s are only
				used in <replaceable>x_apply_token</replaceable> constructions.</para>
		</section>
	</section>

	<section id="TOKEN_DEFN">
		<title>TOKEN_DEFN</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>An auxiliary <code>SORT</code> used in <replaceable>make_tokdef</replaceable>
			and <replaceable>use_tokdef</replaceable>.</para>

		<section id="token_definition">
			<title>token_definition</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">result_sort: SORTNAME
tok_params:  LIST(TOKFORMALS)
body:        result_sort
 -&gt; TOKEN_DEFN</programlisting>

			<para>Makes a token definition. <replaceable>result_sort</replaceable> is the
				<code>SORT</code> of body. <replaceable>tok_params</replaceable> is a list of
				formal <code>TOKEN</code>s and their <code>SORT</code>s.
				<replaceable>body</replaceable> is the definition, which can use the formal
				<code>TOKEN</code>s defined in <replaceable>tok_params</replaceable>.</para>

			<para>The effect of applying the definition of a <code>TOKEN</code> is as if
				the following sequence was obeyed.</para>

			<para>First, the actual parameters (if any) are expanded to produce
				expressions of the appropriate <code>SORT</code>s. During this expansion
				all token applications in the actual parameters are expanded.</para>

			<para>Second, the definition is copied, making fresh <code>TAG</code>s and
				<code>LABEL</code>s where these are introduced in
				<replaceable>identify</replaceable>, <replaceable>variable</replaceable>,
				<replaceable>labelled</replaceable>, <replaceable>conditional</replaceable>,
				<replaceable>make_proc, make_general_proc</replaceable> and
				<replaceable>repeat</replaceable> constructions. Any other <code>TAG</code>s
				or <code>LABEL</code>s used in <replaceable>body</replaceable> will be
				provided by the context (see below) of the <code>TOKEN_DEFN</code> or by
				the expansions of the actual parameters.</para>

			<para>Third, the actual parameter expressions are substituted for the formal
				parameter tokens in <replaceable>tok_params</replaceable> to give the final
				result.</para>

			<para>The context of a <code>TOKEN_DEFN</code> is the set of names
				(<code>TOKEN</code>s, <code>TAG</code>s, <code>LABEL</code>s,
				<code>AL_TAG</code>s etc.) &ldquo;in scope&rdquo; at the site of the
				<code>TOKEN_DEFN</code>.</para>

			<para>Thus, in a <replaceable>make_tokdef</replaceable>, the context consists of the
				set of <code>TOKEN</code>s defined in its tokdef <code>UNIT</code>,
				together with the set of linkable entities defined by the
				<replaceable>make_links</replaceable> of that <code>UNIT</code>. Note that
				this does not include <code>LABEL</code>s and the only <code>TAG</code>s
				included are &ldquo;global&rdquo; ones.</para>

			<para>In a <replaceable>use_tokdef</replaceable>, the context may be wider, since
				the site of the <code>TOKEN_DEFN</code> need not be in a tokdef
				<code>UNIT</code>; it may be an actual parameter of a token application.
				If this happens to be within an EXP, there may be <code>TAG</code>s or
				<code>LABEL</code>s locally within scope; these will be in the context
				of the <code>TOKEN_DEFN</code>, together with the global names of the
				enclosing UNIT as before.</para>

			<para>Previous versions of the specification limited token
				definitions to be non-recursive. There is no intrinsic reason for the
				limitation on recursive <code>TOKEN</code>s. Since the UNIT structure
				implies different namespaces, there is very little implementation
				advantage to be gained from retaining the limitation.
			</para>
		</section>
	</section>

	<section id="TOKFORMALS">
		<title>TOKFORMALS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<section id="make_tokformals">
			<title>make_tokformals</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">sn: SORTNAME
tk: TDFINT
 -&gt; TOKFORMALS</programlisting>

			<para>An auxiliary construction to make up the elements of the lists in
				<replaceable>token_definition</replaceable>.</para>
		</section>
	</section>

	<section id="TRANSFER_MODE">
		<title>TRANSFER_MODE</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>3</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>A <code>TRANSFER_MODE</code> controls the operation of
			<replaceable>assign_with_mode</replaceable>,
			<replaceable>contents_with_mode</replaceable> and
			<replaceable>move_some</replaceable>.</para>

		<para>A <code>TRANSFER_MODE</code> acts like a set of the values
			<replaceable>overlap, trap_on_nil, complete</replaceable> and
			<replaceable>volatile</replaceable>. The <code>TRANSFER_MODE</code>
			<replaceable>standard_transfer_mode</replaceable> acts like the empty set.
			<replaceable>add_modes</replaceable> acts like set union.</para>

		<section id="transfer_mode_apply_token">
			<title>transfer_mode_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; TRANSFER_MODE</programlisting>

			<para>The token is applied to the arguments encoded in the
				<code>BITSTREAM</code> <replaceable>token_args</replaceable> to give a
				<code>TRANSFER_MODE</code>.</para>

			<para>The notation <replaceable>param_sorts(token_value)</replaceable> is intended
				to mean the following. The token definition or token declaration for
				<replaceable>token_value</replaceable> gives the <code>SORT</code>s of its
				arguments in the <code>SORTNAME</code> component. The
				<code>BITSTREAM</code> in <replaceable>token_args</replaceable> consists of
				these <code>SORT</code>s in the given order. If no token declaration or
				definition exists in the <code>CAPSULE</code>, the
				<code>BITSTREAM</code> cannot be read.</para>
		</section>

		<section id="transfer_mode_cond">
			<title>transfer_mode_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM TRANSFER_MODE
e2:      BITSTREAM TRANSFER_MODE
 -&gt; TRANSFER_MODE</programlisting>

			<para><replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="add_modes">
			<title>add_modes</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">md1: TRANSFER_MODE
md2: TRANSFER_MODE
 -&gt; TRANSFER_MODE</programlisting>

			<para>A construction qualified by <replaceable>add_modes</replaceable> has both
				<code>TRANSFER_MODES</code> <replaceable>md1</replaceable> and
				<replaceable>md2</replaceable>. If <replaceable>md1</replaceable> is
				<replaceable>standard_transfer_mode</replaceable> then the result is
				<replaceable>md2</replaceable> and symmetrically.	This operation is
				associative and commutative.</para>
		</section>

		<section id="overlap">
			<title>overlap</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; TRANSFER_MODE</programlisting>

			<para>If <replaceable>overlap</replaceable> is used to qualify a
				<replaceable>move_some</replaceable> or an
				<replaceable>assign_with_mode</replaceable> for which
				<replaceable>arg2</replaceable> is a <replaceable>contents</replaceable> or
				<replaceable>contents_with_mode</replaceable>, then the source and destination
				might overlap.	The transfer shall be made as if the data were copied
				from the source to an independent place and thence to the destination.</para>

			<para>See <link linkend="overlapping">Overlapping</link>.</para>
		</section>

		<section id="standard_transfer_mode">
			<title>standard_transfer_mode</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>5</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; TRANSFER_MODE</programlisting>

			<para>This <code>TRANSFER_MODE</code> implies no special properties.</para>
		</section>

		<section id="trap_on_nil">
			<title>trap_on_nil</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>6</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; TRANSFER_MODE</programlisting>

			<para>If <replaceable>trap_on_nil</replaceable> is used to qualify a
				<replaceable>contents_with_mode</replaceable> operation with a nil pointer
				argument, or an <replaceable>assign_with_mode</replaceable> whose arg1 is a
				nil pointer, or a <replaceable>move_some</replaceable> with either argument a
				nil pointer, the TDF exception <replaceable>nil_access</replaceable> is
				raised.</para>
		</section>

		<section id="volatile">
			<title>volatile</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>7</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; TRANSFER_MODE</programlisting>

			<para>If <replaceable>volatile</replaceable> is used to qualify a construction it
				shall not be optimised away.</para>

			<para>This is intended to implement ANSI C's volatile construction.
			In this use, any volatile identifier should be declared as a
				<code>TAG</code> with used_as_volatile <code>ACCESS</code>.
			</para>
		</section>

		<section id="complete">
			<title>complete</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>8</td> </tr>
			</informaltable>

			<programlisting language="tdf"> -&gt; TRANSFER_MODE</programlisting>

			<para>A transfer qualified with complete shall leave the destination unchanged
				if the evaluation of the value transferred is left with a jump.</para>
		</section>
	</section>

	<section id="UNIQUE">
		<title>UNIQUE</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>These are used to provide world-wide unique names for <code>TOKEN</code>s
			and <code>TAG</code>s.</para>

		<para>This implies a registry for allocating <code>UNIQUE</code> values.</para>

		<section id="make_unique">
			<title>make_unique</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">text: SLIST(TDFIDENT)
 -&gt; UNIQUE</programlisting>

			<para>Two <code>UNIQUE</code> values are equal if and only if they were
				constructed with equal arguments.</para>
		</section>
	</section>

	<section id="UNIT">
		<title>UNIT</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
		</informaltable>

		<para>A <code>UNIT</code> gathers together a <code>PROPS</code> and
			<code>LINK</code>s which relate the names by which objects are known
			inside the <code>PROPS</code> and names by which they are to be known
			across the whole of the enclosing <code>CAPSULE</code>.</para>

		<section id="make_unit">
			<title>make_unit</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">local_vars:  SLIST(TDFINT)
lks:         SLIST(LINKS)
properties:  BYTESTREAM PROPS
 -&gt; UNIT</programlisting>

			<para><replaceable>local_vars</replaceable> gives the number of linkable entities of
				each kind. These numbers correspond (in the same order) to the variable
				sorts in <replaceable>cap_linking</replaceable> in
				<replaceable>make_capsule</replaceable>. The linkable entities will be
				represented by <code>TDFINT</code>s in the range 0 to the corresponding
				<replaceable>nl</replaceable>-1.</para>

			<para><replaceable>lks</replaceable> gives the <code>LINK</code>s for each kind of
				entity in the same order as in <replaceable>local_vars</replaceable>.</para>

			<para>The <replaceable>properties</replaceable> will be a <code>PROPS</code> of a
				form dictated by the unit identification, see <link linkend="make_capsule">make_capsule</link>.</para>

			<para>The length of <replaceable>lks</replaceable> will be either 0 or equal to the
				length of <replaceable>cap_linking</replaceable> in
				<replaceable>make_capsule</replaceable>.</para>
		</section>
	</section>

	<section id="VARIETY">
		<title>VARIETY</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>2</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<para>These describe the different kinds of integer which can occur at run time.
			The fundamental construction consists of a <code>SIGNED_NAT</code> for the
			lower bound of the range of possible values, and a <code>SIGNED_NAT</code>
			for the upper bound (inclusive at both ends).</para>

		<para>There is no limitation on the magnitude of these bounds in TDF, but an
			installer may specify limits. See <link linkend="representing-integers">Representing
			integers</link>.</para>

		<section id="var_apply_token">
			<title>var_apply_token</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">token_value: TOKEN
token_args:  BITSTREAM param_sorts(token_value)
 -&gt; VARIETY</programlisting>

			<para>The token is applied to the arguments to give a <code>VARIETY</code>.</para>

			<para>If there is a definition for <replaceable>token_value</replaceable> in the
				<code>CAPSULE</code> then <replaceable>token_args</replaceable> is a
				<code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
				parameters, in the order specified.</para>
		</section>

		<section id="var_cond">
			<title>var_cond</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">control: EXP INTEGER(v)
e1:      BITSTREAM VARIETY
e2:      BITSTREAM VARIETY
 -&gt; VARIETY</programlisting>

			<para>The <replaceable>control</replaceable> is evaluated. It will be a constant at
				install time under the constant evaluation rules. If it is non-zero,
				<replaceable>e1</replaceable> is installed at this point and
				<replaceable>e2</replaceable> is ignored and never processed.	If
				<replaceable>control</replaceable> is zero then <replaceable>e2</replaceable> is
				installed at this point and <replaceable>e1</replaceable> is ignored and never
				processed.</para>
		</section>

		<section id="var_limits">
			<title>var_limits</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>3</td> </tr>
			</informaltable>

			<programlisting language="tdf">lower_bound: SIGNED_NAT
upper_bound: SIGNED_NAT
 -&gt; VARIETY</programlisting>

			<para><replaceable>lower_bound</replaceable> is the lower limit (inclusive) of the
				range of values which shall be representable in the resulting
				<code>VARIETY</code>, and <replaceable>upper_bound</replaceable> is the upper
				limit (inclusive).</para>
		</section>

		<section id="var_width">
			<title>var_width</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>4</td> </tr>
			</informaltable>

			<programlisting language="tdf">signed_width: BOOL
width:        NAT
 -&gt; VARIETY</programlisting>

			<para>If <replaceable>signed_width</replaceable> is <replaceable>true</replaceable> then
				this construction is equivalent to
				<replaceable>var_limits</replaceable>(-2<superscript><replaceable>width</replaceable>-1</superscript>,
				2<superscript><replaceable>width</replaceable>-1</superscript>-1).	If
				<replaceable>signed_width</replaceable> is <replaceable>false</replaceable> then
				this construction is <replaceable>var_limits </replaceable>(0,
				2<superscript><replaceable>width</replaceable></superscript>-1).</para>
		</section>
	</section>

	<section id="VERSION_PROPS">
		<title>VERSION_PROPS</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>0</td> </tr>
			<tr> <td>Is coding extendable</td> <td>no</td> </tr>
			<tr> <td>Unit identification</td> <td>versions</td> </tr>
		</informaltable>

		<para>This <code>UNIT</code> gives information about version numbers and user
			information.</para>

		<section id="make_versions">
			<title>make_versions</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>0</td> </tr>
			</informaltable>

			<programlisting language="tdf">version_info: SLIST(VERSION)
 -&gt; VERSION_PROPS</programlisting>

			<para>Contains version information.</para>
		</section>
	</section>

	<section id="VERSION">
		<title>VERSION</title>

		<informaltable>
			<tr> <td>Number of encoding bits</td> <td>1</td> </tr>
			<tr> <td>Is coding extendable</td> <td>yes</td> </tr>
		</informaltable>

		<section id="make_version">
			<title>make_version</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>1</td> </tr>
			</informaltable>

			<programlisting language="tdf">major_version: TDFINT
minor_version: TDFINT
 -&gt; VERSION</programlisting>

			<para>The major and minor version numbers of the TDF used. An increase in
				minor version number means an extension of facilities, an increase in
				major version number means an incompatible change. TDF with the same
				major number but a lower minor number than the installer shall install
				correctly.</para>

			<para>For TDF conforming to this specification the major number will be 4 and
				the minor number will be 0.</para>

			<para>Every <code>CAPSULE</code> will contain at least one
				<replaceable>make_version</replaceable> construct.</para>
		</section>

		<section id="user_info">
			<title>user_info</title>

			<informaltable>
				<tr> <td>Encoding number</td> <td>2</td> </tr>
			</informaltable>

			<programlisting language="tdf">information: STRING(k, n)
 -&gt; VERSION</programlisting>

			<para>This is (usually character) information included in the TDF for
				labelling purposes.</para>

			<para><replaceable>information</replaceable> will be produced by
				<replaceable>make_string</replaceable>.</para>
		</section>
	</section>
</chapter>
