<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter id="notes">
	<title>Notes</title>

	<section id="binding">
		<title>Binding</title>

		<para>The following constructions introduce <code>TAG</code>s:
			<replaceable>identify</replaceable>, <replaceable>variable</replaceable>,
			<replaceable>make_proc</replaceable>, <replaceable>make_general_proc</replaceable>,
			<replaceable>make_id_tagdec</replaceable>, <replaceable>make_var_tagdec</replaceable>,
			<replaceable>common_tagdec</replaceable>.</para>

		<para>During the evaluation of <replaceable>identify</replaceable> and
			<replaceable>variable</replaceable> a value, <replaceable>v</replaceable>, is produced
			which is bound to the <code>TAG</code> during the evaluation of an
			<code>EXP</code> or <code>EXP</code>s. The <code>TAG</code> is &ldquo;in
			scope&rdquo; for these <code>EXP</code>s. This means that in the
			<code>EXP</code> a use of the <code>TAG</code> is permissible and will
			refer to the declaration.</para>

		<para>The <replaceable>make_proc</replaceable> and
			<replaceable>make_general_proc</replaceable> construction introduces
			<code>TAG</code>s which are bound to the actual parameters on each call of
			the procedure. These <code>TAG</code>s are &ldquo;in scope&rdquo; for the
			body of the procedure.</para>

		<para>If a <replaceable>make_proc</replaceable> or
			<replaceable>make_general_proc</replaceable> construction occurs in the body of
			another <replaceable>make_proc</replaceable> or
			<replaceable>make_general_proc</replaceable>, the <code>TAG</code>s of the inner
			procedure are not in scope in the outer procedure, nor are the
			<code>TAG</code>s of the outer in scope in the inner.</para>

		<para>The <replaceable>apply_general_proc</replaceable> construction permits the
			introduction of <code>TAG</code>s whose scope is the
			<replaceable>postlude</replaceable> argument. These are bound to the values of
			caller parameters after the evaluation of the body of the procedure.</para>

		<para>The <replaceable>make_id_tagdec</replaceable>,
			<replaceable>make_var_tagdec</replaceable> and
			<replaceable>common_tagdec</replaceable> constructions introduce
			<code>TAG</code>s which are &ldquo;in scope&rdquo; throughout all the
			<replaceable>tagdef</replaceable> <code>UNIT</code>s. These <code>TAG</code>s
			may have values defined for them in the <replaceable>tagdef</replaceable>
			<code>UNIT</code>s, or values may be supplied by linking.</para>

		<para>The following constructions introduce <code>LABEL</code>s:
			<replaceable>conditional</replaceable>, <replaceable>repeat</replaceable>,
			<replaceable>labelled</replaceable>.</para>

		<para>The construction themselves define <code>EXP</code>s for which these
			<code>LABEL</code>s are &ldquo;in scope&rdquo;. This means that in the
			<code>EXP</code>s a use of the <code>LABEL</code> is permissible and will
			refer to the introducing construction.</para>

		<para><code>TAG</code>s, <code>LABEL</code>s and <code>TOKEN</code>s (as
			<code>TOKEN</code> parameters) introduced in the body of a
			<code>TOKEN</code> definition are systematically renamed in their scope
			each time the <code>TOKEN</code> definition is applied. The scope will be
			completely included by the <code>TOKEN</code> definition.</para>

		<para>Each of the values introduced in a <code>UNIT</code> will be named by a
			different <code>TAG</code>, and the labelling constructions will use
			different labels, so no visibility rules are needed. The set of
			<code>TAG</code>s and <code>LABEL</code>s used in a simple
			<code>UNIT</code> are considered separately from those in another simple
			<code>UNIT</code>, so no question of visibility arises. The compound and
			link <code>UNIT</code>s provide a method of relating the items in one
			simple <code>UNIT</code> to those in another, but this is through the
			intermediary of another set of <code>TAG</code>s and <code>TOKEN</code>s
			at the <code>CAPSULE</code> level.</para>
	</section>

	<section id="character-codes">
		<title>Character codes</title>

		<para>TDF does not have a concept of characters. It transmits integers of
			various sizes. So if a producer wishes to communicate characters to an
			installer, it will usually have to do so by encoding them in some way as
			integers.</para>

		<para>An ANSI C producer sending a TDF program to a set of normal C environments
			may well choose to encode its characters using the ASCII codes, an EBCDIC
			based producer transmitting to a known set of EBCDIC environments might
			use the code directly, and a wide character producer might likewise choose
			a specific encoding. For some programs this way of proceeding is
			necessary, because the codes are used both to represent characters and for
			arithmetic, so the particular encoding is enforced. In these cases it will
			not be possible to translate the characters to another encoding because
			the character codes will be used in the TDF as ordinary integers, which
			must not be translated.</para>

		<para>Some producers may wish to transmit true characters, in the sense that
			something is needed to represent particular printing shapes and nothing
			else. These representations will have to be transformed into the correct
			character encoding on the target machine.</para>

		<para>Probably the best way to do this is to use <code>TOKEN</code>s. A fixed
			representation for the printing marks could be chosen in terms of integers
			and <code>TOKEN</code>s introduced to represent the translation from these
			integers to local character codes, and from strings of integers to strings
			of local character codes. These definitions could be bound on the target
			machine and the installer should be capable of translating these
			constructions into efficient machine code. To make this a standard, unique
			<code>TOKEN</code>s should be used.</para>

		<para>But this raises the question, who chooses the fixed representation and the
			unique <code>TOKEN</code>s and their specification? Clearly TDF provides a
			mechanism for performing the standardisation without itself defining a
			standard.</para>

		<para>Here TDF gives rise to the need for extra standards, especially in the
			specification of globally named unique <code>TOKEN</code>s.</para>
	</section>

	<section id="constant-evaluation">
		<title>Constant evaluation</title>

		<para>Some constructions require an <code>EXP</code> argument which is
			&ldquo;constant at install time&rdquo;.	For an <code>EXP</code> to
			satisfy this condition it must be constructed according to the following
			rules after substitution of token definitions and selection of
			<replaceable>exp_cond</replaceable> branches.</para>

		<para>If it contains <replaceable>obtain_tag</replaceable> then the tag will be
			introduced within the <code>EXP</code>, or defined with
			<replaceable>make_id_tagdef</replaceable> within the current capsule.</para>

		<para>It may not contain any of the following constructions:
			<replaceable>apply_proc, apply_general_proc, assign_with_mode</replaceable>,
			<replaceable>contents_with_mode</replaceable>, <replaceable>continue</replaceable>,
			<replaceable>current_env</replaceable>, <replaceable>error_jump</replaceable>,
			<replaceable>goto_local_lv</replaceable>, <replaceable>make_local_lv</replaceable>,
			<replaceable>move_some</replaceable>, <replaceable>repeat</replaceable>,
			<replaceable>round_as_state</replaceable>.</para>

		<para>Unless it is the <code>EXP</code> argument of a <code>TAGDEF</code>, a
			&ldquo;constant at install time&rdquo; may not contain
			<replaceable>env_offset</replaceable> or <replaceable>env_size</replaceable>.</para>

		<para>Any use of <replaceable>contents</replaceable> or <replaceable>assign</replaceable>
			will be applied only to <code>POINTER</code>s derived from
			<replaceable>variable</replaceable> constructions.</para>

		<para>If it contains <replaceable>labelled</replaceable> there will only be jumps to
			the <code>LABEL</code>s from within <replaceable>starter</replaceable>, not from
			within any of the <replaceable>places</replaceable>.</para>

		<para>Any use of <replaceable>obtain_tag</replaceable> defined with
			<replaceable>make_id_tagdef</replaceable> will occur after the end of the
			<replaceable>make_id_tagdef</replaceable>.</para>

		<para>Note specifically that a constant <code>EXP</code> forming the defining
			value of a <code>TAGDEF</code> construct may contain
			<replaceable>env_offset</replaceable> and/or <replaceable>env_size</replaceable>.</para>
	</section>

	<section id="division-and-modulus">
		<title>Division and modulus</title>

		<para>Two classes of division (D) and remainder (M) construct are defined. The
			two classes have the same definition if both operands have the same sign.
			Neither is defined if the second argument is zero.</para>

		<para>Class 1:</para> 

		<programlisting language="tdf">p D1 q = n</programlisting>

		<para>where:</para>

		<!-- TODO: mathml -->
		<programlisting language="tdf">p = n*q + (p M1 q)
sign(p M1 q) = sign(q)
0 &lt;= |p M1 q| &lt; |q|</programlisting>

		<para>Class 2:</para>

		<programlisting language="tdf">p D2 q = n</programlisting>

		<para>where:</para>

		<programlisting language="tdf">p = n*q + (p M2 q)
sign(p M2 q) = sign(p)
0 &lt;= |p M2 q| &lt; |q|</programlisting>
	</section>

	<section id="equality-of-exps">
		<title>Equality of EXPs</title>

		<para>A definition of equality of <code>EXP</code>s would be a considerable part
			of a formal specification of TDF, and is not given here.</para>
	</section>

	<section id="equality-of-shapes">
		<title>Equality of SHAPEs</title>

		<itemizedlist>
			<listitem>
				<para>Two <code>SHAPE</code>s are equal if they are both
					<code>BOTTOM</code>, or both <code>TOP</code> or both
					<code>PROC</code>.</para>
			</listitem>

			<listitem>
				<para>Two <code>SHAPE</code>s are equal if they are both
					<replaceable>integer</replaceable> or both <replaceable>floating</replaceable>, or
					both <replaceable>bitfield</replaceable>, and the corresponding parameters
					are equal.</para>
			</listitem>

			<listitem>
				<para>Two <code>SHAPE</code>s are equal if they are both <code>NOF</code>,
					the numbers of items are equal and the <code>SHAPE</code> parameters
					are equal.</para>
			</listitem>

			<listitem>
				<para>Two <code>OFFSET</code>s or two <code>POINTER</code>s are equal if
					their <code>ALIGNMENT</code> parameters are pairwise equal.</para>
			</listitem>

			<listitem>
				<para>Two <code>COMPOUND</code>s are equal if their <code>OFFSET</code>
					<code>EXP</code>s are equal.</para>
			</listitem>

			<listitem>
				<para>No other pairs of <code>SHAPE</code>s are equal.</para>
			</listitem>
		</itemizedlist>
	</section>

	<section id="equality-of-alignments">
		<title>Equality of ALIGNMENTs</title>

		<para>Two <code>ALIGNMENT</code>s are equal if and only if they are equal sets.</para>
	</section>

	<section id="exceptions-and-jumps">
		<title>Exceptions and jumps</title>

		<para>TDF allows simply for labels and jumps within a procedure, by means of the
			<replaceable>conditional</replaceable>, <replaceable>labelled</replaceable> and
			<replaceable>repeat</replaceable> constructions, and the
			<replaceable>goto</replaceable>, <replaceable>case</replaceable> and various
			<replaceable>test</replaceable> constructions.	But there are two more complex
			jumping situations.</para>

		<para>First there is the jump, known to stay within a procedure, but to a
			computed destination. Many languages have discouraged this kind of
			construction, but it is still available in Cobol (implicitly), and it can
			be used to provide other facilities (see below). TDF allows it by means of
			the <code>POINTER(</code>{<replaceable>code</replaceable><code>})</code>.	TDF
			is arranged so that this can usually be implemented as the address of the
			label. The <replaceable>goto_local_lv</replaceable> construction just jumps to
			the label.</para>

		<para>The other kind of construction needed is the jump out of a procedure to a
			label which is still active, restoring the environment of the destination
			procedure: the long jump. Related to this is the notion of exception.
			Unfortunately long jumps and exceptions do not co-exist well. Exceptions
			are commonly organised so that any necessary destruction operations are
			performed as the stack of frames is traversed; long jumps commonly go
			directly to the destination. TDF must provide some facility which can
			express both of these concepts. Furthermore exceptions come in several
			different versions, according to how the exception handlers are
			discriminated and whether exception handling is initiated if there is no
			handler which will catch the exception.</para>

		<para>Fortunately the normal implementations of these concepts provide a
			suggestion as to how they can be introduced into TDF. The local label
			value provides the destination address, the environment (produced by
			<replaceable>current_env</replaceable>) provides the stack frame for the
			destination, and the stack re-setting needed by the local label jumps
			themselves provides the necessary stack information. If more information
			is needed, such as which exception handlers are active, this can be
			created by producing the appropriate TDF.</para>

		<para>So TDF takes the long jump as the basic construction, and its parameters
			are a local label value and an environment. Everything else can be built
			in terms of these.</para>

		<para>The TDF arithmetic constructions allows one to specify a
			<code>LABEL</code> as destination if the result of the operation is
			exceptional. This is sufficient for the kind of explicit exception
			handling found in C++ and, in principle, could also be used to implement
			the kind of &ldquo;automatic&rdquo; exception detection and handling
			found in Ada, for example.</para>

		<para>However many architectures have facilities for automatically trapping on
			exceptions without explicit testing. To take advantage of this, there is a
			<replaceable>trap</replaceable> <code>ERROR_TREATMENT</code> with associated
			<code>ERROR_code</code>s. The action taken on an exception with
			<replaceable>trap</replaceable> <code>ERROR_TREATMENT</code> will be to
			&ldquo;throw&rdquo; the <code>ERROR_code</code>.	Since each language has
			its own idea of how to interpret the <code>ERROR_code</code> and handle
			exceptions, the onus is on the producer writer to describe how to throw an
			<code>ERROR_code</code>.</para>

		<para>The producer writer must give a definition of a <code>TOKEN</code>
			<replaceable>~Throw</replaceable> : <code>NAT</code> -&gt; <code>EXP</code>
			where the <code>NAT</code> will be the <replaceable>error_val</replaceable> of
			some <code>ERROR_code</code>. The expansion of this token will be
			consistent with the interpretation of the relevant <code>ERROR_code</code>
			and the method of handling exceptions. Usually this will consist of
			decoding the <code>ERROR_code</code> and doing a long_jump on some globals
			set up by the procedure in which the exception handling takes place.</para>

		<para>The translator writer will provide a parameterless <code>EXP TOKEN</code>,
			<replaceable>~Set_signal_handler</replaceable>. This <code>TOKEN</code> will use
			<replaceable>~Throw</replaceable> and must be applied before any possible
			exceptions. This implies that the definition of both
			<replaceable>~Throw</replaceable> and <replaceable>~Set_signal_handler</replaceable>
			must be bound before translation of any <code>CAPSULE</code> which uses
			them, presumeably by linking with some TDF libraries.</para>

		<para>These tokens are specified in more detail in the companion document,
			<ulink url="reference/xhtml/register/">TDF Token Register</ulink>.</para>
	</section>

	<section id="procedures">
		<title>Procedures</title>

		<para>The <replaceable>var_intro</replaceable> of a <replaceable>make_proc</replaceable>, if
			present, may be used under one of two different circumstances. In one
			circumstance, the <code>POINTER TAG</code> provided by the
			<replaceable>var_intro</replaceable> is used to access the actual
			<replaceable>var_param</replaceable> of an <replaceable>apply_proc</replaceable>. If
			this is the case, all uses of <replaceable>apply_proc</replaceable> which have
			the effect of calling this procedure will have the
			<replaceable>var_param</replaceable> option present, and they will all have
			precisely the same number of <replaceable>params</replaceable> as
			<replaceable>params_intro</replaceable> in the <replaceable>make_proc</replaceable>.
			The body of the <replaceable>make_proc</replaceable> can access elements of the
			<replaceable>var_param</replaceable> by using <code>OFFSET</code> arithmetic
			relative to the <code>POINTER TAG</code>.	This provides a method of
			supplying a variable number of parameters, by composing them into a
			compound value which is supplied as the <replaceable>var_param</replaceable>.</para>

		<para>However, this has proved to be unsatisfactory for the implementation of
			variable number of parameters in C - one cannot choose the
			<code>POINTER</code> alignment of the <code>TAG</code> a priori in
			non-prototype calls.</para>

		<para>An alternative circumstance for using <replaceable>var_intro</replaceable> is
			where all uses of <replaceable>apply_proc</replaceable> which have the effect of
			calling this procedure may have more <replaceable>params</replaceable> present
			than the number of <replaceable>params_intro</replaceable>, and none of them
			will have their <replaceable>var_param</replaceable> option present.	The body
			of the <replaceable>make_proc</replaceable> can access the additional params by
			using installer-defined <code>TOKEN</code>s specified in the companion
			document <ulink url="reference/xhtml/register/">TDF Token Register</ulink>,
			analogous to the use of variable argument lists in C. A local variable
			<replaceable>v</replaceable> of shape <replaceable>~va_list</replaceable> must be
			initialised to <replaceable>~__va_start</replaceable>(<replaceable>p</replaceable>),
			where <replaceable>p</replaceable> is the <code>POINTER</code> obtained from the
			<replaceable>var_intro</replaceable>. Successive elements of the
			<replaceable>params</replaceable> list can then be obtained by successive
			applications of
			<replaceable>~va_arg</replaceable>(<replaceable>v</replaceable>,<replaceable>s</replaceable>)
			where <replaceable>s</replaceable> is the <code>SHAPE</code> of element
			obtained. Finally, <replaceable>~va_end</replaceable>(<replaceable>v</replaceable>)
			completes the use of <replaceable>v</replaceable>.</para>

		<para>The definition of caller parameters in general procedures addesses this
			difficulty in a different way, by describing the layout of caller
			parameters qualified by <code>PROCPROPS</code>
			<replaceable>var_callers</replaceable>.	This allows both the call and the body
			to have closely associated views of the <code>OFFSET</code>s within a
			parameter set, regardless of whether or not the particular parameter has
			been named. The installer-defined <code>TOKEN</code>
			<replaceable>~next_caller_offset</replaceable> provides access to successive
			caller parameters, by using <code>OFFSET</code>s relative to the current
			frame pointer <replaceable>current_env</replaceable>, adjusting for any
			differences there may be between the closely associated views.	The
			<replaceable>caller_intro</replaceable> list of the
			<replaceable>make_general_proc</replaceable> must not be empty, then the
			sequence of <code>OFFSET</code>s can start with an appropriate
			<replaceable>env_offset</replaceable>. Similar consideration applies to
			accessing within the callee parameters, using the installer-defined
			<code>TOKEN</code> <replaceable>~next_callee_offset</replaceable>.</para>

		<para>All uses of <replaceable>return</replaceable>,
			<replaceable>untidy_return</replaceable> and <replaceable>tail_call</replaceable> in a
			procedure will return values of the same <code>SHAPE</code>, and this will
			be the <replaceable>result_shape</replaceable> specified in all uses of
			<replaceable>apply_proc</replaceable> or <replaceable>apply_general_proc</replaceable>
			calling the procedure.</para>

		<para>The use of <replaceable>untidy_return</replaceable> gives a generalisation of
			<replaceable>local_alloc</replaceable>.	It extends the validity of pointers
			allocated by <replaceable>local_alloc</replaceable> within the immediatly
			enclosing procedure into the calling procedure.	The original space of
			these pointers may be invalidated by <replaceable>local_free</replaceable> just
			as if it had been generated by <replaceable>local_alloc</replaceable> in the
			calling procedure.</para>

		<para>The <code>PROCPROPS</code> <replaceable>check_stack</replaceable> may be used to
			check that limit set by set_stack_limit is not exceeded by the allocation
			of the static locals of a procedure body to be obeyed. If it is exceeded
			then the producer-defined <code>TOKEN</code> <replaceable>~Throw</replaceable>:
			<code>NAT</code> -&gt; <code>EXP</code> will be invoked as
			<replaceable>~Throw</replaceable>(<replaceable>error_val</replaceable>(<replaceable>stack_overflow</replaceable>)).
			Note that this will not include any space generated by
			<code>local_alloc</code>; an explicit test is required to do check these.</para>

		<para>Any <code>SHAPE</code> is permitted as the
			<replaceable>result_shape</replaceable> in an <replaceable>apply_proc</replaceable> or
			<replaceable>apply_general_proc</replaceable>.</para>
	</section>

	<section id="frames">
		<title>Frames</title>

		<para>TDF states that while a particular procedure activation is current, it is
			possible to create a <code>POINTER</code>, by using
			<replaceable>current_env</replaceable>, which gives access to all the declared
			variables and identifications of the activation which are alive and which
			have been marked as <replaceable>visible</replaceable>. The construction
			<replaceable>env_offset</replaceable> gives the <code>OFFSET</code> of one of
			these relative to such a <code>POINTER</code>.	These constructions may
			serve for several purposes.</para>

		<para>One significant purpose is to implement such languages as Pascal which
			have procedures declared inside other procedures. One way of implementing
			this is by means of a &ldquo;display&rdquo;, that is, a tuple of frame
			pointers of active procedures.</para>

		<para>Another purpose is to find active variables satisfying some criterion in
			all the procedure activations. This is commonly required for garbage
			collection. TDF does not force the installer to implement a frame pointer
			register, since some machines do not work best in this way.	Instead, a
			frame pointer is created only if required by
			<replaceable>current_env</replaceable>.	The implication of this is that this
			sort of garbage collection needs the collaboration of the producer to
			create TDF which makes the correct calls on
			<replaceable>current_env</replaceable> and <replaceable>env_offset</replaceable> and
			place suitable values in known positions.</para>

		<para>Programs compiled especially to provide good diagnostic information can
			also use these operations.</para>

		<para>In general any program which wishes to manipulate the frames of procedures
			other than the current one can use <replaceable>current_env</replaceable> and
			<replaceable>env_offset</replaceable> to do so.</para>

		<para>A frame consists of three components, the caller parameters, callee
			parameters and locals of the procedure involved. Since each component may
			have different internal methods of access within the frame, each has a
			different special frame alignment associated with pointers within them.
			These are <replaceable>callers_alignment</replaceable>,
			<replaceable>callees_alignment</replaceable> and
			<replaceable>locals_alignment</replaceable>. The <code>POINTER</code> produced
			by <replaceable>current_env</replaceable> will be some union of these special
			alignments depending on how the procedure was defined.</para>

		<para>Each of these frame alignments are considered to contain any
			<code>ALIGNMENT</code> produced by <replaceable>alignment</replaceable> from any
			<code>SHAPE</code>. Note that this does not say that they are the set
			union of all such <code>ALIGNMENT</code>s. This is because the
			interpretation of pointer and offset operations (notably
			<replaceable>add_to_pointer</replaceable>) may be different depending on the
			implementation of the frames; they may involve extra indirections.</para>

		<para>Accordingly, because of the constraints on
			<replaceable>add_to_ptr</replaceable>, an <code>OFFSET</code> produced by
			<replaceable>env_offset</replaceable> can only be added to a
			<code>POINTER</code> produced by <replaceable>current_env</replaceable>. It is a
			further constraint that such an <code>OFFSET</code> will only be added to
			a <code>POINTER</code> produced from <replaceable>current_env</replaceable> used
			on the procedure which declared the <code>TAG</code>.</para>
	</section>

	<section id="lifetimes">
		<title>Lifetimes</title>

		<para><code>TAG</code>s are bound to values during the evaluation of
			<code>EXP</code>s, which are specified by the construction which
			introduces the <code>TAG</code>. The evaluation of these <code>EXP</code>s
			is called the lifetime of the activation of the <code>TAG</code>.</para>

		<para>Note that lifetime is a different concept from that of scope. For example,
			if the <code>EXP</code> contains the application of a procedure, the
			evaluation of the body of the procedure is within the lifetime of the
			<code>TAG</code>, but the <code>TAG</code> will not be in scope.</para>

		<para>A similar concept applies to <code>LABEL</code>s.</para>
	</section>

	<section id="alloca">
		<title>Alloca</title>

		<para>The constructions involving <replaceable>alloca</replaceable>
			(<replaceable>last_local</replaceable>, <replaceable>local_alloc</replaceable>,
			<replaceable>local_free</replaceable>, <replaceable>local_free_all</replaceable>) as
			well as the <replaceable>untidy_return</replaceable> construction imply a
			stack-like implementation which is related to procedure calls.	They may
			be implemented using the same stack as the procedure frames, if there is
			such a stack, or it may be more convenient to implement them separately.
			However note that if the <replaceable>alloca</replaceable> mechanism is
			implemented as a stack, this may be an upward or a downward growing stack.</para>

		<para>The state of this notional stack is referred to here as the
			<replaceable>alloca</replaceable> state. The construction
			<replaceable>local_alloc</replaceable> creates a new space on the
			<replaceable>alloca</replaceable> stack, the size of this space being given by
			an <code>OFFSET</code>. In the special case that this <code>OFFSET</code>
			is zero, <replaceable>local_alloc</replaceable> in effect gives the current
			<replaceable>alloca</replaceable> state (normally a <code>POINTER</code> to the
			top of the stack).</para>

		<para>A use of <replaceable>local_free_all</replaceable> returns the
			<replaceable>alloca</replaceable> state to what it was on entry to the current
			procedure.</para>

		<para>The construction <replaceable>last_local</replaceable> gives a
			<code>POINTER</code> to the top item on the stack, but it is necessary to
			give the size of this (as an <code>OFFSET</code>) because this cannot be
			deduced if the stack is upward growing. This top item will be the whole of
			an item previously allocated with <replaceable>local_alloc</replaceable>.</para>

		<para>The construction <replaceable>local_free</replaceable> returns the state of the
			<replaceable>alloca</replaceable> machine to what it was when its parameter
			<code>POINTER</code> was allocated. The <code>OFFSET</code> parameter will
			be the same value as that with which the <code>POINTER</code> was
			allocated.</para>

		<para>The <code>ALIGNMENT</code> of the <code>POINTER</code> delivered by
			<replaceable>local_alloc</replaceable> is <replaceable>alloca_alignment</replaceable>.
			This shall include the set union of all the <code>ALIGNMENT</code>s which
			can be produced by <replaceable>alignment</replaceable> from any
			<code>SHAPE</code>.</para>

		<para>The use of <replaceable>alloca_alignment</replaceable> arises so that the
			<replaceable>alloca</replaceable> stack can hold any kind of value.	The sizes
			of spaces allocated must be rounded up to the appropriate
			<code>ALIGNMENT</code>. Since this includes all value
			<code>ALIGNMENT</code>s a value of any <code>ALIGNMENT</code> can be
			assigned into this space.	Note that there is no necessary relation with
			the special frame alignments (see <link linkend="frames">section
			7.10</link>) though they must both contain all the <code>ALIGNMENT</code>s
			which can be produced by <replaceable>alignment</replaceable> from any
			<code>SHAPE</code>.</para>

		<para>Stack pushing is <replaceable>local_alloc</replaceable>. Stack popping can be
			performed by use of <replaceable>last_local</replaceable> and
			<replaceable>local_free</replaceable>. Remembering the state of the
			<replaceable>alloca</replaceable> stack and returning to it can be performed by
			using <replaceable>local_alloc</replaceable> with a zero <code>OFFSET</code> and
			<replaceable>local_free</replaceable>.</para>

		<para>Note that stack pushing can also be achieved by the use of a procedure
			call with <replaceable>untidy_return</replaceable>.</para>

		<para>A transfer of control to a local label by means of
			<replaceable>goto</replaceable>, <replaceable>goto_local_lv</replaceable>, any
			<replaceable>test</replaceable> construction or any
			<replaceable>error_jump</replaceable> will not change the
			<replaceable>alloca</replaceable> stack.</para>

		<para>If an installer implements identify and variable by creating
			space on a stack when they come into existence, rather than doing the
			allocation for identify and variable at the start of a procedure
			activation, then it may have to consider making the alloca stack into a
			second stack.</para>
	</section>

	<section id="memory-model">
		<title>Memory Model</title>

		<para>The layout of data in memory is entirely determined by the calculation of
			<code>OFFSET</code>s relative to <code>POINTER</code>s. That is, it is
			determined by <code>OFFSET</code> arithmetic and the
			<replaceable>add_to_ptr</replaceable> construction.</para>

		<para>A <code>POINTER</code> is parameterised by the <code>ALIGNMENT</code> of
			the data indicated. An <code>ALIGNMENT</code> is a set of all the
			different kinds of basic value which can be indicated by a
			<code>POINTER</code>. That is, it is a set chosen from all
			<code>VARIETY</code>s, all <code>FLOATING_VARIETY</code>s,
			<replaceable>all</replaceable> <code>BITFIELD_VARIETY</code>s<replaceable>,
			proc</replaceable>, <replaceable>code</replaceable>, <replaceable>pointer</replaceable>
			and <replaceable>offset</replaceable>. There are also three special
			<code>ALIGNMENT</code>s, <replaceable>frame_alignment</replaceable>,
			<replaceable>alloca_alignment</replaceable> and
			<replaceable>var_param_alignment</replaceable>.</para>

		<para>The parameter of a <code>POINTER</code> will not consist entirely of
			<code>BITFIELD_VARIETY</code>s.</para>

		<para>The implication of this is that the <code>ALIGNMENT</code> of all
			procedures is the same, the <code>ALIGNMENT</code> of all
			<code>POINTER</code>s is the same and the <code>ALIGNMENT</code> of all
			<code>OFFSET</code>s is the same.</para>

		<para>At present this corresponds to the state of affairs for all machines.	But
			it is certainly possible that, for example, 64-bit pointers might be
			aligned on 64-bit boundaries while 32-bit pointers are aligned on 32-bit
			boundaries. In this case it will become necessary to add different kinds
			of pointer to TDF. This will not present a problem, because, to use such
			pointers, similar changes will have to be made in languages to distinguish
			the kinds of pointer if they are to be mixed.</para>

		<para>The difference between two <code>POINTER</code>s is measured by an
			<code>OFFSET</code>. Hence an <code>OFFSET</code> is parameterised by two
			<code>ALIGNMENT</code>s, that of the starting <code>POINTER</code> and
			that of the end <code>POINTER</code>. The <code>ALIGNMENT</code> set of
			the first must include the <code>ALIGNMENT</code> set of the second.</para>

		<para>The parameters of an <code>OFFSET</code> may consist entirely of
			<code>BITFIELD_VARIETY</code>s.</para>

		<para>The operations on <code>OFFSET</code>s are subject to various constraints
			on <code>ALIGNMENT</code>s. It is important not to read into offset
			arithmetic what is not there. Accordingly some rules of the algebra of
			<code>OFFSET</code>s are given below.</para>

		<itemizedlist>
			<listitem>
				<para><replaceable>offset_add</replaceable> is associative.</para>
			</listitem>

			<listitem>
				<para><replaceable>offset_mult</replaceable> corresponds to repeated
					offset_addition.</para>
			</listitem>

			<listitem>
				<para><replaceable>offset_max</replaceable> is commutative, associative and
					idempotent.</para>
			</listitem>

			<listitem>
				<para><replaceable>offset_add</replaceable> distributes over
					<replaceable>offset_max</replaceable> where they form legal expressions.</para>
			</listitem>

			<listitem>
				<para><replaceable>offset_test</replaceable>(<replaceable>prob</replaceable>, &gt;= ,
					<replaceable>a</replaceable>, <replaceable>b</replaceable>) continues if
					<replaceable>offset_max</replaceable>(<replaceable>a</replaceable>,<replaceable>b</replaceable>)
					= <replaceable>a</replaceable>.</para>
			</listitem>
		</itemizedlist>

		<section id="simple-model">
			<title>Simple model</title>

			<para>An example of the representation of <code>OFFSET</code> arithmetic is
				given below. This is not a definition, but only an example.	In order to
				make this clear a machine with bit addressing is hypothesized.	This
				machine is referred to as the simple model.</para>

			<para>In this machine <code>ALIGNMENT</code>s will be represented by the
				number by which the bit address of data must be divisible. For example,
				8-bit bytes might have an <code>ALIGNMENT</code> of 8, longs of 32 and
				doubles of 64. <code>OFFSET</code>s will be represented by the
				displacement in bits from a <code>POINTER</code>. <code>POINTER</code>s
				will be represented by the bit address of the data. Only one memory
				space will exist. Then in this example a possible conforming
				implementation would be as follows.</para>

			<itemizedlist>
				<listitem>
					<para><replaceable>add_to_ptr</replaceable> is addition.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_add</replaceable> is addition.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_div</replaceable> and
						<replaceable>offset_div_by_int</replaceable> are exact division.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_max</replaceable> is maximum.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_mult</replaceable> is multiply.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_negate</replaceable> is negate.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_pad</replaceable>(<replaceable>a</replaceable>,
						<replaceable>x</replaceable>) is ((<replaceable>x</replaceable> +
						<replaceable>a</replaceable>
						- 1) / <replaceable>a</replaceable>) * <replaceable>a</replaceable></para>
				</listitem>

				<listitem>
					<para><replaceable>offset_subtract</replaceable> is subtract.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_test</replaceable> is
						<replaceable>integer_test</replaceable>.</para>
				</listitem>

				<listitem>
					<para><replaceable>offset_zero</replaceable> is 0.</para>
				</listitem>

				<listitem>
					<para><replaceable>shape_offset</replaceable>(<replaceable>s</replaceable>) is the
						minimum number of bits needed to be moved to move a value of
						<code>SHAPE</code> <replaceable>s</replaceable>.</para>
				</listitem>
			</itemizedlist>

			<para>Note that these operations only exist where the constraints on the
				parameters are satisfied. Elsewhere the operations are undefined.</para>

			<para>All the computations in this representation are obvious, but there is
				one point to make concerning <replaceable>offset_max</replaceable>, which has
				the following arguments and result.</para>

			<programlisting language="tdf">arg1: EXP OFFSET(x, y)
arg2: EXP OFFSET(z, y)
 -&gt; EXP OFFSET(unite_alignments(x, z), y)</programlisting>

			<para>The <code>SHAPE</code>s could have been chosen to be:</para>

			<programlisting language="tdf">arg1: EXP OFFSET(x, y)
arg2: EXP OFFSET(z, t)
 -&gt; EXP OFFSET(unite_alignments(x, z),
               intersect_alignments(y, t))</programlisting>

			<para>where <replaceable>unite_alignments</replaceable> is set union and
				<replaceable>intersect_alignments</replaceable> is set intersection. This
				would have expressed the most general reality.	The representation of
				<replaceable>unite_alignments</replaceable>(<replaceable>x</replaceable>,
				<replaceable>z</replaceable>) is the maximum of the representations of
				<replaceable>x</replaceable> and <replaceable>z</replaceable> in the simple model.
				Unfortunately the representation of
				<replaceable>intersect_alignments</replaceable>(<replaceable>y</replaceable>,
				<replaceable>t</replaceable>) is not the minimum of the representations of
				<replaceable>y</replaceable> and <replaceable>t</replaceable>. In other words the
				simple model representation is not a homomorphism if
				<replaceable>intersect_alignments</replaceable> is used. Because the choice of
				representation in the installer is an important consideration the actual
				definition was chosen instead. It seems unlikely that this will affect
				practical programs significantly.</para>
		</section>

		<section id="pointers-and-offsets">
			<title>Comparison of pointers and offsets</title>

			<para>Two <code>POINTER</code>s to the same <code>ALIGNMENT</code>,
				<replaceable>a</replaceable>, are equal if and only if the result of
				<replaceable>subtract_ptrs</replaceable> applied to them is equal to
				<replaceable>offset_zero</replaceable>(<replaceable>a</replaceable>).</para>

			<para>The comparison of <code>OFFSET</code>s is reduced to the definition of
				<replaceable>offset_max</replaceable> and the equality of <code>OFFSET</code>s
				by the note in <link linkend="offset_test">offset_test</link>.</para>
		</section>

		<section id="circular-types">
			<title>Circular types in languages</title>

			<para>It is assumed that circular types in programming languages will always
				involve the <code>SHAPE</code>s <code>PROC</code> or
				<code>POINTER</code>(<replaceable>x</replaceable>) on the circular path in
				their TDF representation. Since the <code>ALIGNMENT</code> of
				<code>POINTER</code> is {<replaceable>pointer</replaceable>} and does not
				involve the <code>ALIGNMENT</code> of the thing pointed at, circular
				<code>SHAPE</code>s are not needed. The circularity is always broken in
				<code>ALIGNMENT</code> (or <code>PROC</code>).</para>
		</section>

		<section id="special-alignments">
			<title>Special alignments</title>

			<para>There are seven special <code>ALIGNMENT</code>s. One of these is
				<replaceable>code_alignment</replaceable>, the <code>ALIGNMENT</code> of the
				<code>POINTER</code> delivered by <replaceable>make_local_lv</replaceable>.</para>

			<para>The <code>ALIGNMENT</code> of a parameter of <code>SHAPE</code>
				<replaceable>s</replaceable> is given by
				<replaceable>parameter_alignment</replaceable>(<replaceable>s</replaceable>) which
				will always contain
				<replaceable>alignment</replaceable>(<replaceable>s</replaceable>).</para>

			<para>The other five special <code>ALIGNMENT</code>s are
				<replaceable>alloca_alignment</replaceable>, <replaceable>callees_alignment,
				callers_alignment, locals_alignment</replaceable> and
				<replaceable>var_param_alignment</replaceable>. Each of these contains the set
				union of all the <code>ALIGNMENT</code>s which can be produced by
				<replaceable>alignment</replaceable> from any <code>SHAPE</code>. But they
				need not be equal to that set union, nor need there be any relation
				between them.</para>

			<para>In particular they are not equal (in the sense of <link linkend="equality-of-alignments">
				equality of alignments --&gt;Equality of <code>ALIGNMENT</code>s</link>).</para>

			<para>Each of these five refer to alignments of various components of a
				frame.</para>

			<para>Notice that pointers and offsets such as
				<code>POINTER</code>(<replaceable>callees_alignment</replaceable>(true)) and
				<code>OFFSET</code>(<replaceable>callees_alignment</replaceable>(true),
				<replaceable>x</replaceable>) etc. can have some special representation and
				that <replaceable>add_to_ptr</replaceable> and <replaceable>offset_add</replaceable>
				can operate correctly on these representations.	However it is necessary
				that</para>

			<programlisting language="tdf">alignment(POINTER(A))={pointer}</programlisting>

			<para>for any <code>ALIGNMENT</code> <replaceable>A</replaceable>.</para>
		</section>

		<section id="atomic-assignment">
			<title>Atomic assignment</title>

			<para>At least one <code>VARIETY</code> shall exist such that
				<replaceable>assign</replaceable> and <replaceable>assign_with_mode</replaceable>
				are atomic operations. This <code>VARIETY</code> shall be specified as
				part of the installer specification. It shall be capable of representing
				the numbers 0 to 127.</para>

			<para>Note that it is not necessary for this to be the same
				<code>VARIETY</code> on each machine. Normal practice will be to use a
				<code>TOKEN</code> for this <code>VARIETY</code> and choose the
				definition of the <code>TOKEN</code> on the target machine.</para>
		</section>
	</section>

	<section id="order-of-evaluation">
		<title>Order of evaluation</title>

		<para>The order of evaluation is specified in certain constructions in terms of
			equivalent effect with a canonical order of evaluation. These
			constructions are <replaceable>conditional</replaceable>,
			<replaceable>identify</replaceable>, <replaceable>labelled</replaceable>,
			<replaceable>repeat</replaceable>, <replaceable>sequence</replaceable> and
			<replaceable>variable</replaceable>.	Let these be called the order-specifying
			constructions.</para>

		<para>The constructions which change control also specify a canonical order.
			These are <replaceable>apply_proc</replaceable>,
			<replaceable>apply_general_proc</replaceable>, <replaceable>case</replaceable>,
			<replaceable>goto</replaceable>, <replaceable>goto_local_lv</replaceable>,
			<replaceable>long_jump</replaceable>, <replaceable>return</replaceable>,
			u<replaceable>ntidy_return, return_to_label, tail_call,</replaceable> the
			<replaceable>test</replaceable> constructions and all instructions containing
			the <replaceable>error_jump</replaceable> and <replaceable>trap</replaceable>
			<code>ERROR_TREATMENT</code>s.</para>

		<para>The order of evaluation of the components of other constructions is
			as follows. The components may be evaluated in any order and with
			their components - down to the TDF leaf level - interleaved in any
			order. The constituents of the order specifying constructions may
			also be interleaved in any order, but the order of the operations
			within an order specifying operation shall be equivalent in effect
			to a canonical order.</para>

		<para>Note that the rule specifying when error_jumps or traps are to be taken
			(<link linkend="error_jump"><replaceable>error_jump</replaceable></link>) relaxes
			the strict rule that everything has to be &ldquo;as if&rdquo; completed
			by the end of certain constructions. Without this rule pipelines would
			have to stop at such points, in order to be sure of processing any errors.
			Since this is not normally needed, it would be an expensive requirement.
			Hence this rule. However a construction will be required to force errors
			to be processed in the cases where this is important.</para>
	</section>

	<section id="original-pointers">
		<title>Original pointers</title>

		<para>Certain constructions are specified as producing original pointers. They
			allocate space to hold values and produce pointers indicating that new
			space. All other pointer values are derived pointers, which are produced
			from original pointers by a sequence of <replaceable>add_to_ptr</replaceable>
			operations. Counting original pointers as being derived from themselves,
			every pointer is derived from just one original pointer.</para>

		<para>A null pointer is counted as an original pointer.</para>

		<para>If procedures are called which come from outside the TDF world (such as
			<replaceable>calloc</replaceable>) it is part of their interface with TDF to
			state if they produce original pointers, and what is the lifetime of the
			pointer.</para>

		<para>As a special case, original pointers can be produced by using
			<replaceable>current_env</replaceable> and <replaceable>env_offset</replaceable> (see
			<link linkend="current_env"><replaceable>current_env</replaceable></link>).</para>

		<para>Note that:</para>

		<programlisting language="tdf">add_to_ptr(p, offset_add(q, r))</programlisting>

		<para>is equivalent to:</para>

		<programlisting language="tdf">add_to_ptr(add_to_ptr(p, q), r)</programlisting>

		<para>In the case that <replaceable>p</replaceable> is the result of
			<replaceable>current_env</replaceable> and <replaceable>q</replaceable> is the result
			of <replaceable>env_offset</replaceable>:</para>

		<programlisting language="tdf">add_to_ptr(p, q)</programlisting>

		<para>is defined to be an original pointer. For any such expression
			<replaceable>q</replaceable> will be produced by <replaceable>env_offset</replaceable>
			applied to a <code>TAG</code> introduced in the procedure in which
			<replaceable>current_env</replaceable> was used to make <replaceable>p</replaceable>.</para>
	</section>

	<section id="overlapping">
		<title>Overlapping</title>

		<para>In the case of <replaceable>move_some</replaceable>, or
			<replaceable>assign</replaceable> or <replaceable>assign_with_mode</replaceable> in
			which <replaceable>arg2</replaceable> is a <replaceable>contents</replaceable> or
			<replaceable>contents_with_mode</replaceable>, it is possible that the source
			and destination of the transfer might overlap.</para>

		<para>In this case, if the operation is <replaceable>move_some</replaceable> or
			<replaceable>assign_with_mode</replaceable> and the <code>TRANSFER_MODE</code>
			contains <replaceable>overlap</replaceable>, then the transfer shall be
			performed correctly, that is, as if the data were copied from the source
			to an independent place and then to the destination.</para>

		<para>In all cases, if the source and destination do not overlap the transfer
			shall be performed correctly.</para>

		<para>Otherwise the effect is undefined.</para>
	</section>

	<section id="incomplete-assignment">
		<title>Incomplete assignment</title>

		<para>If the <replaceable>arg2</replaceable> component of an
			<replaceable>assign</replaceable> or <replaceable>assign_with_mode</replaceable>
			operation is left by means of a jump, the question arises as to what value
			is in the destination of the transfer.</para>

		<para>If the <code>TRANSFER_MODE</code> <replaceable>complete</replaceable> is used,
			the destination shall be left unchanged if the <replaceable>arg2</replaceable>
			component is left by means of a jump. If <replaceable>complete</replaceable> is
			not used and <replaceable>arg2</replaceable> is left by a jump, the destination
			may be affected in any way.</para>
	</section>

	<section id="representing-integers">
		<title>Representing integers</title>

		<para>Integer <code>VARIETY</code>s shall be represented by a range of integers
			which includes those specified by the given bounds. This representation
			shall be twos-complement.</para>

		<para>If the lower bound of the <code>VARIETY</code> is non-negative, the
			representing range shall be from 0 to
			2<superscript><replaceable>8n</replaceable></superscript>-1 for some
			<replaceable>n</replaceable>.	<replaceable>n</replaceable> is called the number of
			bytes in the representation. The number of bits in the representation is
			8<replaceable>n</replaceable>.</para>

		<para>If the lower bound of the <code>VARIETY</code> is negative the
			representing range shall be from -2<superscript><replaceable>8n-1</replaceable></superscript> to
			2<superscript><replaceable>8n-1</replaceable></superscript>-1 for some <replaceable>n</replaceable>.
			<replaceable>n</replaceable> is called the number of bytes in the
			representation. The number of bits in the representation is
			8<replaceable>n</replaceable></para>

		<para>Installers may limit the size of <code>VARIETY</code> that they implement.
			A statement of such limits shall be part of the specification of the
			installer. In no case may such limits be less than 64 bits, signed or
			unsigned.</para>

		<para><replaceable>It is intended that there should be no upper limit allowed at
			some future date.</replaceable></para>

		<para>Operations are performed in the representing <code>VARIETY</code>.
			If the result of an operation does not lie within the bounds of the stated
			<code>VARIETY</code>, but does lie in the representation, the value
			produced in that representation shall be as if the <code>VARIETY</code>
			had the lower and upper bounds of the representation. The implication of
			this is usually that a number in a <code>VARIETY</code> is represented by
			that same number in the representation.</para>

		<para>If the bounds of a <code>VARIETY</code>, <replaceable>v</replaceable>, include
			those of a <code>VARIETY</code>, <replaceable>w</replaceable>, the representing
			<code>VARIETY</code> for <replaceable>v</replaceable> shall include or be equal
			to the representing <code>VARIETY</code> for <replaceable>w</replaceable>.</para>

		<para>The representations of two <code>VARIETY</code>s of the form
			<replaceable>var_limits</replaceable>(0,
			2<superscript><replaceable>n</replaceable></superscript>-1) and
			<replaceable>var_limits</replaceable>(-2<superscript><replaceable>n-1</replaceable></superscript>,
			2<superscript><replaceable>n-1</replaceable></superscript>-1) shall have the
			same number of bits and the mapping of their <code>ALIGNMENT</code>s into
			the target alignment shall be the same.</para>
	</section>

	<section id="overflow-and-integers">
		<title>Overflow and Integers</title>

		<para>It is necessary first to define what overflow means for integer operations
			and second to specify what happens when it occurs. The intention of TDF is
			to permit the simplest possible implementation of common constructions on
			all common machines while allowing precise effects to be achieved, if
			necessary at extra cost.</para>

		<para>Integer varieties may be represented in the computer by a range of
			integers which includes the bounds given for the variety. An arithmetic
			operation may therefore yield a result which is within the stated variety,
			or outside the stated variety but inside the range of representing values,
			or outside that range. Most machines provide instructions to detect the
			latter case; testing for the second case is possible but a little more
			costly.</para>

		<para>In the first two cases the result is defined to be the value in the
			representation. Overflow occurs only in the third case.</para>

		<para>If the <code>ERROR_TREATMENT</code> is <replaceable>impossible</replaceable>
			overflow will not occur. If it should happen to do so the effect of the
			operation is undefined.</para>

		<para>If the <code>ERROR_TREATMENT</code> is <replaceable>error_jump</replaceable> a
			<code>LABEL</code> is provided to jump to if overflow occurs.</para>

		<para>If the <code>ERROR_TREATMENT</code> is
			<replaceable>trap(overflow),</replaceable> a producer-defined <code>TOKEN</code>
			<replaceable>~Throw</replaceable>: <code>NAT</code> -&gt; <code>EXP</code> must
			be provided.	On an overflow, the installer will arrange that
			<replaceable>~Throw</replaceable>(<replaceable>error_val</replaceable>(<replaceable>overflow</replaceable>))
			is evaluated.</para>

		<para>The <replaceable>wrap</replaceable> <code>ERROR_TREATMENT</code> is provided so
			that a useful defined result may be produced in certain cases where it is
			usually easily available on most machines. This result is available on the
			assumption that machines use binary arithmetic for integers.	This is
			certainly so at present, and there is no close prospect of other bases
			being used.</para>

		<para>If a precise result is required further arithmetic and testing may be
			needed which the installer may be able to optimise away if the word
			lengths happen to suit the problem. In extreme cases it may be necessary
			to use a larger variety.</para>
	</section>

	<section id="representing-floats">
		<title>Representing floating point</title>

		<para><code>FLOATING_VARIETY</code>s shall be implemented by a representation
			which has at least the properties specified.</para>

		<para>Installers may limit the size of <code>FLOATING_VARIETY</code> which they
			implement. A statement of such limits shall be part of the specification
			of an installer.</para>

		<para>The limit may also permit or exclude infinities.</para>

		<para>Any installer shall implement at least one <code>FLOATING_VARIETY</code>
			with the following properties (c.f. IEEE doubles):</para>

		<itemizedlist>
			<listitem>
				<para><replaceable>mantissa_digs</replaceable> shall not be less than 53.</para>
			</listitem>

			<listitem>
				<para><replaceable>min_exponent</replaceable> shall not be less than 1023.</para>
			</listitem>

			<listitem>
				<para><replaceable>max_exponent</replaceable> shall not be less than 1022.</para>
			</listitem>
		</itemizedlist>

		<para>Operations are performed and overflows detected in the representing
			<code>FLOATING_VARIETY</code>.</para>
	</section>

	<section id="float-errors">
		<title>Floating point errors</title>

		<para>The only permitted <code>ERROR_TREATMENT</code>s for operations delivering
			<code>FLOATING_VARIETY</code>s are <replaceable>impossible,
			error_jump</replaceable> and <replaceable>trap</replaceable> (overflow).</para>

		<para>The kinds of floating point error which can occur depend on the machine
			architecture (especially whether it has IEEE floating point) and on the
			definitions in the ABI being obeyed.</para>

		<para>Possible floating point errors depend on the state of the machine and may
			include overflow, divide by zero, underflow, invalid operation and
			inexact. The setting of this state is performed outside TDF (at present).</para>

		<para>If an <replaceable>error_jump</replaceable> or <replaceable>trap</replaceable> is
			taken as the result of a floating point error the operations to test what
			kind of error it was are outside the TDF definition (at present).</para>
	</section>

	<section id="rounding-and-floating-point">
		<title>Rounding and floating point</title>

		<para>Each machine has a rounding state which shall be one of
			<replaceable>to_nearest</replaceable>, <replaceable>toward_larger</replaceable>,
			<replaceable>toward_smaller</replaceable>, <replaceable>toward_zero</replaceable>. For
			each operation delivering a <code>FLOATING_VARIETY</code>, except for
			<replaceable>make_floating</replaceable>, any rounding necessary shall be
			performed according to the rounding state.</para>
	</section>

	<section id="float-accuracy">
		<title>Floating point accuracy</title>

		<para>While it is understood that most implementations will use IEEE floating
			arithmetic operations, there are machines which use other formats and
			operations. It is intended that they should not be excluded from having
			TDF implementations.</para>

		<para>For TDF to have reasonably consistent semantics across many platforms, one
			must have some <replaceable>minimum</replaceable> requirements on the accuracies
			of the results of the floating point operations defined in TDF. The
			provisional requirements sketched below would certainly be satisfied by an
			IEEE implementation.</para>

		<para>Let <replaceable>@</replaceable>	be some primitive dyadic arithmetic operator
			and <replaceable>@'</replaceable> be its TDF floating-point implementation. Let
			<replaceable>F</replaceable> be some non-complex <code>FLOATING_VARIETY</code>
			and <replaceable>F'</replaceable> be a representational variety of
			<replaceable>F</replaceable>.</para>

		<para>Condition 1:</para>

		<para>If <replaceable>a</replaceable>, <replaceable>b</replaceable> and <replaceable>a @
			b</replaceable> can all be represented exactly in <replaceable>F</replaceable>,
			then they will also be represented exactly in <replaceable>F'</replaceable>.
			Extending the '-notation in the obvious manner:</para>

		<programlisting language="tdf">(a @ b)' = (a' @' b')</programlisting>

		<para>This equality will also hold using the TDF equality test, i.e.:</para>

		<programlisting language="tdf">(a @ b)' =' (a' @' b')</programlisting>

		<para>Condition 2:</para>

		<para>The operator @' is monotonic in the sense apposite to the operator @. For
			example, consider the operator +; if x is any number and a and b are as
			above:</para>

		<programlisting language="tdf">(x &gt; b) =&gt; ((a' +' x') &gt;=	(a + b)')</programlisting>

		<para>and:</para>

		<programlisting language="tdf">(x &lt; b) =&gt;	((a' +' x') &lt;= (a + b)')</programlisting>

		<para>and so on, reflecting the weakening of the ordering after the operation
			from &gt; to &gt;=	and &lt; to &lt;=.	Once again, the inequalities
			will hold for their TDF equivalents e.g., &gt;=' and &gt;'.</para>

		<para>Similar conditions can be expressed for the monadic operations.</para>

		<para>For the floating-point test operation, there are obvious analogues
			to both conditions. The weakening of the ordering in the monotonicity
			condition, however, may lead to surprising results, arising mainly
			from the uncertainty of the result of equality between floating numbers
			which cannot be represented exactly in <replaceable>F</replaceable>.</para>

		<para>Accuracy requirements for complex <code>FLOATING_VARIETY</code>s could
			follow directly by considering the above conditions applied to real and
			imaginary parts independently. The following proviso is added for some
			complex operations however, to allow for possible intermediate error
			conditions. With <replaceable>floating_div</replaceable>,
			<replaceable>floating_mult</replaceable> and <replaceable>floating_power</replaceable>
			for complex <code>FLOATING_VARIETY</code>s, errors are guaranteed not to
			occur only if the square of the modulus of each argument is representable
			and the square of the modulus of the result is representable. Whenever
			these additional constraints are not met, the operation will either
			complete with the accuracy conditions above applying, or it will complete
			according to the <code>ERROR_TREATMENT</code> specified.</para>
	</section>

	<section id="representing-bitfields">
		<title>Representing bitfields</title>

		<para><code>BITFIELD_VARIETY</code>s specify a number of bits and shall be
			represented by exactly that number of bits in twos-complement notation.
			Producers may expect them to be packed as closely as possible.</para>

		<para>Installers may limit the number of bits permitted in
			<code>BITFIELD_VARIETY</code>s.	Such a limit shall be not less than 32
			bits, signed or unsigned.</para>

		<para><emphasis>It is intended that there should be no upper limit allowed at
			some future date.</emphasis></para>

		<para>Some offsets of which the second parameter contains a
			<code>BITFIELD</code> alignment are subject to a constraint defined below.
			This constraint is referred to as <replaceable>variety_enclosed.</replaceable></para>

		<para>The intent of this constraint is to force <code>BITFIELD</code>s to be
			implemented (in memory) as being included in some properly aligned
			<code>VARIETY</code> value.	The constraint applies to:</para>

		<programlisting language="tdf">x: offset(p, b)</programlisting>

		<para>and to:</para>

		<programlisting language="tdf">sh = bitfield(bfvar_bits(s, n))</programlisting>

		<para>where	<replaceable>alignment(sh)</replaceable> is included in
			<replaceable>b</replaceable>. The constraint is as follows:</para>
		
		<para>There will exist a <code>VARIETY</code>, <replaceable>v</replaceable>, and
			<replaceable>r</replaceable>:
			<replaceable>offset</replaceable>(<replaceable>p</replaceable>,
			<replaceable>q</replaceable>) where <replaceable>v</replaceable> is in
			<replaceable>q</replaceable>.</para>

		<programlisting language="tdf">offset_pad(b, r) &lt;= x</programlisting>

		<para>and:</para>

		<programlisting language="tdf">offset_pad(b, r + sz(v)) &gt;= offset_pad( b, x + sz(sh))</programlisting>

		<para>where the comparisons are in the sense of
			<replaceable>offset_test</replaceable>, + is <replaceable>offset_add</replaceable> and
			<replaceable>sz</replaceable> is <replaceable>shape_offset</replaceable>.</para>
	</section>

	<section id="permitted-limits">
		<title>Permitted limits</title>

		<para>An installer may specify limits on the sizes of some of the data
			<code>SHAPE</code>s which it implements. In each case there is a minimum
			set of limits such that all installers shall implement at least the
			specified <code>SHAPE</code>s. Part of the description of an installer
			shall be the limits it imposes. Installers are encouraged not to impose
			limits if possible, though it is not expected that this will be feasible
			for floating point numbers.</para>
	</section>

	<section id="least-upper-bound">
		<title>Least Upper Bound</title>

		<para>The LUB of two <code>SHAPE</code>s, <replaceable>a</replaceable> and
			<replaceable>b</replaceable> is defined as follows:</para>

		<itemizedlist>
			<listitem>
				<para>If <replaceable>a</replaceable> and <replaceable>b</replaceable> are equal shapes,
					then <replaceable>a</replaceable></para>
			</listitem>

			<listitem>
				<para>If <replaceable>a</replaceable> is <code>BOTTOM</code> then
					<replaceable>b</replaceable></para>
			</listitem>

			<listitem>
				<para>If <replaceable>b</replaceable> is <code>BOTTOM</code> then
					<replaceable>a</replaceable>.</para>
			</listitem>

			<listitem>
				<para>Otherwise <code>TOP</code>.</para>
			</listitem>
		</itemizedlist>
	</section>

	<section id="read-only-areas">
		<title>Read-only areas</title>

		<para>Consider three scenarios in increasingly static order:</para>

		<itemizedlist>
			<listitem>
				<para>Dynamic loading. A new module is loaded, initialising procedures
					are obeyed and the results of these are then marked as read-only.</para>
			</listitem>

			<listitem>
				<para>Normal loading. An <replaceable>ld</replaceable> program is obeyed which
					produces various (possibly circular) structures which are put into an
					area which will be read-only when the program is obeyed.</para>
			</listitem>

			<listitem>
				<para>Using ROM. Data structures are created (again possibly circular) and
					burnt into ROM for use by a separate program.</para>
			</listitem>
		</itemizedlist>

		<para>In each case program is obeyed to create a structure, which is then
			frozen. The special case when the data is, say, just a string is not
			sufficiently general.</para>

		<para>This TDF specification takes the attitude that the use of read-only areas
			is a property of how TDF is used - a part of the installation process -
			and there should not be TDF constructions to say that some values in a
			<code>CAPSULE</code> are read-only. Such constructions could not be
			sufficiently general.</para>
	</section>

	<section id="signatures">
		<title>Tag and Token signatures</title>

		<para>In a TDF program there will usually be references to <code>TAG</code>s
			which are not defined in TDF; their definitions are intended to be
			supplied by a host system in system specific libraries.</para>

		<para>These <code>TAG</code>s will be declared (but not defined) in a TDF
			<code>CAPSULE</code> and will be specified by external linkages of the
			<code>CAPSULE</code> with <code>EXTERNAL</code>s containg either
			<code>TDFIDENT</code>s or <code>UNIQUE</code>s. In previous versions of
			TDF, the external names required by system linking could only be derived
			from those <code>EXTERNAL</code>s.</para>

		<para>Version 4.0 gives an alternative method of constructing extra-TDF names.
			Each global <code>TAG</code> declaration can now contain a
			<code>STRING</code> signature field which may be used to derive the
			external name required by the system.</para>

		<para>This addition is principally motivated by the various &ldquo;name
			mangling&rdquo; schemes of C++. The <code>STRING</code> signature can be
			constructed by concatenations and token expansions. Suitable usages of
			<code>TOKEN</code>s can ensure that the particular form of name-mangling
			can be deferred to installation time and hence allow, at least
			conceptually, linking with different C++ libraries.</para>

		<para>As well as <code>TAG</code> declarations, <code>TAG</code> definitions are
			allowed to have signatures.	The restriction that the signature (if
			present) of a <code>TAG</code> definition being identical to its
			corresponding definition could allow type checking across seperately
			compiled <code>CAPSULE</code>s.</para>

		<para>Similar considerations apply to <code>TOKEN</code>s; although token names
			are totally internal to TDF, it would allow one to check that a token
			declared in one <code>CAPSULE</code> has the same &ldquo;type&rdquo; as
			its definition in another.</para>
	</section>

	<section id="dynamic-initialisation">
		<title>Dynamic initialisation</title>

		<para>The dynamic initialisation of global variables is required for languages
			like C++. Previous to version 4.0, the only initialisations permissable
			were load-time ones; in particular no procedure calls were allowed in
			forming the initialising value. Version 4.0 introduces the constructor
			<replaceable>initial_value</replaceable> to remedy this situation.</para>

		<para>Several different implementation strategies could be considered for this.
			Basically, one must ensure that all the initial_value expressions are
			transformed into assignments to globals in some procedure. One might
			expect that there would be one such procedure invented for each
			<code>CAPSULE</code> and that somehow this procedure is called before the
			main program.</para>

		<para>This raises problems on how we can name this procedure so that it can be
			identified as being a special initialising procedure. Some UNIX linkers
			reserve a name like <replaceable>__init</replaceable> specially so that all
			instances of it from different modules can be called before the main
			procedure. Other cases may require a pre-pass on the
			<replaceable>.o</replaceable> files prior to system linking.</para>
	</section>
</chapter>
